// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_USERINTERACTION_USERINTERACTIONFB_H_
#define FLATBUFFERS_GENERATED_USERINTERACTION_USERINTERACTIONFB_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

namespace UserInteractionFB {

struct SingleVec2;

struct SingleVec4;

struct ArrayOfVec2;
struct ArrayOfVec2Builder;

struct ArrayOfVec4;
struct ArrayOfVec4Builder;

struct EventMouseMotion;
struct EventMouseMotionBuilder;

struct EventMouseWheel;
struct EventMouseWheelBuilder;

struct EventMouseButton;
struct EventMouseButtonBuilder;

struct EventTextInput;
struct EventTextInputBuilder;

struct EventKeyboard;
struct EventKeyboardBuilder;

struct Event;
struct EventBuilder;

inline const ::flatbuffers::TypeTable *SingleVec2TypeTable();

inline const ::flatbuffers::TypeTable *SingleVec4TypeTable();

inline const ::flatbuffers::TypeTable *ArrayOfVec2TypeTable();

inline const ::flatbuffers::TypeTable *ArrayOfVec4TypeTable();

inline const ::flatbuffers::TypeTable *EventMouseMotionTypeTable();

inline const ::flatbuffers::TypeTable *EventMouseWheelTypeTable();

inline const ::flatbuffers::TypeTable *EventMouseButtonTypeTable();

inline const ::flatbuffers::TypeTable *EventTextInputTypeTable();

inline const ::flatbuffers::TypeTable *EventKeyboardTypeTable();

inline const ::flatbuffers::TypeTable *EventTypeTable();

enum MouseButton : uint8_t {
  MouseButton_None = 0,
  MouseButton_Left = 1,
  MouseButton_Right = 2,
  MouseButton_Middle = 3,
  MouseButton_X1 = 4,
  MouseButton_X2 = 5,
  MouseButton_MIN = MouseButton_None,
  MouseButton_MAX = MouseButton_X2
};

inline const MouseButton (&EnumValuesMouseButton())[6] {
  static const MouseButton values[] = {
    MouseButton_None,
    MouseButton_Left,
    MouseButton_Right,
    MouseButton_Middle,
    MouseButton_X1,
    MouseButton_X2
  };
  return values;
}

inline const char * const *EnumNamesMouseButton() {
  static const char * const names[7] = {
    "None",
    "Left",
    "Right",
    "Middle",
    "X1",
    "X2",
    nullptr
  };
  return names;
}

inline const char *EnumNameMouseButton(MouseButton e) {
  if (::flatbuffers::IsOutRange(e, MouseButton_None, MouseButton_X2)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMouseButton()[index];
}

enum MouseButtonEventType : uint8_t {
  MouseButtonEventType_Up = 0,
  MouseButtonEventType_Down = 1,
  MouseButtonEventType_MIN = MouseButtonEventType_Up,
  MouseButtonEventType_MAX = MouseButtonEventType_Down
};

inline const MouseButtonEventType (&EnumValuesMouseButtonEventType())[2] {
  static const MouseButtonEventType values[] = {
    MouseButtonEventType_Up,
    MouseButtonEventType_Down
  };
  return values;
}

inline const char * const *EnumNamesMouseButtonEventType() {
  static const char * const names[3] = {
    "Up",
    "Down",
    nullptr
  };
  return names;
}

inline const char *EnumNameMouseButtonEventType(MouseButtonEventType e) {
  if (::flatbuffers::IsOutRange(e, MouseButtonEventType_Up, MouseButtonEventType_Down)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMouseButtonEventType()[index];
}

enum KeyModifiers : uint8_t {
  KeyModifiers_None = 0,
  KeyModifiers_Ctrl = 1,
  KeyModifiers_Shift = 2,
  KeyModifiers_Alt = 4,
  KeyModifiers_Super = 8,
  KeyModifiers_MIN = KeyModifiers_None,
  KeyModifiers_MAX = KeyModifiers_Super
};

inline const KeyModifiers (&EnumValuesKeyModifiers())[5] {
  static const KeyModifiers values[] = {
    KeyModifiers_None,
    KeyModifiers_Ctrl,
    KeyModifiers_Shift,
    KeyModifiers_Alt,
    KeyModifiers_Super
  };
  return values;
}

inline const char * const *EnumNamesKeyModifiers() {
  static const char * const names[10] = {
    "None",
    "Ctrl",
    "Shift",
    "",
    "Alt",
    "",
    "",
    "",
    "Super",
    nullptr
  };
  return names;
}

inline const char *EnumNameKeyModifiers(KeyModifiers e) {
  if (::flatbuffers::IsOutRange(e, KeyModifiers_None, KeyModifiers_Super)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesKeyModifiers()[index];
}

enum KeyCode : uint32_t {
  KeyCode_Key_None = 0,
  KeyCode_Key_Tab = 1,
  KeyCode_Key_LeftArrow = 2,
  KeyCode_Key_RightArrow = 3,
  KeyCode_Key_UpArrow = 4,
  KeyCode_Key_DownArrow = 5,
  KeyCode_Key_PageUp = 6,
  KeyCode_Key_PageDown = 7,
  KeyCode_Key_Home = 8,
  KeyCode_Key_End = 9,
  KeyCode_Key_Insert = 10,
  KeyCode_Key_Delete = 11,
  KeyCode_Key_Backspace = 12,
  KeyCode_Key_Space = 13,
  KeyCode_Key_Enter = 14,
  KeyCode_Key_Escape = 15,
  KeyCode_Key_Apostrophe = 16,
  KeyCode_Key_Comma = 17,
  KeyCode_Key_Minus = 18,
  KeyCode_Key_Period = 19,
  KeyCode_Key_Slash = 20,
  KeyCode_Key_Semicolon = 21,
  KeyCode_Key_Equal = 22,
  KeyCode_Key_LeftBracket = 23,
  KeyCode_Key_Backslash = 24,
  KeyCode_Key_RightBracket = 25,
  KeyCode_Key_GraveAccent = 26,
  KeyCode_Key_CapsLock = 27,
  KeyCode_Key_ScrollLock = 28,
  KeyCode_Key_NumLock = 29,
  KeyCode_Key_PrintScreen = 30,
  KeyCode_Key_Pause = 31,
  KeyCode_Key_Keypad0 = 32,
  KeyCode_Key_Keypad1 = 33,
  KeyCode_Key_Keypad2 = 34,
  KeyCode_Key_Keypad3 = 35,
  KeyCode_Key_Keypad4 = 36,
  KeyCode_Key_Keypad5 = 37,
  KeyCode_Key_Keypad6 = 38,
  KeyCode_Key_Keypad7 = 39,
  KeyCode_Key_Keypad8 = 40,
  KeyCode_Key_Keypad9 = 41,
  KeyCode_Key_KeypadDecimal = 42,
  KeyCode_Key_KeypadDivide = 43,
  KeyCode_Key_KeypadMultiply = 44,
  KeyCode_Key_KeypadSubtract = 45,
  KeyCode_Key_KeypadAdd = 46,
  KeyCode_Key_KeypadEnter = 47,
  KeyCode_Key_KeypadEqual = 48,
  KeyCode_Key_LeftCtrl = 49,
  KeyCode_Key_LeftShift = 50,
  KeyCode_Key_LeftAlt = 51,
  KeyCode_Key_LeftSuper = 52,
  KeyCode_Key_RightCtrl = 53,
  KeyCode_Key_RightShift = 54,
  KeyCode_Key_RightAlt = 55,
  KeyCode_Key_RightSuper = 56,
  KeyCode_Key_Menu = 57,
  KeyCode_Key_0 = 58,
  KeyCode_Key_1 = 59,
  KeyCode_Key_2 = 60,
  KeyCode_Key_3 = 61,
  KeyCode_Key_4 = 62,
  KeyCode_Key_5 = 63,
  KeyCode_Key_6 = 64,
  KeyCode_Key_7 = 65,
  KeyCode_Key_8 = 66,
  KeyCode_Key_9 = 67,
  KeyCode_Key_A = 68,
  KeyCode_Key_B = 69,
  KeyCode_Key_C = 70,
  KeyCode_Key_D = 71,
  KeyCode_Key_E = 72,
  KeyCode_Key_F = 73,
  KeyCode_Key_G = 74,
  KeyCode_Key_H = 75,
  KeyCode_Key_I = 76,
  KeyCode_Key_J = 77,
  KeyCode_Key_K = 78,
  KeyCode_Key_L = 79,
  KeyCode_Key_M = 80,
  KeyCode_Key_N = 81,
  KeyCode_Key_O = 82,
  KeyCode_Key_P = 83,
  KeyCode_Key_Q = 84,
  KeyCode_Key_R = 85,
  KeyCode_Key_S = 86,
  KeyCode_Key_T = 87,
  KeyCode_Key_U = 88,
  KeyCode_Key_V = 89,
  KeyCode_Key_W = 90,
  KeyCode_Key_X = 91,
  KeyCode_Key_Y = 92,
  KeyCode_Key_Z = 93,
  KeyCode_Key_F1 = 94,
  KeyCode_Key_F2 = 95,
  KeyCode_Key_F3 = 96,
  KeyCode_Key_F4 = 97,
  KeyCode_Key_F5 = 98,
  KeyCode_Key_F6 = 99,
  KeyCode_Key_F7 = 100,
  KeyCode_Key_F8 = 101,
  KeyCode_Key_F9 = 102,
  KeyCode_Key_F10 = 103,
  KeyCode_Key_F11 = 104,
  KeyCode_Key_F12 = 105,
  KeyCode_Key_F13 = 106,
  KeyCode_Key_F14 = 107,
  KeyCode_Key_F15 = 108,
  KeyCode_Key_F16 = 109,
  KeyCode_Key_F17 = 110,
  KeyCode_Key_F18 = 111,
  KeyCode_Key_F19 = 112,
  KeyCode_Key_F20 = 113,
  KeyCode_Key_F21 = 114,
  KeyCode_Key_F22 = 115,
  KeyCode_Key_F23 = 116,
  KeyCode_Key_F24 = 117,
  KeyCode_Key_AppBack = 118,
  KeyCode_Key_AppForward = 119,
  KeyCode_MIN = KeyCode_Key_None,
  KeyCode_MAX = KeyCode_Key_AppForward
};

inline const KeyCode (&EnumValuesKeyCode())[120] {
  static const KeyCode values[] = {
    KeyCode_Key_None,
    KeyCode_Key_Tab,
    KeyCode_Key_LeftArrow,
    KeyCode_Key_RightArrow,
    KeyCode_Key_UpArrow,
    KeyCode_Key_DownArrow,
    KeyCode_Key_PageUp,
    KeyCode_Key_PageDown,
    KeyCode_Key_Home,
    KeyCode_Key_End,
    KeyCode_Key_Insert,
    KeyCode_Key_Delete,
    KeyCode_Key_Backspace,
    KeyCode_Key_Space,
    KeyCode_Key_Enter,
    KeyCode_Key_Escape,
    KeyCode_Key_Apostrophe,
    KeyCode_Key_Comma,
    KeyCode_Key_Minus,
    KeyCode_Key_Period,
    KeyCode_Key_Slash,
    KeyCode_Key_Semicolon,
    KeyCode_Key_Equal,
    KeyCode_Key_LeftBracket,
    KeyCode_Key_Backslash,
    KeyCode_Key_RightBracket,
    KeyCode_Key_GraveAccent,
    KeyCode_Key_CapsLock,
    KeyCode_Key_ScrollLock,
    KeyCode_Key_NumLock,
    KeyCode_Key_PrintScreen,
    KeyCode_Key_Pause,
    KeyCode_Key_Keypad0,
    KeyCode_Key_Keypad1,
    KeyCode_Key_Keypad2,
    KeyCode_Key_Keypad3,
    KeyCode_Key_Keypad4,
    KeyCode_Key_Keypad5,
    KeyCode_Key_Keypad6,
    KeyCode_Key_Keypad7,
    KeyCode_Key_Keypad8,
    KeyCode_Key_Keypad9,
    KeyCode_Key_KeypadDecimal,
    KeyCode_Key_KeypadDivide,
    KeyCode_Key_KeypadMultiply,
    KeyCode_Key_KeypadSubtract,
    KeyCode_Key_KeypadAdd,
    KeyCode_Key_KeypadEnter,
    KeyCode_Key_KeypadEqual,
    KeyCode_Key_LeftCtrl,
    KeyCode_Key_LeftShift,
    KeyCode_Key_LeftAlt,
    KeyCode_Key_LeftSuper,
    KeyCode_Key_RightCtrl,
    KeyCode_Key_RightShift,
    KeyCode_Key_RightAlt,
    KeyCode_Key_RightSuper,
    KeyCode_Key_Menu,
    KeyCode_Key_0,
    KeyCode_Key_1,
    KeyCode_Key_2,
    KeyCode_Key_3,
    KeyCode_Key_4,
    KeyCode_Key_5,
    KeyCode_Key_6,
    KeyCode_Key_7,
    KeyCode_Key_8,
    KeyCode_Key_9,
    KeyCode_Key_A,
    KeyCode_Key_B,
    KeyCode_Key_C,
    KeyCode_Key_D,
    KeyCode_Key_E,
    KeyCode_Key_F,
    KeyCode_Key_G,
    KeyCode_Key_H,
    KeyCode_Key_I,
    KeyCode_Key_J,
    KeyCode_Key_K,
    KeyCode_Key_L,
    KeyCode_Key_M,
    KeyCode_Key_N,
    KeyCode_Key_O,
    KeyCode_Key_P,
    KeyCode_Key_Q,
    KeyCode_Key_R,
    KeyCode_Key_S,
    KeyCode_Key_T,
    KeyCode_Key_U,
    KeyCode_Key_V,
    KeyCode_Key_W,
    KeyCode_Key_X,
    KeyCode_Key_Y,
    KeyCode_Key_Z,
    KeyCode_Key_F1,
    KeyCode_Key_F2,
    KeyCode_Key_F3,
    KeyCode_Key_F4,
    KeyCode_Key_F5,
    KeyCode_Key_F6,
    KeyCode_Key_F7,
    KeyCode_Key_F8,
    KeyCode_Key_F9,
    KeyCode_Key_F10,
    KeyCode_Key_F11,
    KeyCode_Key_F12,
    KeyCode_Key_F13,
    KeyCode_Key_F14,
    KeyCode_Key_F15,
    KeyCode_Key_F16,
    KeyCode_Key_F17,
    KeyCode_Key_F18,
    KeyCode_Key_F19,
    KeyCode_Key_F20,
    KeyCode_Key_F21,
    KeyCode_Key_F22,
    KeyCode_Key_F23,
    KeyCode_Key_F24,
    KeyCode_Key_AppBack,
    KeyCode_Key_AppForward
  };
  return values;
}

inline const char * const *EnumNamesKeyCode() {
  static const char * const names[121] = {
    "Key_None",
    "Key_Tab",
    "Key_LeftArrow",
    "Key_RightArrow",
    "Key_UpArrow",
    "Key_DownArrow",
    "Key_PageUp",
    "Key_PageDown",
    "Key_Home",
    "Key_End",
    "Key_Insert",
    "Key_Delete",
    "Key_Backspace",
    "Key_Space",
    "Key_Enter",
    "Key_Escape",
    "Key_Apostrophe",
    "Key_Comma",
    "Key_Minus",
    "Key_Period",
    "Key_Slash",
    "Key_Semicolon",
    "Key_Equal",
    "Key_LeftBracket",
    "Key_Backslash",
    "Key_RightBracket",
    "Key_GraveAccent",
    "Key_CapsLock",
    "Key_ScrollLock",
    "Key_NumLock",
    "Key_PrintScreen",
    "Key_Pause",
    "Key_Keypad0",
    "Key_Keypad1",
    "Key_Keypad2",
    "Key_Keypad3",
    "Key_Keypad4",
    "Key_Keypad5",
    "Key_Keypad6",
    "Key_Keypad7",
    "Key_Keypad8",
    "Key_Keypad9",
    "Key_KeypadDecimal",
    "Key_KeypadDivide",
    "Key_KeypadMultiply",
    "Key_KeypadSubtract",
    "Key_KeypadAdd",
    "Key_KeypadEnter",
    "Key_KeypadEqual",
    "Key_LeftCtrl",
    "Key_LeftShift",
    "Key_LeftAlt",
    "Key_LeftSuper",
    "Key_RightCtrl",
    "Key_RightShift",
    "Key_RightAlt",
    "Key_RightSuper",
    "Key_Menu",
    "Key_0",
    "Key_1",
    "Key_2",
    "Key_3",
    "Key_4",
    "Key_5",
    "Key_6",
    "Key_7",
    "Key_8",
    "Key_9",
    "Key_A",
    "Key_B",
    "Key_C",
    "Key_D",
    "Key_E",
    "Key_F",
    "Key_G",
    "Key_H",
    "Key_I",
    "Key_J",
    "Key_K",
    "Key_L",
    "Key_M",
    "Key_N",
    "Key_O",
    "Key_P",
    "Key_Q",
    "Key_R",
    "Key_S",
    "Key_T",
    "Key_U",
    "Key_V",
    "Key_W",
    "Key_X",
    "Key_Y",
    "Key_Z",
    "Key_F1",
    "Key_F2",
    "Key_F3",
    "Key_F4",
    "Key_F5",
    "Key_F6",
    "Key_F7",
    "Key_F8",
    "Key_F9",
    "Key_F10",
    "Key_F11",
    "Key_F12",
    "Key_F13",
    "Key_F14",
    "Key_F15",
    "Key_F16",
    "Key_F17",
    "Key_F18",
    "Key_F19",
    "Key_F20",
    "Key_F21",
    "Key_F22",
    "Key_F23",
    "Key_F24",
    "Key_AppBack",
    "Key_AppForward",
    nullptr
  };
  return names;
}

inline const char *EnumNameKeyCode(KeyCode e) {
  if (::flatbuffers::IsOutRange(e, KeyCode_Key_None, KeyCode_Key_AppForward)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesKeyCode()[index];
}

enum UserInteraction : uint8_t {
  UserInteraction_NONE = 0,
  UserInteraction_EventMouseMotion = 1,
  UserInteraction_EventMouseWheel = 2,
  UserInteraction_EventMouseButton = 3,
  UserInteraction_EventTextInput = 4,
  UserInteraction_EventKeyboard = 5,
  UserInteraction_MIN = UserInteraction_NONE,
  UserInteraction_MAX = UserInteraction_EventKeyboard
};

inline const UserInteraction (&EnumValuesUserInteraction())[6] {
  static const UserInteraction values[] = {
    UserInteraction_NONE,
    UserInteraction_EventMouseMotion,
    UserInteraction_EventMouseWheel,
    UserInteraction_EventMouseButton,
    UserInteraction_EventTextInput,
    UserInteraction_EventKeyboard
  };
  return values;
}

inline const char * const *EnumNamesUserInteraction() {
  static const char * const names[7] = {
    "NONE",
    "EventMouseMotion",
    "EventMouseWheel",
    "EventMouseButton",
    "EventTextInput",
    "EventKeyboard",
    nullptr
  };
  return names;
}

inline const char *EnumNameUserInteraction(UserInteraction e) {
  if (::flatbuffers::IsOutRange(e, UserInteraction_NONE, UserInteraction_EventKeyboard)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesUserInteraction()[index];
}

template<typename T> struct UserInteractionTraits {
  static const UserInteraction enum_value = UserInteraction_NONE;
};

template<> struct UserInteractionTraits<UserInteractionFB::EventMouseMotion> {
  static const UserInteraction enum_value = UserInteraction_EventMouseMotion;
};

template<> struct UserInteractionTraits<UserInteractionFB::EventMouseWheel> {
  static const UserInteraction enum_value = UserInteraction_EventMouseWheel;
};

template<> struct UserInteractionTraits<UserInteractionFB::EventMouseButton> {
  static const UserInteraction enum_value = UserInteraction_EventMouseButton;
};

template<> struct UserInteractionTraits<UserInteractionFB::EventTextInput> {
  static const UserInteraction enum_value = UserInteraction_EventTextInput;
};

template<> struct UserInteractionTraits<UserInteractionFB::EventKeyboard> {
  static const UserInteraction enum_value = UserInteraction_EventKeyboard;
};

bool VerifyUserInteraction(::flatbuffers::Verifier &verifier, const void *obj, UserInteraction type);
bool VerifyUserInteractionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) SingleVec2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SingleVec2TypeTable();
  }
  SingleVec2()
      : x_(0),
        y_(0) {
  }
  SingleVec2(float _x, float _y)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(SingleVec2, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) SingleVec4 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SingleVec4TypeTable();
  }
  SingleVec4()
      : x_(0),
        y_(0),
        z_(0),
        w_(0) {
  }
  SingleVec4(float _x, float _y, float _z, float _w)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)),
        z_(::flatbuffers::EndianScalar(_z)),
        w_(::flatbuffers::EndianScalar(_w)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return ::flatbuffers::EndianScalar(z_);
  }
  float w() const {
    return ::flatbuffers::EndianScalar(w_);
  }
};
FLATBUFFERS_STRUCT_END(SingleVec4, 16);

struct ArrayOfVec2 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ArrayOfVec2Builder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ArrayOfVec2TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_XS = 4,
    VT_YS = 6
  };
  const ::flatbuffers::Vector<float> *xs() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_XS);
  }
  const ::flatbuffers::Vector<float> *ys() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_YS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_XS) &&
           verifier.VerifyVector(xs()) &&
           VerifyOffset(verifier, VT_YS) &&
           verifier.VerifyVector(ys()) &&
           verifier.EndTable();
  }
};

struct ArrayOfVec2Builder {
  typedef ArrayOfVec2 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_xs(::flatbuffers::Offset<::flatbuffers::Vector<float>> xs) {
    fbb_.AddOffset(ArrayOfVec2::VT_XS, xs);
  }
  void add_ys(::flatbuffers::Offset<::flatbuffers::Vector<float>> ys) {
    fbb_.AddOffset(ArrayOfVec2::VT_YS, ys);
  }
  explicit ArrayOfVec2Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ArrayOfVec2> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ArrayOfVec2>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ArrayOfVec2> CreateArrayOfVec2(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> xs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> ys = 0) {
  ArrayOfVec2Builder builder_(_fbb);
  builder_.add_ys(ys);
  builder_.add_xs(xs);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ArrayOfVec2> CreateArrayOfVec2Direct(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *xs = nullptr,
    const std::vector<float> *ys = nullptr) {
  auto xs__ = xs ? _fbb.CreateVector<float>(*xs) : 0;
  auto ys__ = ys ? _fbb.CreateVector<float>(*ys) : 0;
  return UserInteractionFB::CreateArrayOfVec2(
      _fbb,
      xs__,
      ys__);
}

struct ArrayOfVec4 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ArrayOfVec4Builder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ArrayOfVec4TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_XS = 4,
    VT_YS = 6,
    VT_ZS = 8,
    VT_WS = 10
  };
  const ::flatbuffers::Vector<float> *xs() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_XS);
  }
  const ::flatbuffers::Vector<float> *ys() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_YS);
  }
  const ::flatbuffers::Vector<float> *zs() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_ZS);
  }
  const ::flatbuffers::Vector<float> *ws() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_WS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_XS) &&
           verifier.VerifyVector(xs()) &&
           VerifyOffset(verifier, VT_YS) &&
           verifier.VerifyVector(ys()) &&
           VerifyOffset(verifier, VT_ZS) &&
           verifier.VerifyVector(zs()) &&
           VerifyOffset(verifier, VT_WS) &&
           verifier.VerifyVector(ws()) &&
           verifier.EndTable();
  }
};

struct ArrayOfVec4Builder {
  typedef ArrayOfVec4 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_xs(::flatbuffers::Offset<::flatbuffers::Vector<float>> xs) {
    fbb_.AddOffset(ArrayOfVec4::VT_XS, xs);
  }
  void add_ys(::flatbuffers::Offset<::flatbuffers::Vector<float>> ys) {
    fbb_.AddOffset(ArrayOfVec4::VT_YS, ys);
  }
  void add_zs(::flatbuffers::Offset<::flatbuffers::Vector<float>> zs) {
    fbb_.AddOffset(ArrayOfVec4::VT_ZS, zs);
  }
  void add_ws(::flatbuffers::Offset<::flatbuffers::Vector<float>> ws) {
    fbb_.AddOffset(ArrayOfVec4::VT_WS, ws);
  }
  explicit ArrayOfVec4Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ArrayOfVec4> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ArrayOfVec4>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ArrayOfVec4> CreateArrayOfVec4(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> xs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> ys = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> zs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> ws = 0) {
  ArrayOfVec4Builder builder_(_fbb);
  builder_.add_ws(ws);
  builder_.add_zs(zs);
  builder_.add_ys(ys);
  builder_.add_xs(xs);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ArrayOfVec4> CreateArrayOfVec4Direct(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *xs = nullptr,
    const std::vector<float> *ys = nullptr,
    const std::vector<float> *zs = nullptr,
    const std::vector<float> *ws = nullptr) {
  auto xs__ = xs ? _fbb.CreateVector<float>(*xs) : 0;
  auto ys__ = ys ? _fbb.CreateVector<float>(*ys) : 0;
  auto zs__ = zs ? _fbb.CreateVector<float>(*zs) : 0;
  auto ws__ = ws ? _fbb.CreateVector<float>(*ws) : 0;
  return UserInteractionFB::CreateArrayOfVec4(
      _fbb,
      xs__,
      ys__,
      zs__,
      ws__);
}

struct EventMouseMotion FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EventMouseMotionBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return EventMouseMotionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POS = 4,
    VT_MOUSE_ID = 6,
    VT_IS_TOUCH = 8
  };
  const UserInteractionFB::SingleVec2 *pos() const {
    return GetStruct<const UserInteractionFB::SingleVec2 *>(VT_POS);
  }
  uint32_t mouse_id() const {
    return GetField<uint32_t>(VT_MOUSE_ID, 0);
  }
  bool is_touch() const {
    return GetField<uint8_t>(VT_IS_TOUCH, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<UserInteractionFB::SingleVec2>(verifier, VT_POS, 4) &&
           VerifyField<uint32_t>(verifier, VT_MOUSE_ID, 4) &&
           VerifyField<uint8_t>(verifier, VT_IS_TOUCH, 1) &&
           verifier.EndTable();
  }
};

struct EventMouseMotionBuilder {
  typedef EventMouseMotion Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pos(const UserInteractionFB::SingleVec2 *pos) {
    fbb_.AddStruct(EventMouseMotion::VT_POS, pos);
  }
  void add_mouse_id(uint32_t mouse_id) {
    fbb_.AddElement<uint32_t>(EventMouseMotion::VT_MOUSE_ID, mouse_id, 0);
  }
  void add_is_touch(bool is_touch) {
    fbb_.AddElement<uint8_t>(EventMouseMotion::VT_IS_TOUCH, static_cast<uint8_t>(is_touch), 0);
  }
  explicit EventMouseMotionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EventMouseMotion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EventMouseMotion>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EventMouseMotion> CreateEventMouseMotion(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const UserInteractionFB::SingleVec2 *pos = nullptr,
    uint32_t mouse_id = 0,
    bool is_touch = false) {
  EventMouseMotionBuilder builder_(_fbb);
  builder_.add_mouse_id(mouse_id);
  builder_.add_pos(pos);
  builder_.add_is_touch(is_touch);
  return builder_.Finish();
}

struct EventMouseWheel FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EventMouseWheelBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return EventMouseWheelTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POS = 4,
    VT_MOUSE_ID = 6,
    VT_IS_TOUCH = 8
  };
  const UserInteractionFB::SingleVec2 *pos() const {
    return GetStruct<const UserInteractionFB::SingleVec2 *>(VT_POS);
  }
  uint32_t mouse_id() const {
    return GetField<uint32_t>(VT_MOUSE_ID, 0);
  }
  bool is_touch() const {
    return GetField<uint8_t>(VT_IS_TOUCH, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<UserInteractionFB::SingleVec2>(verifier, VT_POS, 4) &&
           VerifyField<uint32_t>(verifier, VT_MOUSE_ID, 4) &&
           VerifyField<uint8_t>(verifier, VT_IS_TOUCH, 1) &&
           verifier.EndTable();
  }
};

struct EventMouseWheelBuilder {
  typedef EventMouseWheel Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pos(const UserInteractionFB::SingleVec2 *pos) {
    fbb_.AddStruct(EventMouseWheel::VT_POS, pos);
  }
  void add_mouse_id(uint32_t mouse_id) {
    fbb_.AddElement<uint32_t>(EventMouseWheel::VT_MOUSE_ID, mouse_id, 0);
  }
  void add_is_touch(bool is_touch) {
    fbb_.AddElement<uint8_t>(EventMouseWheel::VT_IS_TOUCH, static_cast<uint8_t>(is_touch), 0);
  }
  explicit EventMouseWheelBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EventMouseWheel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EventMouseWheel>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EventMouseWheel> CreateEventMouseWheel(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const UserInteractionFB::SingleVec2 *pos = nullptr,
    uint32_t mouse_id = 0,
    bool is_touch = false) {
  EventMouseWheelBuilder builder_(_fbb);
  builder_.add_mouse_id(mouse_id);
  builder_.add_pos(pos);
  builder_.add_is_touch(is_touch);
  return builder_.Finish();
}

struct EventMouseButton FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EventMouseButtonBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return EventMouseButtonTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POS = 4,
    VT_MOUSE_ID = 6,
    VT_IS_TOUCH = 8,
    VT_BUTTON = 10,
    VT_TYPE = 12
  };
  const UserInteractionFB::SingleVec2 *pos() const {
    return GetStruct<const UserInteractionFB::SingleVec2 *>(VT_POS);
  }
  uint32_t mouse_id() const {
    return GetField<uint32_t>(VT_MOUSE_ID, 0);
  }
  bool is_touch() const {
    return GetField<uint8_t>(VT_IS_TOUCH, 0) != 0;
  }
  UserInteractionFB::MouseButton button() const {
    return static_cast<UserInteractionFB::MouseButton>(GetField<uint8_t>(VT_BUTTON, 0));
  }
  UserInteractionFB::MouseButtonEventType type() const {
    return static_cast<UserInteractionFB::MouseButtonEventType>(GetField<uint8_t>(VT_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<UserInteractionFB::SingleVec2>(verifier, VT_POS, 4) &&
           VerifyField<uint32_t>(verifier, VT_MOUSE_ID, 4) &&
           VerifyField<uint8_t>(verifier, VT_IS_TOUCH, 1) &&
           VerifyField<uint8_t>(verifier, VT_BUTTON, 1) &&
           VerifyField<uint8_t>(verifier, VT_TYPE, 1) &&
           verifier.EndTable();
  }
};

struct EventMouseButtonBuilder {
  typedef EventMouseButton Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pos(const UserInteractionFB::SingleVec2 *pos) {
    fbb_.AddStruct(EventMouseButton::VT_POS, pos);
  }
  void add_mouse_id(uint32_t mouse_id) {
    fbb_.AddElement<uint32_t>(EventMouseButton::VT_MOUSE_ID, mouse_id, 0);
  }
  void add_is_touch(bool is_touch) {
    fbb_.AddElement<uint8_t>(EventMouseButton::VT_IS_TOUCH, static_cast<uint8_t>(is_touch), 0);
  }
  void add_button(UserInteractionFB::MouseButton button) {
    fbb_.AddElement<uint8_t>(EventMouseButton::VT_BUTTON, static_cast<uint8_t>(button), 0);
  }
  void add_type(UserInteractionFB::MouseButtonEventType type) {
    fbb_.AddElement<uint8_t>(EventMouseButton::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  explicit EventMouseButtonBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EventMouseButton> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EventMouseButton>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EventMouseButton> CreateEventMouseButton(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const UserInteractionFB::SingleVec2 *pos = nullptr,
    uint32_t mouse_id = 0,
    bool is_touch = false,
    UserInteractionFB::MouseButton button = UserInteractionFB::MouseButton_None,
    UserInteractionFB::MouseButtonEventType type = UserInteractionFB::MouseButtonEventType_Up) {
  EventMouseButtonBuilder builder_(_fbb);
  builder_.add_mouse_id(mouse_id);
  builder_.add_pos(pos);
  builder_.add_type(type);
  builder_.add_button(button);
  builder_.add_is_touch(is_touch);
  return builder_.Finish();
}

struct EventTextInput FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EventTextInputBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return EventTextInputTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEXT = 4
  };
  const ::flatbuffers::String *text() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TEXT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           verifier.EndTable();
  }
};

struct EventTextInputBuilder {
  typedef EventTextInput Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_text(::flatbuffers::Offset<::flatbuffers::String> text) {
    fbb_.AddOffset(EventTextInput::VT_TEXT, text);
  }
  explicit EventTextInputBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EventTextInput> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EventTextInput>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EventTextInput> CreateEventTextInput(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> text = 0) {
  EventTextInputBuilder builder_(_fbb);
  builder_.add_text(text);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<EventTextInput> CreateEventTextInputDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *text = nullptr) {
  auto text__ = text ? _fbb.CreateString(text) : 0;
  return UserInteractionFB::CreateEventTextInput(
      _fbb,
      text__);
}

struct EventKeyboard FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EventKeyboardBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return EventKeyboardTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODIFIERS = 4,
    VT_CODE = 6,
    VT_IS_DOWN = 8,
    VT_NATIVE_SYM = 10,
    VT_SCANCODE = 12
  };
  UserInteractionFB::KeyModifiers modifiers() const {
    return static_cast<UserInteractionFB::KeyModifiers>(GetField<uint8_t>(VT_MODIFIERS, 0));
  }
  UserInteractionFB::KeyCode code() const {
    return static_cast<UserInteractionFB::KeyCode>(GetField<uint32_t>(VT_CODE, 0));
  }
  bool is_down() const {
    return GetField<uint8_t>(VT_IS_DOWN, 0) != 0;
  }
  uint32_t native_sym() const {
    return GetField<uint32_t>(VT_NATIVE_SYM, 0);
  }
  uint32_t scancode() const {
    return GetField<uint32_t>(VT_SCANCODE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MODIFIERS, 1) &&
           VerifyField<uint32_t>(verifier, VT_CODE, 4) &&
           VerifyField<uint8_t>(verifier, VT_IS_DOWN, 1) &&
           VerifyField<uint32_t>(verifier, VT_NATIVE_SYM, 4) &&
           VerifyField<uint32_t>(verifier, VT_SCANCODE, 4) &&
           verifier.EndTable();
  }
};

struct EventKeyboardBuilder {
  typedef EventKeyboard Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_modifiers(UserInteractionFB::KeyModifiers modifiers) {
    fbb_.AddElement<uint8_t>(EventKeyboard::VT_MODIFIERS, static_cast<uint8_t>(modifiers), 0);
  }
  void add_code(UserInteractionFB::KeyCode code) {
    fbb_.AddElement<uint32_t>(EventKeyboard::VT_CODE, static_cast<uint32_t>(code), 0);
  }
  void add_is_down(bool is_down) {
    fbb_.AddElement<uint8_t>(EventKeyboard::VT_IS_DOWN, static_cast<uint8_t>(is_down), 0);
  }
  void add_native_sym(uint32_t native_sym) {
    fbb_.AddElement<uint32_t>(EventKeyboard::VT_NATIVE_SYM, native_sym, 0);
  }
  void add_scancode(uint32_t scancode) {
    fbb_.AddElement<uint32_t>(EventKeyboard::VT_SCANCODE, scancode, 0);
  }
  explicit EventKeyboardBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EventKeyboard> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EventKeyboard>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EventKeyboard> CreateEventKeyboard(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    UserInteractionFB::KeyModifiers modifiers = UserInteractionFB::KeyModifiers_None,
    UserInteractionFB::KeyCode code = UserInteractionFB::KeyCode_Key_None,
    bool is_down = false,
    uint32_t native_sym = 0,
    uint32_t scancode = 0) {
  EventKeyboardBuilder builder_(_fbb);
  builder_.add_scancode(scancode);
  builder_.add_native_sym(native_sym);
  builder_.add_code(code);
  builder_.add_is_down(is_down);
  builder_.add_modifiers(modifiers);
  return builder_.Finish();
}

struct Event FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EventBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return EventTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EVENT_TYPE = 4,
    VT_EVENT = 6
  };
  UserInteractionFB::UserInteraction event_type() const {
    return static_cast<UserInteractionFB::UserInteraction>(GetField<uint8_t>(VT_EVENT_TYPE, 0));
  }
  const void *event() const {
    return GetPointer<const void *>(VT_EVENT);
  }
  template<typename T> const T *event_as() const;
  const UserInteractionFB::EventMouseMotion *event_as_EventMouseMotion() const {
    return event_type() == UserInteractionFB::UserInteraction_EventMouseMotion ? static_cast<const UserInteractionFB::EventMouseMotion *>(event()) : nullptr;
  }
  const UserInteractionFB::EventMouseWheel *event_as_EventMouseWheel() const {
    return event_type() == UserInteractionFB::UserInteraction_EventMouseWheel ? static_cast<const UserInteractionFB::EventMouseWheel *>(event()) : nullptr;
  }
  const UserInteractionFB::EventMouseButton *event_as_EventMouseButton() const {
    return event_type() == UserInteractionFB::UserInteraction_EventMouseButton ? static_cast<const UserInteractionFB::EventMouseButton *>(event()) : nullptr;
  }
  const UserInteractionFB::EventTextInput *event_as_EventTextInput() const {
    return event_type() == UserInteractionFB::UserInteraction_EventTextInput ? static_cast<const UserInteractionFB::EventTextInput *>(event()) : nullptr;
  }
  const UserInteractionFB::EventKeyboard *event_as_EventKeyboard() const {
    return event_type() == UserInteractionFB::UserInteraction_EventKeyboard ? static_cast<const UserInteractionFB::EventKeyboard *>(event()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_EVENT_TYPE, 1) &&
           VerifyOffset(verifier, VT_EVENT) &&
           VerifyUserInteraction(verifier, event(), event_type()) &&
           verifier.EndTable();
  }
};

template<> inline const UserInteractionFB::EventMouseMotion *Event::event_as<UserInteractionFB::EventMouseMotion>() const {
  return event_as_EventMouseMotion();
}

template<> inline const UserInteractionFB::EventMouseWheel *Event::event_as<UserInteractionFB::EventMouseWheel>() const {
  return event_as_EventMouseWheel();
}

template<> inline const UserInteractionFB::EventMouseButton *Event::event_as<UserInteractionFB::EventMouseButton>() const {
  return event_as_EventMouseButton();
}

template<> inline const UserInteractionFB::EventTextInput *Event::event_as<UserInteractionFB::EventTextInput>() const {
  return event_as_EventTextInput();
}

template<> inline const UserInteractionFB::EventKeyboard *Event::event_as<UserInteractionFB::EventKeyboard>() const {
  return event_as_EventKeyboard();
}

struct EventBuilder {
  typedef Event Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_event_type(UserInteractionFB::UserInteraction event_type) {
    fbb_.AddElement<uint8_t>(Event::VT_EVENT_TYPE, static_cast<uint8_t>(event_type), 0);
  }
  void add_event(::flatbuffers::Offset<void> event) {
    fbb_.AddOffset(Event::VT_EVENT, event);
  }
  explicit EventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Event> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Event>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Event> CreateEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    UserInteractionFB::UserInteraction event_type = UserInteractionFB::UserInteraction_NONE,
    ::flatbuffers::Offset<void> event = 0) {
  EventBuilder builder_(_fbb);
  builder_.add_event(event);
  builder_.add_event_type(event_type);
  return builder_.Finish();
}

inline bool VerifyUserInteraction(::flatbuffers::Verifier &verifier, const void *obj, UserInteraction type) {
  switch (type) {
    case UserInteraction_NONE: {
      return true;
    }
    case UserInteraction_EventMouseMotion: {
      auto ptr = reinterpret_cast<const UserInteractionFB::EventMouseMotion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case UserInteraction_EventMouseWheel: {
      auto ptr = reinterpret_cast<const UserInteractionFB::EventMouseWheel *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case UserInteraction_EventMouseButton: {
      auto ptr = reinterpret_cast<const UserInteractionFB::EventMouseButton *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case UserInteraction_EventTextInput: {
      auto ptr = reinterpret_cast<const UserInteractionFB::EventTextInput *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case UserInteraction_EventKeyboard: {
      auto ptr = reinterpret_cast<const UserInteractionFB::EventKeyboard *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyUserInteractionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyUserInteraction(
        verifier,  values->Get(i), types->GetEnum<UserInteraction>(i))) {
      return false;
    }
  }
  return true;
}

inline const ::flatbuffers::TypeTable *MouseButtonTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    UserInteractionFB::MouseButtonTypeTable
  };
  static const char * const names[] = {
    "None",
    "Left",
    "Right",
    "Middle",
    "X1",
    "X2"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 6, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *MouseButtonEventTypeTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    UserInteractionFB::MouseButtonEventTypeTypeTable
  };
  static const char * const names[] = {
    "Up",
    "Down"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *KeyModifiersTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    UserInteractionFB::KeyModifiersTypeTable
  };
  static const int64_t values[] = { 0, 1, 2, 4, 8 };
  static const char * const names[] = {
    "None",
    "Ctrl",
    "Shift",
    "Alt",
    "Super"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 5, type_codes, type_refs, nullptr, values, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *KeyCodeTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    UserInteractionFB::KeyCodeTypeTable
  };
  static const char * const names[] = {
    "Key_None",
    "Key_Tab",
    "Key_LeftArrow",
    "Key_RightArrow",
    "Key_UpArrow",
    "Key_DownArrow",
    "Key_PageUp",
    "Key_PageDown",
    "Key_Home",
    "Key_End",
    "Key_Insert",
    "Key_Delete",
    "Key_Backspace",
    "Key_Space",
    "Key_Enter",
    "Key_Escape",
    "Key_Apostrophe",
    "Key_Comma",
    "Key_Minus",
    "Key_Period",
    "Key_Slash",
    "Key_Semicolon",
    "Key_Equal",
    "Key_LeftBracket",
    "Key_Backslash",
    "Key_RightBracket",
    "Key_GraveAccent",
    "Key_CapsLock",
    "Key_ScrollLock",
    "Key_NumLock",
    "Key_PrintScreen",
    "Key_Pause",
    "Key_Keypad0",
    "Key_Keypad1",
    "Key_Keypad2",
    "Key_Keypad3",
    "Key_Keypad4",
    "Key_Keypad5",
    "Key_Keypad6",
    "Key_Keypad7",
    "Key_Keypad8",
    "Key_Keypad9",
    "Key_KeypadDecimal",
    "Key_KeypadDivide",
    "Key_KeypadMultiply",
    "Key_KeypadSubtract",
    "Key_KeypadAdd",
    "Key_KeypadEnter",
    "Key_KeypadEqual",
    "Key_LeftCtrl",
    "Key_LeftShift",
    "Key_LeftAlt",
    "Key_LeftSuper",
    "Key_RightCtrl",
    "Key_RightShift",
    "Key_RightAlt",
    "Key_RightSuper",
    "Key_Menu",
    "Key_0",
    "Key_1",
    "Key_2",
    "Key_3",
    "Key_4",
    "Key_5",
    "Key_6",
    "Key_7",
    "Key_8",
    "Key_9",
    "Key_A",
    "Key_B",
    "Key_C",
    "Key_D",
    "Key_E",
    "Key_F",
    "Key_G",
    "Key_H",
    "Key_I",
    "Key_J",
    "Key_K",
    "Key_L",
    "Key_M",
    "Key_N",
    "Key_O",
    "Key_P",
    "Key_Q",
    "Key_R",
    "Key_S",
    "Key_T",
    "Key_U",
    "Key_V",
    "Key_W",
    "Key_X",
    "Key_Y",
    "Key_Z",
    "Key_F1",
    "Key_F2",
    "Key_F3",
    "Key_F4",
    "Key_F5",
    "Key_F6",
    "Key_F7",
    "Key_F8",
    "Key_F9",
    "Key_F10",
    "Key_F11",
    "Key_F12",
    "Key_F13",
    "Key_F14",
    "Key_F15",
    "Key_F16",
    "Key_F17",
    "Key_F18",
    "Key_F19",
    "Key_F20",
    "Key_F21",
    "Key_F22",
    "Key_F23",
    "Key_F24",
    "Key_AppBack",
    "Key_AppForward"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 120, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *UserInteractionTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 2 },
    { ::flatbuffers::ET_SEQUENCE, 0, 3 },
    { ::flatbuffers::ET_SEQUENCE, 0, 4 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    UserInteractionFB::EventMouseMotionTypeTable,
    UserInteractionFB::EventMouseWheelTypeTable,
    UserInteractionFB::EventMouseButtonTypeTable,
    UserInteractionFB::EventTextInputTypeTable,
    UserInteractionFB::EventKeyboardTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "EventMouseMotion",
    "EventMouseWheel",
    "EventMouseButton",
    "EventTextInput",
    "EventKeyboard"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_UNION, 6, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *SingleVec2TypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const int64_t values[] = { 0, 4, 8 };
  static const char * const names[] = {
    "x",
    "y"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_STRUCT, 2, type_codes, nullptr, nullptr, values, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *SingleVec4TypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const int64_t values[] = { 0, 4, 8, 12, 16 };
  static const char * const names[] = {
    "x",
    "y",
    "z",
    "w"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_STRUCT, 4, type_codes, nullptr, nullptr, values, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ArrayOfVec2TypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_FLOAT, 1, -1 },
    { ::flatbuffers::ET_FLOAT, 1, -1 }
  };
  static const char * const names[] = {
    "xs",
    "ys"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ArrayOfVec4TypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_FLOAT, 1, -1 },
    { ::flatbuffers::ET_FLOAT, 1, -1 },
    { ::flatbuffers::ET_FLOAT, 1, -1 },
    { ::flatbuffers::ET_FLOAT, 1, -1 }
  };
  static const char * const names[] = {
    "xs",
    "ys",
    "zs",
    "ws"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *EventMouseMotionTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    UserInteractionFB::SingleVec2TypeTable
  };
  static const char * const names[] = {
    "pos",
    "mouse_id",
    "is_touch"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *EventMouseWheelTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    UserInteractionFB::SingleVec2TypeTable
  };
  static const char * const names[] = {
    "pos",
    "mouse_id",
    "is_touch"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *EventMouseButtonTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_UCHAR, 0, 1 },
    { ::flatbuffers::ET_UCHAR, 0, 2 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    UserInteractionFB::SingleVec2TypeTable,
    UserInteractionFB::MouseButtonTypeTable,
    UserInteractionFB::MouseButtonEventTypeTypeTable
  };
  static const char * const names[] = {
    "pos",
    "mouse_id",
    "is_touch",
    "button",
    "type"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *EventTextInputTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "text"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *EventKeyboardTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 1 },
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    UserInteractionFB::KeyModifiersTypeTable,
    UserInteractionFB::KeyCodeTypeTable
  };
  static const char * const names[] = {
    "modifiers",
    "code",
    "is_down",
    "native_sym",
    "scancode"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *EventTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UTYPE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    UserInteractionFB::UserInteractionTypeTable
  };
  static const char * const names[] = {
    "event_type",
    "event"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const UserInteractionFB::Event *GetEvent(const void *buf) {
  return ::flatbuffers::GetRoot<UserInteractionFB::Event>(buf);
}

inline const UserInteractionFB::Event *GetSizePrefixedEvent(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<UserInteractionFB::Event>(buf);
}

inline bool VerifyEventBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<UserInteractionFB::Event>(nullptr);
}

inline bool VerifySizePrefixedEventBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<UserInteractionFB::Event>(nullptr);
}

inline void FinishEventBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<UserInteractionFB::Event> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedEventBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<UserInteractionFB::Event> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace UserInteractionFB

#endif  // FLATBUFFERS_GENERATED_USERINTERACTION_USERINTERACTIONFB_H_
