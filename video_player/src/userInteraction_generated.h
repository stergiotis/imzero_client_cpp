// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_USERINTERACTION_USERINTERACTIONFB_H_
#define FLATBUFFERS_GENERATED_USERINTERACTION_USERINTERACTIONFB_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

namespace UserInteractionFB {

struct SingleVec2;

struct SingleVec4;

struct ArrayOfVec2;
struct ArrayOfVec2Builder;

struct ArrayOfVec4;
struct ArrayOfVec4Builder;

struct EventMouseMotion;
struct EventMouseMotionBuilder;

struct EventMouseWheel;
struct EventMouseWheelBuilder;

struct EventMouseButton;
struct EventMouseButtonBuilder;

struct EventTextInput;
struct EventTextInputBuilder;

struct Event;
struct EventBuilder;

enum MouseButton : uint8_t {
  MouseButton_None = 0,
  MouseButton_Left = 1,
  MouseButton_Right = 2,
  MouseButton_Middle = 3,
  MouseButton_X1 = 4,
  MouseButton_X2 = 5,
  MouseButton_MIN = MouseButton_None,
  MouseButton_MAX = MouseButton_X2
};

inline const MouseButton (&EnumValuesMouseButton())[6] {
  static const MouseButton values[] = {
    MouseButton_None,
    MouseButton_Left,
    MouseButton_Right,
    MouseButton_Middle,
    MouseButton_X1,
    MouseButton_X2
  };
  return values;
}

inline const char * const *EnumNamesMouseButton() {
  static const char * const names[7] = {
    "None",
    "Left",
    "Right",
    "Middle",
    "X1",
    "X2",
    nullptr
  };
  return names;
}

inline const char *EnumNameMouseButton(MouseButton e) {
  if (::flatbuffers::IsOutRange(e, MouseButton_None, MouseButton_X2)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMouseButton()[index];
}

enum UserInteraction : uint8_t {
  UserInteraction_NONE = 0,
  UserInteraction_EventMouseMotion = 1,
  UserInteraction_EventMouseWheel = 2,
  UserInteraction_EventMouseButton = 3,
  UserInteraction_MIN = UserInteraction_NONE,
  UserInteraction_MAX = UserInteraction_EventMouseButton
};

inline const UserInteraction (&EnumValuesUserInteraction())[4] {
  static const UserInteraction values[] = {
    UserInteraction_NONE,
    UserInteraction_EventMouseMotion,
    UserInteraction_EventMouseWheel,
    UserInteraction_EventMouseButton
  };
  return values;
}

inline const char * const *EnumNamesUserInteraction() {
  static const char * const names[5] = {
    "NONE",
    "EventMouseMotion",
    "EventMouseWheel",
    "EventMouseButton",
    nullptr
  };
  return names;
}

inline const char *EnumNameUserInteraction(UserInteraction e) {
  if (::flatbuffers::IsOutRange(e, UserInteraction_NONE, UserInteraction_EventMouseButton)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesUserInteraction()[index];
}

template<typename T> struct UserInteractionTraits {
  static const UserInteraction enum_value = UserInteraction_NONE;
};

template<> struct UserInteractionTraits<UserInteractionFB::EventMouseMotion> {
  static const UserInteraction enum_value = UserInteraction_EventMouseMotion;
};

template<> struct UserInteractionTraits<UserInteractionFB::EventMouseWheel> {
  static const UserInteraction enum_value = UserInteraction_EventMouseWheel;
};

template<> struct UserInteractionTraits<UserInteractionFB::EventMouseButton> {
  static const UserInteraction enum_value = UserInteraction_EventMouseButton;
};

bool VerifyUserInteraction(::flatbuffers::Verifier &verifier, const void *obj, UserInteraction type);
bool VerifyUserInteractionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) SingleVec2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  SingleVec2()
      : x_(0),
        y_(0) {
  }
  SingleVec2(float _x, float _y)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(SingleVec2, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) SingleVec4 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  SingleVec4()
      : x_(0),
        y_(0),
        z_(0),
        w_(0) {
  }
  SingleVec4(float _x, float _y, float _z, float _w)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)),
        z_(::flatbuffers::EndianScalar(_z)),
        w_(::flatbuffers::EndianScalar(_w)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return ::flatbuffers::EndianScalar(z_);
  }
  float w() const {
    return ::flatbuffers::EndianScalar(w_);
  }
};
FLATBUFFERS_STRUCT_END(SingleVec4, 16);

struct ArrayOfVec2 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ArrayOfVec2Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_XS = 4,
    VT_YS = 6
  };
  const ::flatbuffers::Vector<float> *xs() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_XS);
  }
  const ::flatbuffers::Vector<float> *ys() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_YS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_XS) &&
           verifier.VerifyVector(xs()) &&
           VerifyOffset(verifier, VT_YS) &&
           verifier.VerifyVector(ys()) &&
           verifier.EndTable();
  }
};

struct ArrayOfVec2Builder {
  typedef ArrayOfVec2 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_xs(::flatbuffers::Offset<::flatbuffers::Vector<float>> xs) {
    fbb_.AddOffset(ArrayOfVec2::VT_XS, xs);
  }
  void add_ys(::flatbuffers::Offset<::flatbuffers::Vector<float>> ys) {
    fbb_.AddOffset(ArrayOfVec2::VT_YS, ys);
  }
  explicit ArrayOfVec2Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ArrayOfVec2> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ArrayOfVec2>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ArrayOfVec2> CreateArrayOfVec2(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> xs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> ys = 0) {
  ArrayOfVec2Builder builder_(_fbb);
  builder_.add_ys(ys);
  builder_.add_xs(xs);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ArrayOfVec2> CreateArrayOfVec2Direct(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *xs = nullptr,
    const std::vector<float> *ys = nullptr) {
  auto xs__ = xs ? _fbb.CreateVector<float>(*xs) : 0;
  auto ys__ = ys ? _fbb.CreateVector<float>(*ys) : 0;
  return UserInteractionFB::CreateArrayOfVec2(
      _fbb,
      xs__,
      ys__);
}

struct ArrayOfVec4 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ArrayOfVec4Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_XS = 4,
    VT_YS = 6,
    VT_ZS = 8,
    VT_WS = 10
  };
  const ::flatbuffers::Vector<float> *xs() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_XS);
  }
  const ::flatbuffers::Vector<float> *ys() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_YS);
  }
  const ::flatbuffers::Vector<float> *zs() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_ZS);
  }
  const ::flatbuffers::Vector<float> *ws() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_WS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_XS) &&
           verifier.VerifyVector(xs()) &&
           VerifyOffset(verifier, VT_YS) &&
           verifier.VerifyVector(ys()) &&
           VerifyOffset(verifier, VT_ZS) &&
           verifier.VerifyVector(zs()) &&
           VerifyOffset(verifier, VT_WS) &&
           verifier.VerifyVector(ws()) &&
           verifier.EndTable();
  }
};

struct ArrayOfVec4Builder {
  typedef ArrayOfVec4 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_xs(::flatbuffers::Offset<::flatbuffers::Vector<float>> xs) {
    fbb_.AddOffset(ArrayOfVec4::VT_XS, xs);
  }
  void add_ys(::flatbuffers::Offset<::flatbuffers::Vector<float>> ys) {
    fbb_.AddOffset(ArrayOfVec4::VT_YS, ys);
  }
  void add_zs(::flatbuffers::Offset<::flatbuffers::Vector<float>> zs) {
    fbb_.AddOffset(ArrayOfVec4::VT_ZS, zs);
  }
  void add_ws(::flatbuffers::Offset<::flatbuffers::Vector<float>> ws) {
    fbb_.AddOffset(ArrayOfVec4::VT_WS, ws);
  }
  explicit ArrayOfVec4Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ArrayOfVec4> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ArrayOfVec4>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ArrayOfVec4> CreateArrayOfVec4(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> xs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> ys = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> zs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> ws = 0) {
  ArrayOfVec4Builder builder_(_fbb);
  builder_.add_ws(ws);
  builder_.add_zs(zs);
  builder_.add_ys(ys);
  builder_.add_xs(xs);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ArrayOfVec4> CreateArrayOfVec4Direct(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *xs = nullptr,
    const std::vector<float> *ys = nullptr,
    const std::vector<float> *zs = nullptr,
    const std::vector<float> *ws = nullptr) {
  auto xs__ = xs ? _fbb.CreateVector<float>(*xs) : 0;
  auto ys__ = ys ? _fbb.CreateVector<float>(*ys) : 0;
  auto zs__ = zs ? _fbb.CreateVector<float>(*zs) : 0;
  auto ws__ = ws ? _fbb.CreateVector<float>(*ws) : 0;
  return UserInteractionFB::CreateArrayOfVec4(
      _fbb,
      xs__,
      ys__,
      zs__,
      ws__);
}

struct EventMouseMotion FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EventMouseMotionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POS = 4,
    VT_MOUSE_ID = 6,
    VT_IS_TOUCH = 8
  };
  const UserInteractionFB::SingleVec2 *pos() const {
    return GetStruct<const UserInteractionFB::SingleVec2 *>(VT_POS);
  }
  uint32_t mouse_id() const {
    return GetField<uint32_t>(VT_MOUSE_ID, 0);
  }
  bool is_touch() const {
    return GetField<uint8_t>(VT_IS_TOUCH, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<UserInteractionFB::SingleVec2>(verifier, VT_POS, 4) &&
           VerifyField<uint32_t>(verifier, VT_MOUSE_ID, 4) &&
           VerifyField<uint8_t>(verifier, VT_IS_TOUCH, 1) &&
           verifier.EndTable();
  }
};

struct EventMouseMotionBuilder {
  typedef EventMouseMotion Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pos(const UserInteractionFB::SingleVec2 *pos) {
    fbb_.AddStruct(EventMouseMotion::VT_POS, pos);
  }
  void add_mouse_id(uint32_t mouse_id) {
    fbb_.AddElement<uint32_t>(EventMouseMotion::VT_MOUSE_ID, mouse_id, 0);
  }
  void add_is_touch(bool is_touch) {
    fbb_.AddElement<uint8_t>(EventMouseMotion::VT_IS_TOUCH, static_cast<uint8_t>(is_touch), 0);
  }
  explicit EventMouseMotionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EventMouseMotion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EventMouseMotion>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EventMouseMotion> CreateEventMouseMotion(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const UserInteractionFB::SingleVec2 *pos = nullptr,
    uint32_t mouse_id = 0,
    bool is_touch = false) {
  EventMouseMotionBuilder builder_(_fbb);
  builder_.add_mouse_id(mouse_id);
  builder_.add_pos(pos);
  builder_.add_is_touch(is_touch);
  return builder_.Finish();
}

struct EventMouseWheel FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EventMouseWheelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POS = 4,
    VT_MOUSE_ID = 6,
    VT_IS_TOUCH = 8
  };
  const UserInteractionFB::SingleVec2 *pos() const {
    return GetStruct<const UserInteractionFB::SingleVec2 *>(VT_POS);
  }
  uint32_t mouse_id() const {
    return GetField<uint32_t>(VT_MOUSE_ID, 0);
  }
  bool is_touch() const {
    return GetField<uint8_t>(VT_IS_TOUCH, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<UserInteractionFB::SingleVec2>(verifier, VT_POS, 4) &&
           VerifyField<uint32_t>(verifier, VT_MOUSE_ID, 4) &&
           VerifyField<uint8_t>(verifier, VT_IS_TOUCH, 1) &&
           verifier.EndTable();
  }
};

struct EventMouseWheelBuilder {
  typedef EventMouseWheel Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pos(const UserInteractionFB::SingleVec2 *pos) {
    fbb_.AddStruct(EventMouseWheel::VT_POS, pos);
  }
  void add_mouse_id(uint32_t mouse_id) {
    fbb_.AddElement<uint32_t>(EventMouseWheel::VT_MOUSE_ID, mouse_id, 0);
  }
  void add_is_touch(bool is_touch) {
    fbb_.AddElement<uint8_t>(EventMouseWheel::VT_IS_TOUCH, static_cast<uint8_t>(is_touch), 0);
  }
  explicit EventMouseWheelBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EventMouseWheel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EventMouseWheel>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EventMouseWheel> CreateEventMouseWheel(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const UserInteractionFB::SingleVec2 *pos = nullptr,
    uint32_t mouse_id = 0,
    bool is_touch = false) {
  EventMouseWheelBuilder builder_(_fbb);
  builder_.add_mouse_id(mouse_id);
  builder_.add_pos(pos);
  builder_.add_is_touch(is_touch);
  return builder_.Finish();
}

struct EventMouseButton FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EventMouseButtonBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POS = 4,
    VT_MOUSE_ID = 6,
    VT_IS_TOUCH = 8,
    VT_BUTTON = 10
  };
  const UserInteractionFB::SingleVec2 *pos() const {
    return GetStruct<const UserInteractionFB::SingleVec2 *>(VT_POS);
  }
  uint32_t mouse_id() const {
    return GetField<uint32_t>(VT_MOUSE_ID, 0);
  }
  bool is_touch() const {
    return GetField<uint8_t>(VT_IS_TOUCH, 0) != 0;
  }
  UserInteractionFB::MouseButton button() const {
    return static_cast<UserInteractionFB::MouseButton>(GetField<uint8_t>(VT_BUTTON, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<UserInteractionFB::SingleVec2>(verifier, VT_POS, 4) &&
           VerifyField<uint32_t>(verifier, VT_MOUSE_ID, 4) &&
           VerifyField<uint8_t>(verifier, VT_IS_TOUCH, 1) &&
           VerifyField<uint8_t>(verifier, VT_BUTTON, 1) &&
           verifier.EndTable();
  }
};

struct EventMouseButtonBuilder {
  typedef EventMouseButton Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pos(const UserInteractionFB::SingleVec2 *pos) {
    fbb_.AddStruct(EventMouseButton::VT_POS, pos);
  }
  void add_mouse_id(uint32_t mouse_id) {
    fbb_.AddElement<uint32_t>(EventMouseButton::VT_MOUSE_ID, mouse_id, 0);
  }
  void add_is_touch(bool is_touch) {
    fbb_.AddElement<uint8_t>(EventMouseButton::VT_IS_TOUCH, static_cast<uint8_t>(is_touch), 0);
  }
  void add_button(UserInteractionFB::MouseButton button) {
    fbb_.AddElement<uint8_t>(EventMouseButton::VT_BUTTON, static_cast<uint8_t>(button), 0);
  }
  explicit EventMouseButtonBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EventMouseButton> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EventMouseButton>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EventMouseButton> CreateEventMouseButton(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const UserInteractionFB::SingleVec2 *pos = nullptr,
    uint32_t mouse_id = 0,
    bool is_touch = false,
    UserInteractionFB::MouseButton button = UserInteractionFB::MouseButton_None) {
  EventMouseButtonBuilder builder_(_fbb);
  builder_.add_mouse_id(mouse_id);
  builder_.add_pos(pos);
  builder_.add_button(button);
  builder_.add_is_touch(is_touch);
  return builder_.Finish();
}

struct EventTextInput FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EventTextInputBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEXT = 4
  };
  const ::flatbuffers::String *text() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TEXT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           verifier.EndTable();
  }
};

struct EventTextInputBuilder {
  typedef EventTextInput Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_text(::flatbuffers::Offset<::flatbuffers::String> text) {
    fbb_.AddOffset(EventTextInput::VT_TEXT, text);
  }
  explicit EventTextInputBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EventTextInput> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EventTextInput>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EventTextInput> CreateEventTextInput(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> text = 0) {
  EventTextInputBuilder builder_(_fbb);
  builder_.add_text(text);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<EventTextInput> CreateEventTextInputDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *text = nullptr) {
  auto text__ = text ? _fbb.CreateString(text) : 0;
  return UserInteractionFB::CreateEventTextInput(
      _fbb,
      text__);
}

struct Event FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EventBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EVENT_TYPE = 4,
    VT_EVENT = 6
  };
  UserInteractionFB::UserInteraction event_type() const {
    return static_cast<UserInteractionFB::UserInteraction>(GetField<uint8_t>(VT_EVENT_TYPE, 0));
  }
  const void *event() const {
    return GetPointer<const void *>(VT_EVENT);
  }
  template<typename T> const T *event_as() const;
  const UserInteractionFB::EventMouseMotion *event_as_EventMouseMotion() const {
    return event_type() == UserInteractionFB::UserInteraction_EventMouseMotion ? static_cast<const UserInteractionFB::EventMouseMotion *>(event()) : nullptr;
  }
  const UserInteractionFB::EventMouseWheel *event_as_EventMouseWheel() const {
    return event_type() == UserInteractionFB::UserInteraction_EventMouseWheel ? static_cast<const UserInteractionFB::EventMouseWheel *>(event()) : nullptr;
  }
  const UserInteractionFB::EventMouseButton *event_as_EventMouseButton() const {
    return event_type() == UserInteractionFB::UserInteraction_EventMouseButton ? static_cast<const UserInteractionFB::EventMouseButton *>(event()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_EVENT_TYPE, 1) &&
           VerifyOffset(verifier, VT_EVENT) &&
           VerifyUserInteraction(verifier, event(), event_type()) &&
           verifier.EndTable();
  }
};

template<> inline const UserInteractionFB::EventMouseMotion *Event::event_as<UserInteractionFB::EventMouseMotion>() const {
  return event_as_EventMouseMotion();
}

template<> inline const UserInteractionFB::EventMouseWheel *Event::event_as<UserInteractionFB::EventMouseWheel>() const {
  return event_as_EventMouseWheel();
}

template<> inline const UserInteractionFB::EventMouseButton *Event::event_as<UserInteractionFB::EventMouseButton>() const {
  return event_as_EventMouseButton();
}

struct EventBuilder {
  typedef Event Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_event_type(UserInteractionFB::UserInteraction event_type) {
    fbb_.AddElement<uint8_t>(Event::VT_EVENT_TYPE, static_cast<uint8_t>(event_type), 0);
  }
  void add_event(::flatbuffers::Offset<void> event) {
    fbb_.AddOffset(Event::VT_EVENT, event);
  }
  explicit EventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Event> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Event>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Event> CreateEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    UserInteractionFB::UserInteraction event_type = UserInteractionFB::UserInteraction_NONE,
    ::flatbuffers::Offset<void> event = 0) {
  EventBuilder builder_(_fbb);
  builder_.add_event(event);
  builder_.add_event_type(event_type);
  return builder_.Finish();
}

inline bool VerifyUserInteraction(::flatbuffers::Verifier &verifier, const void *obj, UserInteraction type) {
  switch (type) {
    case UserInteraction_NONE: {
      return true;
    }
    case UserInteraction_EventMouseMotion: {
      auto ptr = reinterpret_cast<const UserInteractionFB::EventMouseMotion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case UserInteraction_EventMouseWheel: {
      auto ptr = reinterpret_cast<const UserInteractionFB::EventMouseWheel *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case UserInteraction_EventMouseButton: {
      auto ptr = reinterpret_cast<const UserInteractionFB::EventMouseButton *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyUserInteractionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyUserInteraction(
        verifier,  values->Get(i), types->GetEnum<UserInteraction>(i))) {
      return false;
    }
  }
  return true;
}

inline const UserInteractionFB::Event *GetEvent(const void *buf) {
  return ::flatbuffers::GetRoot<UserInteractionFB::Event>(buf);
}

inline const UserInteractionFB::Event *GetSizePrefixedEvent(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<UserInteractionFB::Event>(buf);
}

inline bool VerifyEventBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<UserInteractionFB::Event>(nullptr);
}

inline bool VerifySizePrefixedEventBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<UserInteractionFB::Event>(nullptr);
}

inline void FinishEventBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<UserInteractionFB::Event> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedEventBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<UserInteractionFB::Event> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace UserInteractionFB

#endif  // FLATBUFFERS_GENERATED_USERINTERACTION_USERINTERACTIONFB_H_
