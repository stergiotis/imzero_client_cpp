// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_IMZEROFB_IMZEROFB_H_
#define FLATBUFFERS_GENERATED_IMZEROFB_IMZEROFB_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

namespace ImZeroFB {

struct SingleVec2;

struct SingleVec4;

struct ArrayOfVec2;
struct ArrayOfVec2Builder;

struct ArrayOfVec4;
struct ArrayOfVec4Builder;

struct CmdRegisterFont;
struct CmdRegisterFontBuilder;

struct CmdPolyline;
struct CmdPolylineBuilder;

struct CmdConvexPolyFilled;
struct CmdConvexPolyFilledBuilder;

struct CmdLine;
struct CmdLineBuilder;

struct CmdRectRounded;
struct CmdRectRoundedBuilder;

struct CmdRectRoundedCorners;
struct CmdRectRoundedCornersBuilder;

struct CmdRectRoundedFilled;
struct CmdRectRoundedFilledBuilder;

struct CmdRectRoundedCornersFilled;
struct CmdRectRoundedCornersFilledBuilder;

struct CmdQuad;
struct CmdQuadBuilder;

struct CmdQuadFilled;
struct CmdQuadFilledBuilder;

struct CmdTriangle;
struct CmdTriangleBuilder;

struct CmdTriangleFilled;
struct CmdTriangleFilledBuilder;

struct CmdCircle;
struct CmdCircleBuilder;

struct CmdCircleFilled;
struct CmdCircleFilledBuilder;

struct CmdNgon;
struct CmdNgonBuilder;

struct CmdNgonFilled;
struct CmdNgonFilledBuilder;

struct CmdEllipse;
struct CmdEllipseBuilder;

struct CmdEllipseFilled;
struct CmdEllipseFilledBuilder;

struct CmdBezierCubic;
struct CmdBezierCubicBuilder;

struct CmdBezierQuadratic;
struct CmdBezierQuadraticBuilder;

struct CmdImage;
struct CmdImageBuilder;

struct CmdImageQuad;
struct CmdImageQuadBuilder;

struct CmdImageRounded;
struct CmdImageRoundedBuilder;

struct CmdPushClipRect;
struct CmdPushClipRectBuilder;

struct CmdPopClipRect;
struct CmdPopClipRectBuilder;

struct CmdRenderText;
struct CmdRenderTextBuilder;

struct CmdRenderParagraph;
struct CmdRenderParagraphBuilder;

struct CmdRenderUnicodeCodepoint;
struct CmdRenderUnicodeCodepointBuilder;

struct CmdTranslation;
struct CmdTranslationBuilder;

struct PopTranslation;
struct PopTranslationBuilder;

struct CmdPushRotation;
struct CmdPushRotationBuilder;

struct CmdPopRotation;
struct CmdPopRotationBuilder;

struct CmdRectFilledMultiColor;
struct CmdRectFilledMultiColorBuilder;

struct CmdWrappedDrawList;
struct CmdWrappedDrawListBuilder;

struct CmdVertexDraw;
struct CmdVertexDrawBuilder;

struct CmdSimpleVertexDraw;
struct CmdSimpleVertexDrawBuilder;

struct CmdSvgPathSubset;
struct CmdSvgPathSubsetBuilder;

struct CmdPath;
struct CmdPathBuilder;

struct SingleVectorCmdDto;
struct SingleVectorCmdDtoBuilder;

struct VertexData;
struct VertexDataBuilder;

struct DrawList;
struct DrawListBuilder;

struct IoRecord;
struct IoRecordBuilder;

struct EventMouseMotion;
struct EventMouseMotionBuilder;

struct EventMouseWheel;
struct EventMouseWheelBuilder;

struct EventMouseButton;
struct EventMouseButtonBuilder;

struct EventTextInput;
struct EventTextInputBuilder;

struct EventKeyboard;
struct EventKeyboardBuilder;

struct InputEvent;
struct InputEventBuilder;

inline const ::flatbuffers::TypeTable *SingleVec2TypeTable();

inline const ::flatbuffers::TypeTable *SingleVec4TypeTable();

inline const ::flatbuffers::TypeTable *ArrayOfVec2TypeTable();

inline const ::flatbuffers::TypeTable *ArrayOfVec4TypeTable();

inline const ::flatbuffers::TypeTable *CmdRegisterFontTypeTable();

inline const ::flatbuffers::TypeTable *CmdPolylineTypeTable();

inline const ::flatbuffers::TypeTable *CmdConvexPolyFilledTypeTable();

inline const ::flatbuffers::TypeTable *CmdLineTypeTable();

inline const ::flatbuffers::TypeTable *CmdRectRoundedTypeTable();

inline const ::flatbuffers::TypeTable *CmdRectRoundedCornersTypeTable();

inline const ::flatbuffers::TypeTable *CmdRectRoundedFilledTypeTable();

inline const ::flatbuffers::TypeTable *CmdRectRoundedCornersFilledTypeTable();

inline const ::flatbuffers::TypeTable *CmdQuadTypeTable();

inline const ::flatbuffers::TypeTable *CmdQuadFilledTypeTable();

inline const ::flatbuffers::TypeTable *CmdTriangleTypeTable();

inline const ::flatbuffers::TypeTable *CmdTriangleFilledTypeTable();

inline const ::flatbuffers::TypeTable *CmdCircleTypeTable();

inline const ::flatbuffers::TypeTable *CmdCircleFilledTypeTable();

inline const ::flatbuffers::TypeTable *CmdNgonTypeTable();

inline const ::flatbuffers::TypeTable *CmdNgonFilledTypeTable();

inline const ::flatbuffers::TypeTable *CmdEllipseTypeTable();

inline const ::flatbuffers::TypeTable *CmdEllipseFilledTypeTable();

inline const ::flatbuffers::TypeTable *CmdBezierCubicTypeTable();

inline const ::flatbuffers::TypeTable *CmdBezierQuadraticTypeTable();

inline const ::flatbuffers::TypeTable *CmdImageTypeTable();

inline const ::flatbuffers::TypeTable *CmdImageQuadTypeTable();

inline const ::flatbuffers::TypeTable *CmdImageRoundedTypeTable();

inline const ::flatbuffers::TypeTable *CmdPushClipRectTypeTable();

inline const ::flatbuffers::TypeTable *CmdPopClipRectTypeTable();

inline const ::flatbuffers::TypeTable *CmdRenderTextTypeTable();

inline const ::flatbuffers::TypeTable *CmdRenderParagraphTypeTable();

inline const ::flatbuffers::TypeTable *CmdRenderUnicodeCodepointTypeTable();

inline const ::flatbuffers::TypeTable *CmdTranslationTypeTable();

inline const ::flatbuffers::TypeTable *PopTranslationTypeTable();

inline const ::flatbuffers::TypeTable *CmdPushRotationTypeTable();

inline const ::flatbuffers::TypeTable *CmdPopRotationTypeTable();

inline const ::flatbuffers::TypeTable *CmdRectFilledMultiColorTypeTable();

inline const ::flatbuffers::TypeTable *CmdWrappedDrawListTypeTable();

inline const ::flatbuffers::TypeTable *CmdVertexDrawTypeTable();

inline const ::flatbuffers::TypeTable *CmdSimpleVertexDrawTypeTable();

inline const ::flatbuffers::TypeTable *CmdSvgPathSubsetTypeTable();

inline const ::flatbuffers::TypeTable *CmdPathTypeTable();

inline const ::flatbuffers::TypeTable *SingleVectorCmdDtoTypeTable();

inline const ::flatbuffers::TypeTable *VertexDataTypeTable();

inline const ::flatbuffers::TypeTable *DrawListTypeTable();

inline const ::flatbuffers::TypeTable *IoRecordTypeTable();

inline const ::flatbuffers::TypeTable *EventMouseMotionTypeTable();

inline const ::flatbuffers::TypeTable *EventMouseWheelTypeTable();

inline const ::flatbuffers::TypeTable *EventMouseButtonTypeTable();

inline const ::flatbuffers::TypeTable *EventTextInputTypeTable();

inline const ::flatbuffers::TypeTable *EventKeyboardTypeTable();

inline const ::flatbuffers::TypeTable *InputEventTypeTable();

enum TextAlignFlags : uint8_t {
  TextAlignFlags_left = 0,
  TextAlignFlags_right = 1,
  TextAlignFlags_center = 2,
  TextAlignFlags_justify = 3,
  TextAlignFlags_MIN = TextAlignFlags_left,
  TextAlignFlags_MAX = TextAlignFlags_justify
};

inline const TextAlignFlags (&EnumValuesTextAlignFlags())[4] {
  static const TextAlignFlags values[] = {
    TextAlignFlags_left,
    TextAlignFlags_right,
    TextAlignFlags_center,
    TextAlignFlags_justify
  };
  return values;
}

inline const char * const *EnumNamesTextAlignFlags() {
  static const char * const names[5] = {
    "left",
    "right",
    "center",
    "justify",
    nullptr
  };
  return names;
}

inline const char *EnumNameTextAlignFlags(TextAlignFlags e) {
  if (::flatbuffers::IsOutRange(e, TextAlignFlags_left, TextAlignFlags_justify)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTextAlignFlags()[index];
}

enum TextDirection : uint8_t {
  TextDirection_ltr = 0,
  TextDirection_rtl = 1,
  TextDirection_MIN = TextDirection_ltr,
  TextDirection_MAX = TextDirection_rtl
};

inline const TextDirection (&EnumValuesTextDirection())[2] {
  static const TextDirection values[] = {
    TextDirection_ltr,
    TextDirection_rtl
  };
  return values;
}

inline const char * const *EnumNamesTextDirection() {
  static const char * const names[3] = {
    "ltr",
    "rtl",
    nullptr
  };
  return names;
}

inline const char *EnumNameTextDirection(TextDirection e) {
  if (::flatbuffers::IsOutRange(e, TextDirection_ltr, TextDirection_rtl)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTextDirection()[index];
}

enum PathVerb : uint8_t {
  PathVerb_move = 0,
  PathVerb_line = 1,
  PathVerb_quad = 2,
  PathVerb_conic = 3,
  PathVerb_cubic = 4,
  PathVerb_close = 5,
  PathVerb_done = 6,
  PathVerb_MIN = PathVerb_move,
  PathVerb_MAX = PathVerb_done
};

inline const PathVerb (&EnumValuesPathVerb())[7] {
  static const PathVerb values[] = {
    PathVerb_move,
    PathVerb_line,
    PathVerb_quad,
    PathVerb_conic,
    PathVerb_cubic,
    PathVerb_close,
    PathVerb_done
  };
  return values;
}

inline const char * const *EnumNamesPathVerb() {
  static const char * const names[8] = {
    "move",
    "line",
    "quad",
    "conic",
    "cubic",
    "close",
    "done",
    nullptr
  };
  return names;
}

inline const char *EnumNamePathVerb(PathVerb e) {
  if (::flatbuffers::IsOutRange(e, PathVerb_move, PathVerb_done)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPathVerb()[index];
}

enum PathFillType : uint8_t {
  PathFillType_winding = 0,
  PathFillType_evenOdd = 1,
  PathFillType_inverseWinding = 2,
  PathFillType_inverseEvenOdd = 3,
  PathFillType_MIN = PathFillType_winding,
  PathFillType_MAX = PathFillType_inverseEvenOdd
};

inline const PathFillType (&EnumValuesPathFillType())[4] {
  static const PathFillType values[] = {
    PathFillType_winding,
    PathFillType_evenOdd,
    PathFillType_inverseWinding,
    PathFillType_inverseEvenOdd
  };
  return values;
}

inline const char * const *EnumNamesPathFillType() {
  static const char * const names[5] = {
    "winding",
    "evenOdd",
    "inverseWinding",
    "inverseEvenOdd",
    nullptr
  };
  return names;
}

inline const char *EnumNamePathFillType(PathFillType e) {
  if (::flatbuffers::IsOutRange(e, PathFillType_winding, PathFillType_inverseEvenOdd)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPathFillType()[index];
}

enum VectorCmdArg : uint8_t {
  VectorCmdArg_NONE = 0,
  VectorCmdArg_CmdRegisterFont = 1,
  VectorCmdArg_CmdPolyline = 2,
  VectorCmdArg_CmdConvexPolyFilled = 3,
  VectorCmdArg_CmdLine = 4,
  VectorCmdArg_CmdRectRounded = 5,
  VectorCmdArg_CmdRectRoundedCorners = 6,
  VectorCmdArg_CmdRectRoundedFilled = 7,
  VectorCmdArg_CmdRectRoundedCornersFilled = 8,
  VectorCmdArg_CmdQuad = 9,
  VectorCmdArg_CmdQuadFilled = 10,
  VectorCmdArg_CmdTriangle = 11,
  VectorCmdArg_CmdTriangleFilled = 12,
  VectorCmdArg_CmdCircle = 13,
  VectorCmdArg_CmdCircleFilled = 14,
  VectorCmdArg_CmdNgon = 15,
  VectorCmdArg_CmdNgonFilled = 16,
  VectorCmdArg_CmdEllipse = 17,
  VectorCmdArg_CmdEllipseFilled = 18,
  VectorCmdArg_CmdBezierCubic = 19,
  VectorCmdArg_CmdBezierQuadratic = 20,
  VectorCmdArg_CmdImage = 21,
  VectorCmdArg_CmdImageQuad = 22,
  VectorCmdArg_CmdImageRounded = 23,
  VectorCmdArg_CmdPushClipRect = 24,
  VectorCmdArg_CmdPopClipRect = 25,
  VectorCmdArg_CmdRenderText = 26,
  VectorCmdArg_CmdRenderParagraph = 27,
  VectorCmdArg_CmdRenderUnicodeCodepoint = 28,
  VectorCmdArg_CmdRectFilledMultiColor = 29,
  VectorCmdArg_CmdWrappedDrawList = 30,
  VectorCmdArg_CmdVertexDraw = 31,
  VectorCmdArg_CmdPushRotation = 32,
  VectorCmdArg_CmdPopRotation = 33,
  VectorCmdArg_CmdSimpleVertexDraw = 34,
  VectorCmdArg_CmdSvgPathSubset = 35,
  VectorCmdArg_CmdPath = 36,
  VectorCmdArg_MIN = VectorCmdArg_NONE,
  VectorCmdArg_MAX = VectorCmdArg_CmdPath
};

inline const VectorCmdArg (&EnumValuesVectorCmdArg())[37] {
  static const VectorCmdArg values[] = {
    VectorCmdArg_NONE,
    VectorCmdArg_CmdRegisterFont,
    VectorCmdArg_CmdPolyline,
    VectorCmdArg_CmdConvexPolyFilled,
    VectorCmdArg_CmdLine,
    VectorCmdArg_CmdRectRounded,
    VectorCmdArg_CmdRectRoundedCorners,
    VectorCmdArg_CmdRectRoundedFilled,
    VectorCmdArg_CmdRectRoundedCornersFilled,
    VectorCmdArg_CmdQuad,
    VectorCmdArg_CmdQuadFilled,
    VectorCmdArg_CmdTriangle,
    VectorCmdArg_CmdTriangleFilled,
    VectorCmdArg_CmdCircle,
    VectorCmdArg_CmdCircleFilled,
    VectorCmdArg_CmdNgon,
    VectorCmdArg_CmdNgonFilled,
    VectorCmdArg_CmdEllipse,
    VectorCmdArg_CmdEllipseFilled,
    VectorCmdArg_CmdBezierCubic,
    VectorCmdArg_CmdBezierQuadratic,
    VectorCmdArg_CmdImage,
    VectorCmdArg_CmdImageQuad,
    VectorCmdArg_CmdImageRounded,
    VectorCmdArg_CmdPushClipRect,
    VectorCmdArg_CmdPopClipRect,
    VectorCmdArg_CmdRenderText,
    VectorCmdArg_CmdRenderParagraph,
    VectorCmdArg_CmdRenderUnicodeCodepoint,
    VectorCmdArg_CmdRectFilledMultiColor,
    VectorCmdArg_CmdWrappedDrawList,
    VectorCmdArg_CmdVertexDraw,
    VectorCmdArg_CmdPushRotation,
    VectorCmdArg_CmdPopRotation,
    VectorCmdArg_CmdSimpleVertexDraw,
    VectorCmdArg_CmdSvgPathSubset,
    VectorCmdArg_CmdPath
  };
  return values;
}

inline const char * const *EnumNamesVectorCmdArg() {
  static const char * const names[38] = {
    "NONE",
    "CmdRegisterFont",
    "CmdPolyline",
    "CmdConvexPolyFilled",
    "CmdLine",
    "CmdRectRounded",
    "CmdRectRoundedCorners",
    "CmdRectRoundedFilled",
    "CmdRectRoundedCornersFilled",
    "CmdQuad",
    "CmdQuadFilled",
    "CmdTriangle",
    "CmdTriangleFilled",
    "CmdCircle",
    "CmdCircleFilled",
    "CmdNgon",
    "CmdNgonFilled",
    "CmdEllipse",
    "CmdEllipseFilled",
    "CmdBezierCubic",
    "CmdBezierQuadratic",
    "CmdImage",
    "CmdImageQuad",
    "CmdImageRounded",
    "CmdPushClipRect",
    "CmdPopClipRect",
    "CmdRenderText",
    "CmdRenderParagraph",
    "CmdRenderUnicodeCodepoint",
    "CmdRectFilledMultiColor",
    "CmdWrappedDrawList",
    "CmdVertexDraw",
    "CmdPushRotation",
    "CmdPopRotation",
    "CmdSimpleVertexDraw",
    "CmdSvgPathSubset",
    "CmdPath",
    nullptr
  };
  return names;
}

inline const char *EnumNameVectorCmdArg(VectorCmdArg e) {
  if (::flatbuffers::IsOutRange(e, VectorCmdArg_NONE, VectorCmdArg_CmdPath)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesVectorCmdArg()[index];
}

template<typename T> struct VectorCmdArgTraits {
  static const VectorCmdArg enum_value = VectorCmdArg_NONE;
};

template<> struct VectorCmdArgTraits<ImZeroFB::CmdRegisterFont> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdRegisterFont;
};

template<> struct VectorCmdArgTraits<ImZeroFB::CmdPolyline> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdPolyline;
};

template<> struct VectorCmdArgTraits<ImZeroFB::CmdConvexPolyFilled> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdConvexPolyFilled;
};

template<> struct VectorCmdArgTraits<ImZeroFB::CmdLine> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdLine;
};

template<> struct VectorCmdArgTraits<ImZeroFB::CmdRectRounded> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdRectRounded;
};

template<> struct VectorCmdArgTraits<ImZeroFB::CmdRectRoundedCorners> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdRectRoundedCorners;
};

template<> struct VectorCmdArgTraits<ImZeroFB::CmdRectRoundedFilled> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdRectRoundedFilled;
};

template<> struct VectorCmdArgTraits<ImZeroFB::CmdRectRoundedCornersFilled> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdRectRoundedCornersFilled;
};

template<> struct VectorCmdArgTraits<ImZeroFB::CmdQuad> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdQuad;
};

template<> struct VectorCmdArgTraits<ImZeroFB::CmdQuadFilled> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdQuadFilled;
};

template<> struct VectorCmdArgTraits<ImZeroFB::CmdTriangle> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdTriangle;
};

template<> struct VectorCmdArgTraits<ImZeroFB::CmdTriangleFilled> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdTriangleFilled;
};

template<> struct VectorCmdArgTraits<ImZeroFB::CmdCircle> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdCircle;
};

template<> struct VectorCmdArgTraits<ImZeroFB::CmdCircleFilled> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdCircleFilled;
};

template<> struct VectorCmdArgTraits<ImZeroFB::CmdNgon> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdNgon;
};

template<> struct VectorCmdArgTraits<ImZeroFB::CmdNgonFilled> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdNgonFilled;
};

template<> struct VectorCmdArgTraits<ImZeroFB::CmdEllipse> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdEllipse;
};

template<> struct VectorCmdArgTraits<ImZeroFB::CmdEllipseFilled> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdEllipseFilled;
};

template<> struct VectorCmdArgTraits<ImZeroFB::CmdBezierCubic> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdBezierCubic;
};

template<> struct VectorCmdArgTraits<ImZeroFB::CmdBezierQuadratic> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdBezierQuadratic;
};

template<> struct VectorCmdArgTraits<ImZeroFB::CmdImage> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdImage;
};

template<> struct VectorCmdArgTraits<ImZeroFB::CmdImageQuad> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdImageQuad;
};

template<> struct VectorCmdArgTraits<ImZeroFB::CmdImageRounded> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdImageRounded;
};

template<> struct VectorCmdArgTraits<ImZeroFB::CmdPushClipRect> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdPushClipRect;
};

template<> struct VectorCmdArgTraits<ImZeroFB::CmdPopClipRect> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdPopClipRect;
};

template<> struct VectorCmdArgTraits<ImZeroFB::CmdRenderText> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdRenderText;
};

template<> struct VectorCmdArgTraits<ImZeroFB::CmdRenderParagraph> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdRenderParagraph;
};

template<> struct VectorCmdArgTraits<ImZeroFB::CmdRenderUnicodeCodepoint> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdRenderUnicodeCodepoint;
};

template<> struct VectorCmdArgTraits<ImZeroFB::CmdRectFilledMultiColor> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdRectFilledMultiColor;
};

template<> struct VectorCmdArgTraits<ImZeroFB::CmdWrappedDrawList> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdWrappedDrawList;
};

template<> struct VectorCmdArgTraits<ImZeroFB::CmdVertexDraw> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdVertexDraw;
};

template<> struct VectorCmdArgTraits<ImZeroFB::CmdPushRotation> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdPushRotation;
};

template<> struct VectorCmdArgTraits<ImZeroFB::CmdPopRotation> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdPopRotation;
};

template<> struct VectorCmdArgTraits<ImZeroFB::CmdSimpleVertexDraw> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdSimpleVertexDraw;
};

template<> struct VectorCmdArgTraits<ImZeroFB::CmdSvgPathSubset> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdSvgPathSubset;
};

template<> struct VectorCmdArgTraits<ImZeroFB::CmdPath> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdPath;
};

bool VerifyVectorCmdArg(::flatbuffers::Verifier &verifier, const void *obj, VectorCmdArg type);
bool VerifyVectorCmdArgVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum DrawListFlags : uint8_t {
  DrawListFlags_None = 0,
  DrawListFlags_AntiAliasedLines = 1,
  DrawListFlags_AntiAliasedFill = 2,
  DrawListFlags_AntiAliasedText = 4,
  DrawListFlags_AntiAliasedClipping = 8,
  DrawListFlags_MIN = DrawListFlags_None,
  DrawListFlags_MAX = DrawListFlags_AntiAliasedClipping
};

inline const DrawListFlags (&EnumValuesDrawListFlags())[5] {
  static const DrawListFlags values[] = {
    DrawListFlags_None,
    DrawListFlags_AntiAliasedLines,
    DrawListFlags_AntiAliasedFill,
    DrawListFlags_AntiAliasedText,
    DrawListFlags_AntiAliasedClipping
  };
  return values;
}

inline const char * const *EnumNamesDrawListFlags() {
  static const char * const names[10] = {
    "None",
    "AntiAliasedLines",
    "AntiAliasedFill",
    "",
    "AntiAliasedText",
    "",
    "",
    "",
    "AntiAliasedClipping",
    nullptr
  };
  return names;
}

inline const char *EnumNameDrawListFlags(DrawListFlags e) {
  if (::flatbuffers::IsOutRange(e, DrawListFlags_None, DrawListFlags_AntiAliasedClipping)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDrawListFlags()[index];
}

enum IoFlags : uint16_t {
  IoFlags_None = 0,
  IoFlags_WantCaptureMouse = 1,
  IoFlags_WantCaptureKeyboard = 2,
  IoFlags_WantTextInput = 4,
  IoFlags_WantSetMousePos = 8,
  IoFlags_NavIsActive = 16,
  IoFlags_NavIsVisible = 32,
  IoFlags_MIN = IoFlags_None,
  IoFlags_MAX = IoFlags_NavIsVisible
};

inline const IoFlags (&EnumValuesIoFlags())[7] {
  static const IoFlags values[] = {
    IoFlags_None,
    IoFlags_WantCaptureMouse,
    IoFlags_WantCaptureKeyboard,
    IoFlags_WantTextInput,
    IoFlags_WantSetMousePos,
    IoFlags_NavIsActive,
    IoFlags_NavIsVisible
  };
  return values;
}

inline const char * const *EnumNamesIoFlags() {
  static const char * const names[34] = {
    "None",
    "WantCaptureMouse",
    "WantCaptureKeyboard",
    "",
    "WantTextInput",
    "",
    "",
    "",
    "WantSetMousePos",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "NavIsActive",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "NavIsVisible",
    nullptr
  };
  return names;
}

inline const char *EnumNameIoFlags(IoFlags e) {
  if (::flatbuffers::IsOutRange(e, IoFlags_None, IoFlags_NavIsVisible)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesIoFlags()[index];
}

enum MouseButton : uint8_t {
  MouseButton_None = 0,
  MouseButton_Left = 1,
  MouseButton_Right = 2,
  MouseButton_Middle = 3,
  MouseButton_X1 = 4,
  MouseButton_X2 = 5,
  MouseButton_MIN = MouseButton_None,
  MouseButton_MAX = MouseButton_X2
};

inline const MouseButton (&EnumValuesMouseButton())[6] {
  static const MouseButton values[] = {
    MouseButton_None,
    MouseButton_Left,
    MouseButton_Right,
    MouseButton_Middle,
    MouseButton_X1,
    MouseButton_X2
  };
  return values;
}

inline const char * const *EnumNamesMouseButton() {
  static const char * const names[7] = {
    "None",
    "Left",
    "Right",
    "Middle",
    "X1",
    "X2",
    nullptr
  };
  return names;
}

inline const char *EnumNameMouseButton(MouseButton e) {
  if (::flatbuffers::IsOutRange(e, MouseButton_None, MouseButton_X2)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMouseButton()[index];
}

enum MouseButtonEventType : uint8_t {
  MouseButtonEventType_Up = 0,
  MouseButtonEventType_Down = 1,
  MouseButtonEventType_MIN = MouseButtonEventType_Up,
  MouseButtonEventType_MAX = MouseButtonEventType_Down
};

inline const MouseButtonEventType (&EnumValuesMouseButtonEventType())[2] {
  static const MouseButtonEventType values[] = {
    MouseButtonEventType_Up,
    MouseButtonEventType_Down
  };
  return values;
}

inline const char * const *EnumNamesMouseButtonEventType() {
  static const char * const names[3] = {
    "Up",
    "Down",
    nullptr
  };
  return names;
}

inline const char *EnumNameMouseButtonEventType(MouseButtonEventType e) {
  if (::flatbuffers::IsOutRange(e, MouseButtonEventType_Up, MouseButtonEventType_Down)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMouseButtonEventType()[index];
}

enum KeyModifiers : uint8_t {
  KeyModifiers_None = 0,
  KeyModifiers_Ctrl = 1,
  KeyModifiers_Shift = 2,
  KeyModifiers_Alt = 4,
  KeyModifiers_Super = 8,
  KeyModifiers_MIN = KeyModifiers_None,
  KeyModifiers_MAX = KeyModifiers_Super
};

inline const KeyModifiers (&EnumValuesKeyModifiers())[5] {
  static const KeyModifiers values[] = {
    KeyModifiers_None,
    KeyModifiers_Ctrl,
    KeyModifiers_Shift,
    KeyModifiers_Alt,
    KeyModifiers_Super
  };
  return values;
}

inline const char * const *EnumNamesKeyModifiers() {
  static const char * const names[10] = {
    "None",
    "Ctrl",
    "Shift",
    "",
    "Alt",
    "",
    "",
    "",
    "Super",
    nullptr
  };
  return names;
}

inline const char *EnumNameKeyModifiers(KeyModifiers e) {
  if (::flatbuffers::IsOutRange(e, KeyModifiers_None, KeyModifiers_Super)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesKeyModifiers()[index];
}

enum KeyCode : uint32_t {
  KeyCode_Key_None = 0,
  KeyCode_Key_Tab = 1,
  KeyCode_Key_LeftArrow = 2,
  KeyCode_Key_RightArrow = 3,
  KeyCode_Key_UpArrow = 4,
  KeyCode_Key_DownArrow = 5,
  KeyCode_Key_PageUp = 6,
  KeyCode_Key_PageDown = 7,
  KeyCode_Key_Home = 8,
  KeyCode_Key_End = 9,
  KeyCode_Key_Insert = 10,
  KeyCode_Key_Delete = 11,
  KeyCode_Key_Backspace = 12,
  KeyCode_Key_Space = 13,
  KeyCode_Key_Enter = 14,
  KeyCode_Key_Escape = 15,
  KeyCode_Key_Apostrophe = 16,
  KeyCode_Key_Comma = 17,
  KeyCode_Key_Minus = 18,
  KeyCode_Key_Period = 19,
  KeyCode_Key_Slash = 20,
  KeyCode_Key_Semicolon = 21,
  KeyCode_Key_Equal = 22,
  KeyCode_Key_LeftBracket = 23,
  KeyCode_Key_Backslash = 24,
  KeyCode_Key_RightBracket = 25,
  KeyCode_Key_GraveAccent = 26,
  KeyCode_Key_CapsLock = 27,
  KeyCode_Key_ScrollLock = 28,
  KeyCode_Key_NumLock = 29,
  KeyCode_Key_PrintScreen = 30,
  KeyCode_Key_Pause = 31,
  KeyCode_Key_Keypad0 = 32,
  KeyCode_Key_Keypad1 = 33,
  KeyCode_Key_Keypad2 = 34,
  KeyCode_Key_Keypad3 = 35,
  KeyCode_Key_Keypad4 = 36,
  KeyCode_Key_Keypad5 = 37,
  KeyCode_Key_Keypad6 = 38,
  KeyCode_Key_Keypad7 = 39,
  KeyCode_Key_Keypad8 = 40,
  KeyCode_Key_Keypad9 = 41,
  KeyCode_Key_KeypadDecimal = 42,
  KeyCode_Key_KeypadDivide = 43,
  KeyCode_Key_KeypadMultiply = 44,
  KeyCode_Key_KeypadSubtract = 45,
  KeyCode_Key_KeypadAdd = 46,
  KeyCode_Key_KeypadEnter = 47,
  KeyCode_Key_KeypadEqual = 48,
  KeyCode_Key_LeftCtrl = 49,
  KeyCode_Key_LeftShift = 50,
  KeyCode_Key_LeftAlt = 51,
  KeyCode_Key_LeftSuper = 52,
  KeyCode_Key_RightCtrl = 53,
  KeyCode_Key_RightShift = 54,
  KeyCode_Key_RightAlt = 55,
  KeyCode_Key_RightSuper = 56,
  KeyCode_Key_Menu = 57,
  KeyCode_Key_0 = 58,
  KeyCode_Key_1 = 59,
  KeyCode_Key_2 = 60,
  KeyCode_Key_3 = 61,
  KeyCode_Key_4 = 62,
  KeyCode_Key_5 = 63,
  KeyCode_Key_6 = 64,
  KeyCode_Key_7 = 65,
  KeyCode_Key_8 = 66,
  KeyCode_Key_9 = 67,
  KeyCode_Key_A = 68,
  KeyCode_Key_B = 69,
  KeyCode_Key_C = 70,
  KeyCode_Key_D = 71,
  KeyCode_Key_E = 72,
  KeyCode_Key_F = 73,
  KeyCode_Key_G = 74,
  KeyCode_Key_H = 75,
  KeyCode_Key_I = 76,
  KeyCode_Key_J = 77,
  KeyCode_Key_K = 78,
  KeyCode_Key_L = 79,
  KeyCode_Key_M = 80,
  KeyCode_Key_N = 81,
  KeyCode_Key_O = 82,
  KeyCode_Key_P = 83,
  KeyCode_Key_Q = 84,
  KeyCode_Key_R = 85,
  KeyCode_Key_S = 86,
  KeyCode_Key_T = 87,
  KeyCode_Key_U = 88,
  KeyCode_Key_V = 89,
  KeyCode_Key_W = 90,
  KeyCode_Key_X = 91,
  KeyCode_Key_Y = 92,
  KeyCode_Key_Z = 93,
  KeyCode_Key_F1 = 94,
  KeyCode_Key_F2 = 95,
  KeyCode_Key_F3 = 96,
  KeyCode_Key_F4 = 97,
  KeyCode_Key_F5 = 98,
  KeyCode_Key_F6 = 99,
  KeyCode_Key_F7 = 100,
  KeyCode_Key_F8 = 101,
  KeyCode_Key_F9 = 102,
  KeyCode_Key_F10 = 103,
  KeyCode_Key_F11 = 104,
  KeyCode_Key_F12 = 105,
  KeyCode_Key_F13 = 106,
  KeyCode_Key_F14 = 107,
  KeyCode_Key_F15 = 108,
  KeyCode_Key_F16 = 109,
  KeyCode_Key_F17 = 110,
  KeyCode_Key_F18 = 111,
  KeyCode_Key_F19 = 112,
  KeyCode_Key_F20 = 113,
  KeyCode_Key_F21 = 114,
  KeyCode_Key_F22 = 115,
  KeyCode_Key_F23 = 116,
  KeyCode_Key_F24 = 117,
  KeyCode_Key_AppBack = 118,
  KeyCode_Key_AppForward = 119,
  KeyCode_MIN = KeyCode_Key_None,
  KeyCode_MAX = KeyCode_Key_AppForward
};

inline const KeyCode (&EnumValuesKeyCode())[120] {
  static const KeyCode values[] = {
    KeyCode_Key_None,
    KeyCode_Key_Tab,
    KeyCode_Key_LeftArrow,
    KeyCode_Key_RightArrow,
    KeyCode_Key_UpArrow,
    KeyCode_Key_DownArrow,
    KeyCode_Key_PageUp,
    KeyCode_Key_PageDown,
    KeyCode_Key_Home,
    KeyCode_Key_End,
    KeyCode_Key_Insert,
    KeyCode_Key_Delete,
    KeyCode_Key_Backspace,
    KeyCode_Key_Space,
    KeyCode_Key_Enter,
    KeyCode_Key_Escape,
    KeyCode_Key_Apostrophe,
    KeyCode_Key_Comma,
    KeyCode_Key_Minus,
    KeyCode_Key_Period,
    KeyCode_Key_Slash,
    KeyCode_Key_Semicolon,
    KeyCode_Key_Equal,
    KeyCode_Key_LeftBracket,
    KeyCode_Key_Backslash,
    KeyCode_Key_RightBracket,
    KeyCode_Key_GraveAccent,
    KeyCode_Key_CapsLock,
    KeyCode_Key_ScrollLock,
    KeyCode_Key_NumLock,
    KeyCode_Key_PrintScreen,
    KeyCode_Key_Pause,
    KeyCode_Key_Keypad0,
    KeyCode_Key_Keypad1,
    KeyCode_Key_Keypad2,
    KeyCode_Key_Keypad3,
    KeyCode_Key_Keypad4,
    KeyCode_Key_Keypad5,
    KeyCode_Key_Keypad6,
    KeyCode_Key_Keypad7,
    KeyCode_Key_Keypad8,
    KeyCode_Key_Keypad9,
    KeyCode_Key_KeypadDecimal,
    KeyCode_Key_KeypadDivide,
    KeyCode_Key_KeypadMultiply,
    KeyCode_Key_KeypadSubtract,
    KeyCode_Key_KeypadAdd,
    KeyCode_Key_KeypadEnter,
    KeyCode_Key_KeypadEqual,
    KeyCode_Key_LeftCtrl,
    KeyCode_Key_LeftShift,
    KeyCode_Key_LeftAlt,
    KeyCode_Key_LeftSuper,
    KeyCode_Key_RightCtrl,
    KeyCode_Key_RightShift,
    KeyCode_Key_RightAlt,
    KeyCode_Key_RightSuper,
    KeyCode_Key_Menu,
    KeyCode_Key_0,
    KeyCode_Key_1,
    KeyCode_Key_2,
    KeyCode_Key_3,
    KeyCode_Key_4,
    KeyCode_Key_5,
    KeyCode_Key_6,
    KeyCode_Key_7,
    KeyCode_Key_8,
    KeyCode_Key_9,
    KeyCode_Key_A,
    KeyCode_Key_B,
    KeyCode_Key_C,
    KeyCode_Key_D,
    KeyCode_Key_E,
    KeyCode_Key_F,
    KeyCode_Key_G,
    KeyCode_Key_H,
    KeyCode_Key_I,
    KeyCode_Key_J,
    KeyCode_Key_K,
    KeyCode_Key_L,
    KeyCode_Key_M,
    KeyCode_Key_N,
    KeyCode_Key_O,
    KeyCode_Key_P,
    KeyCode_Key_Q,
    KeyCode_Key_R,
    KeyCode_Key_S,
    KeyCode_Key_T,
    KeyCode_Key_U,
    KeyCode_Key_V,
    KeyCode_Key_W,
    KeyCode_Key_X,
    KeyCode_Key_Y,
    KeyCode_Key_Z,
    KeyCode_Key_F1,
    KeyCode_Key_F2,
    KeyCode_Key_F3,
    KeyCode_Key_F4,
    KeyCode_Key_F5,
    KeyCode_Key_F6,
    KeyCode_Key_F7,
    KeyCode_Key_F8,
    KeyCode_Key_F9,
    KeyCode_Key_F10,
    KeyCode_Key_F11,
    KeyCode_Key_F12,
    KeyCode_Key_F13,
    KeyCode_Key_F14,
    KeyCode_Key_F15,
    KeyCode_Key_F16,
    KeyCode_Key_F17,
    KeyCode_Key_F18,
    KeyCode_Key_F19,
    KeyCode_Key_F20,
    KeyCode_Key_F21,
    KeyCode_Key_F22,
    KeyCode_Key_F23,
    KeyCode_Key_F24,
    KeyCode_Key_AppBack,
    KeyCode_Key_AppForward
  };
  return values;
}

inline const char * const *EnumNamesKeyCode() {
  static const char * const names[121] = {
    "Key_None",
    "Key_Tab",
    "Key_LeftArrow",
    "Key_RightArrow",
    "Key_UpArrow",
    "Key_DownArrow",
    "Key_PageUp",
    "Key_PageDown",
    "Key_Home",
    "Key_End",
    "Key_Insert",
    "Key_Delete",
    "Key_Backspace",
    "Key_Space",
    "Key_Enter",
    "Key_Escape",
    "Key_Apostrophe",
    "Key_Comma",
    "Key_Minus",
    "Key_Period",
    "Key_Slash",
    "Key_Semicolon",
    "Key_Equal",
    "Key_LeftBracket",
    "Key_Backslash",
    "Key_RightBracket",
    "Key_GraveAccent",
    "Key_CapsLock",
    "Key_ScrollLock",
    "Key_NumLock",
    "Key_PrintScreen",
    "Key_Pause",
    "Key_Keypad0",
    "Key_Keypad1",
    "Key_Keypad2",
    "Key_Keypad3",
    "Key_Keypad4",
    "Key_Keypad5",
    "Key_Keypad6",
    "Key_Keypad7",
    "Key_Keypad8",
    "Key_Keypad9",
    "Key_KeypadDecimal",
    "Key_KeypadDivide",
    "Key_KeypadMultiply",
    "Key_KeypadSubtract",
    "Key_KeypadAdd",
    "Key_KeypadEnter",
    "Key_KeypadEqual",
    "Key_LeftCtrl",
    "Key_LeftShift",
    "Key_LeftAlt",
    "Key_LeftSuper",
    "Key_RightCtrl",
    "Key_RightShift",
    "Key_RightAlt",
    "Key_RightSuper",
    "Key_Menu",
    "Key_0",
    "Key_1",
    "Key_2",
    "Key_3",
    "Key_4",
    "Key_5",
    "Key_6",
    "Key_7",
    "Key_8",
    "Key_9",
    "Key_A",
    "Key_B",
    "Key_C",
    "Key_D",
    "Key_E",
    "Key_F",
    "Key_G",
    "Key_H",
    "Key_I",
    "Key_J",
    "Key_K",
    "Key_L",
    "Key_M",
    "Key_N",
    "Key_O",
    "Key_P",
    "Key_Q",
    "Key_R",
    "Key_S",
    "Key_T",
    "Key_U",
    "Key_V",
    "Key_W",
    "Key_X",
    "Key_Y",
    "Key_Z",
    "Key_F1",
    "Key_F2",
    "Key_F3",
    "Key_F4",
    "Key_F5",
    "Key_F6",
    "Key_F7",
    "Key_F8",
    "Key_F9",
    "Key_F10",
    "Key_F11",
    "Key_F12",
    "Key_F13",
    "Key_F14",
    "Key_F15",
    "Key_F16",
    "Key_F17",
    "Key_F18",
    "Key_F19",
    "Key_F20",
    "Key_F21",
    "Key_F22",
    "Key_F23",
    "Key_F24",
    "Key_AppBack",
    "Key_AppForward",
    nullptr
  };
  return names;
}

inline const char *EnumNameKeyCode(KeyCode e) {
  if (::flatbuffers::IsOutRange(e, KeyCode_Key_None, KeyCode_Key_AppForward)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesKeyCode()[index];
}

enum UserInteraction : uint8_t {
  UserInteraction_NONE = 0,
  UserInteraction_EventMouseMotion = 1,
  UserInteraction_EventMouseWheel = 2,
  UserInteraction_EventMouseButton = 3,
  UserInteraction_EventTextInput = 4,
  UserInteraction_EventKeyboard = 5,
  UserInteraction_MIN = UserInteraction_NONE,
  UserInteraction_MAX = UserInteraction_EventKeyboard
};

inline const UserInteraction (&EnumValuesUserInteraction())[6] {
  static const UserInteraction values[] = {
    UserInteraction_NONE,
    UserInteraction_EventMouseMotion,
    UserInteraction_EventMouseWheel,
    UserInteraction_EventMouseButton,
    UserInteraction_EventTextInput,
    UserInteraction_EventKeyboard
  };
  return values;
}

inline const char * const *EnumNamesUserInteraction() {
  static const char * const names[7] = {
    "NONE",
    "EventMouseMotion",
    "EventMouseWheel",
    "EventMouseButton",
    "EventTextInput",
    "EventKeyboard",
    nullptr
  };
  return names;
}

inline const char *EnumNameUserInteraction(UserInteraction e) {
  if (::flatbuffers::IsOutRange(e, UserInteraction_NONE, UserInteraction_EventKeyboard)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesUserInteraction()[index];
}

template<typename T> struct UserInteractionTraits {
  static const UserInteraction enum_value = UserInteraction_NONE;
};

template<> struct UserInteractionTraits<ImZeroFB::EventMouseMotion> {
  static const UserInteraction enum_value = UserInteraction_EventMouseMotion;
};

template<> struct UserInteractionTraits<ImZeroFB::EventMouseWheel> {
  static const UserInteraction enum_value = UserInteraction_EventMouseWheel;
};

template<> struct UserInteractionTraits<ImZeroFB::EventMouseButton> {
  static const UserInteraction enum_value = UserInteraction_EventMouseButton;
};

template<> struct UserInteractionTraits<ImZeroFB::EventTextInput> {
  static const UserInteraction enum_value = UserInteraction_EventTextInput;
};

template<> struct UserInteractionTraits<ImZeroFB::EventKeyboard> {
  static const UserInteraction enum_value = UserInteraction_EventKeyboard;
};

bool VerifyUserInteraction(::flatbuffers::Verifier &verifier, const void *obj, UserInteraction type);
bool VerifyUserInteractionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) SingleVec2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SingleVec2TypeTable();
  }
  SingleVec2()
      : x_(0),
        y_(0) {
  }
  SingleVec2(float _x, float _y)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(SingleVec2, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) SingleVec4 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SingleVec4TypeTable();
  }
  SingleVec4()
      : x_(0),
        y_(0),
        z_(0),
        w_(0) {
  }
  SingleVec4(float _x, float _y, float _z, float _w)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)),
        z_(::flatbuffers::EndianScalar(_z)),
        w_(::flatbuffers::EndianScalar(_w)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return ::flatbuffers::EndianScalar(z_);
  }
  float w() const {
    return ::flatbuffers::EndianScalar(w_);
  }
};
FLATBUFFERS_STRUCT_END(SingleVec4, 16);

struct ArrayOfVec2 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ArrayOfVec2Builder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ArrayOfVec2TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_XS = 4,
    VT_YS = 6
  };
  const ::flatbuffers::Vector<float> *xs() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_XS);
  }
  const ::flatbuffers::Vector<float> *ys() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_YS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_XS) &&
           verifier.VerifyVector(xs()) &&
           VerifyOffset(verifier, VT_YS) &&
           verifier.VerifyVector(ys()) &&
           verifier.EndTable();
  }
};

struct ArrayOfVec2Builder {
  typedef ArrayOfVec2 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_xs(::flatbuffers::Offset<::flatbuffers::Vector<float>> xs) {
    fbb_.AddOffset(ArrayOfVec2::VT_XS, xs);
  }
  void add_ys(::flatbuffers::Offset<::flatbuffers::Vector<float>> ys) {
    fbb_.AddOffset(ArrayOfVec2::VT_YS, ys);
  }
  explicit ArrayOfVec2Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ArrayOfVec2> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ArrayOfVec2>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ArrayOfVec2> CreateArrayOfVec2(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> xs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> ys = 0) {
  ArrayOfVec2Builder builder_(_fbb);
  builder_.add_ys(ys);
  builder_.add_xs(xs);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ArrayOfVec2> CreateArrayOfVec2Direct(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *xs = nullptr,
    const std::vector<float> *ys = nullptr) {
  auto xs__ = xs ? _fbb.CreateVector<float>(*xs) : 0;
  auto ys__ = ys ? _fbb.CreateVector<float>(*ys) : 0;
  return ImZeroFB::CreateArrayOfVec2(
      _fbb,
      xs__,
      ys__);
}

struct ArrayOfVec4 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ArrayOfVec4Builder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ArrayOfVec4TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_XS = 4,
    VT_YS = 6,
    VT_ZS = 8,
    VT_WS = 10
  };
  const ::flatbuffers::Vector<float> *xs() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_XS);
  }
  const ::flatbuffers::Vector<float> *ys() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_YS);
  }
  const ::flatbuffers::Vector<float> *zs() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_ZS);
  }
  const ::flatbuffers::Vector<float> *ws() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_WS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_XS) &&
           verifier.VerifyVector(xs()) &&
           VerifyOffset(verifier, VT_YS) &&
           verifier.VerifyVector(ys()) &&
           VerifyOffset(verifier, VT_ZS) &&
           verifier.VerifyVector(zs()) &&
           VerifyOffset(verifier, VT_WS) &&
           verifier.VerifyVector(ws()) &&
           verifier.EndTable();
  }
};

struct ArrayOfVec4Builder {
  typedef ArrayOfVec4 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_xs(::flatbuffers::Offset<::flatbuffers::Vector<float>> xs) {
    fbb_.AddOffset(ArrayOfVec4::VT_XS, xs);
  }
  void add_ys(::flatbuffers::Offset<::flatbuffers::Vector<float>> ys) {
    fbb_.AddOffset(ArrayOfVec4::VT_YS, ys);
  }
  void add_zs(::flatbuffers::Offset<::flatbuffers::Vector<float>> zs) {
    fbb_.AddOffset(ArrayOfVec4::VT_ZS, zs);
  }
  void add_ws(::flatbuffers::Offset<::flatbuffers::Vector<float>> ws) {
    fbb_.AddOffset(ArrayOfVec4::VT_WS, ws);
  }
  explicit ArrayOfVec4Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ArrayOfVec4> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ArrayOfVec4>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ArrayOfVec4> CreateArrayOfVec4(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> xs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> ys = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> zs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> ws = 0) {
  ArrayOfVec4Builder builder_(_fbb);
  builder_.add_ws(ws);
  builder_.add_zs(zs);
  builder_.add_ys(ys);
  builder_.add_xs(xs);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ArrayOfVec4> CreateArrayOfVec4Direct(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *xs = nullptr,
    const std::vector<float> *ys = nullptr,
    const std::vector<float> *zs = nullptr,
    const std::vector<float> *ws = nullptr) {
  auto xs__ = xs ? _fbb.CreateVector<float>(*xs) : 0;
  auto ys__ = ys ? _fbb.CreateVector<float>(*ys) : 0;
  auto zs__ = zs ? _fbb.CreateVector<float>(*zs) : 0;
  auto ws__ = ws ? _fbb.CreateVector<float>(*ws) : 0;
  return ImZeroFB::CreateArrayOfVec4(
      _fbb,
      xs__,
      ys__,
      zs__,
      ws__);
}

struct CmdRegisterFont FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdRegisterFontBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CmdRegisterFontTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_URL = 6,
    VT_SUBPIXEL = 8
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *url() const {
    return GetPointer<const ::flatbuffers::String *>(VT_URL);
  }
  bool subpixel() const {
    return GetField<uint8_t>(VT_SUBPIXEL, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_URL) &&
           verifier.VerifyString(url()) &&
           VerifyField<uint8_t>(verifier, VT_SUBPIXEL, 1) &&
           verifier.EndTable();
  }
};

struct CmdRegisterFontBuilder {
  typedef CmdRegisterFont Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(CmdRegisterFont::VT_NAME, name);
  }
  void add_url(::flatbuffers::Offset<::flatbuffers::String> url) {
    fbb_.AddOffset(CmdRegisterFont::VT_URL, url);
  }
  void add_subpixel(bool subpixel) {
    fbb_.AddElement<uint8_t>(CmdRegisterFont::VT_SUBPIXEL, static_cast<uint8_t>(subpixel), 0);
  }
  explicit CmdRegisterFontBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdRegisterFont> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdRegisterFont>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdRegisterFont> CreateCmdRegisterFont(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> url = 0,
    bool subpixel = false) {
  CmdRegisterFontBuilder builder_(_fbb);
  builder_.add_url(url);
  builder_.add_name(name);
  builder_.add_subpixel(subpixel);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CmdRegisterFont> CreateCmdRegisterFontDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *url = nullptr,
    bool subpixel = false) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto url__ = url ? _fbb.CreateString(url) : 0;
  return ImZeroFB::CreateCmdRegisterFont(
      _fbb,
      name__,
      url__,
      subpixel);
}

struct CmdPolyline FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdPolylineBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CmdPolylineTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POINTS = 4,
    VT_COL = 6,
    VT_FLAGS = 8,
    VT_THICKNESS = 10
  };
  const ImZeroFB::ArrayOfVec2 *points() const {
    return GetPointer<const ImZeroFB::ArrayOfVec2 *>(VT_POINTS);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  uint32_t flags() const {
    return GetField<uint32_t>(VT_FLAGS, 0);
  }
  float thickness() const {
    return GetField<float>(VT_THICKNESS, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_POINTS) &&
           verifier.VerifyTable(points()) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           VerifyField<uint32_t>(verifier, VT_FLAGS, 4) &&
           VerifyField<float>(verifier, VT_THICKNESS, 4) &&
           verifier.EndTable();
  }
};

struct CmdPolylineBuilder {
  typedef CmdPolyline Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_points(::flatbuffers::Offset<ImZeroFB::ArrayOfVec2> points) {
    fbb_.AddOffset(CmdPolyline::VT_POINTS, points);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdPolyline::VT_COL, col, 0);
  }
  void add_flags(uint32_t flags) {
    fbb_.AddElement<uint32_t>(CmdPolyline::VT_FLAGS, flags, 0);
  }
  void add_thickness(float thickness) {
    fbb_.AddElement<float>(CmdPolyline::VT_THICKNESS, thickness, 0.0f);
  }
  explicit CmdPolylineBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdPolyline> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdPolyline>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdPolyline> CreateCmdPolyline(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ImZeroFB::ArrayOfVec2> points = 0,
    uint32_t col = 0,
    uint32_t flags = 0,
    float thickness = 0.0f) {
  CmdPolylineBuilder builder_(_fbb);
  builder_.add_thickness(thickness);
  builder_.add_flags(flags);
  builder_.add_col(col);
  builder_.add_points(points);
  return builder_.Finish();
}

struct CmdConvexPolyFilled FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdConvexPolyFilledBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CmdConvexPolyFilledTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POINTS = 4,
    VT_COL = 6
  };
  const ImZeroFB::ArrayOfVec2 *points() const {
    return GetPointer<const ImZeroFB::ArrayOfVec2 *>(VT_POINTS);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_POINTS) &&
           verifier.VerifyTable(points()) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           verifier.EndTable();
  }
};

struct CmdConvexPolyFilledBuilder {
  typedef CmdConvexPolyFilled Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_points(::flatbuffers::Offset<ImZeroFB::ArrayOfVec2> points) {
    fbb_.AddOffset(CmdConvexPolyFilled::VT_POINTS, points);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdConvexPolyFilled::VT_COL, col, 0);
  }
  explicit CmdConvexPolyFilledBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdConvexPolyFilled> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdConvexPolyFilled>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdConvexPolyFilled> CreateCmdConvexPolyFilled(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ImZeroFB::ArrayOfVec2> points = 0,
    uint32_t col = 0) {
  CmdConvexPolyFilledBuilder builder_(_fbb);
  builder_.add_col(col);
  builder_.add_points(points);
  return builder_.Finish();
}

struct CmdLine FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdLineBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CmdLineTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_P1 = 4,
    VT_P2 = 6,
    VT_COL = 8,
    VT_THICKNESS = 10
  };
  const ImZeroFB::SingleVec2 *p1() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_P1);
  }
  const ImZeroFB::SingleVec2 *p2() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_P2);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  float thickness() const {
    return GetField<float>(VT_THICKNESS, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_P1, 4) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_P2, 4) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           VerifyField<float>(verifier, VT_THICKNESS, 4) &&
           verifier.EndTable();
  }
};

struct CmdLineBuilder {
  typedef CmdLine Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_p1(const ImZeroFB::SingleVec2 *p1) {
    fbb_.AddStruct(CmdLine::VT_P1, p1);
  }
  void add_p2(const ImZeroFB::SingleVec2 *p2) {
    fbb_.AddStruct(CmdLine::VT_P2, p2);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdLine::VT_COL, col, 0);
  }
  void add_thickness(float thickness) {
    fbb_.AddElement<float>(CmdLine::VT_THICKNESS, thickness, 0.0f);
  }
  explicit CmdLineBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdLine> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdLine>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdLine> CreateCmdLine(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const ImZeroFB::SingleVec2 *p1 = nullptr,
    const ImZeroFB::SingleVec2 *p2 = nullptr,
    uint32_t col = 0,
    float thickness = 0.0f) {
  CmdLineBuilder builder_(_fbb);
  builder_.add_thickness(thickness);
  builder_.add_col(col);
  builder_.add_p2(p2);
  builder_.add_p1(p1);
  return builder_.Finish();
}

struct CmdRectRounded FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdRectRoundedBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CmdRectRoundedTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_P_MIN = 4,
    VT_P_MAX = 6,
    VT_COL = 8,
    VT_ROUNDING = 10,
    VT_THICKNESS = 12
  };
  const ImZeroFB::SingleVec2 *p_min() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_P_MIN);
  }
  const ImZeroFB::SingleVec2 *p_max() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_P_MAX);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  float rounding() const {
    return GetField<float>(VT_ROUNDING, 0.0f);
  }
  float thickness() const {
    return GetField<float>(VT_THICKNESS, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_P_MIN, 4) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_P_MAX, 4) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           VerifyField<float>(verifier, VT_ROUNDING, 4) &&
           VerifyField<float>(verifier, VT_THICKNESS, 4) &&
           verifier.EndTable();
  }
};

struct CmdRectRoundedBuilder {
  typedef CmdRectRounded Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_p_min(const ImZeroFB::SingleVec2 *p_min) {
    fbb_.AddStruct(CmdRectRounded::VT_P_MIN, p_min);
  }
  void add_p_max(const ImZeroFB::SingleVec2 *p_max) {
    fbb_.AddStruct(CmdRectRounded::VT_P_MAX, p_max);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdRectRounded::VT_COL, col, 0);
  }
  void add_rounding(float rounding) {
    fbb_.AddElement<float>(CmdRectRounded::VT_ROUNDING, rounding, 0.0f);
  }
  void add_thickness(float thickness) {
    fbb_.AddElement<float>(CmdRectRounded::VT_THICKNESS, thickness, 0.0f);
  }
  explicit CmdRectRoundedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdRectRounded> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdRectRounded>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdRectRounded> CreateCmdRectRounded(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const ImZeroFB::SingleVec2 *p_min = nullptr,
    const ImZeroFB::SingleVec2 *p_max = nullptr,
    uint32_t col = 0,
    float rounding = 0.0f,
    float thickness = 0.0f) {
  CmdRectRoundedBuilder builder_(_fbb);
  builder_.add_thickness(thickness);
  builder_.add_rounding(rounding);
  builder_.add_col(col);
  builder_.add_p_max(p_max);
  builder_.add_p_min(p_min);
  return builder_.Finish();
}

struct CmdRectRoundedCorners FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdRectRoundedCornersBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CmdRectRoundedCornersTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_P_MIN = 4,
    VT_P_MAX = 6,
    VT_COL = 8,
    VT_ROUNDING_TOP_LEFT = 10,
    VT_ROUNDING_TOP_RIGHT = 12,
    VT_ROUNDING_BOTTOM_RIGHT = 14,
    VT_ROUNDING_BOTTOM_LEFT = 16,
    VT_THICKNESS = 18
  };
  const ImZeroFB::SingleVec2 *p_min() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_P_MIN);
  }
  const ImZeroFB::SingleVec2 *p_max() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_P_MAX);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  float rounding_top_left() const {
    return GetField<float>(VT_ROUNDING_TOP_LEFT, 0.0f);
  }
  float rounding_top_right() const {
    return GetField<float>(VT_ROUNDING_TOP_RIGHT, 0.0f);
  }
  float rounding_bottom_right() const {
    return GetField<float>(VT_ROUNDING_BOTTOM_RIGHT, 0.0f);
  }
  float rounding_bottom_left() const {
    return GetField<float>(VT_ROUNDING_BOTTOM_LEFT, 0.0f);
  }
  float thickness() const {
    return GetField<float>(VT_THICKNESS, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_P_MIN, 4) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_P_MAX, 4) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           VerifyField<float>(verifier, VT_ROUNDING_TOP_LEFT, 4) &&
           VerifyField<float>(verifier, VT_ROUNDING_TOP_RIGHT, 4) &&
           VerifyField<float>(verifier, VT_ROUNDING_BOTTOM_RIGHT, 4) &&
           VerifyField<float>(verifier, VT_ROUNDING_BOTTOM_LEFT, 4) &&
           VerifyField<float>(verifier, VT_THICKNESS, 4) &&
           verifier.EndTable();
  }
};

struct CmdRectRoundedCornersBuilder {
  typedef CmdRectRoundedCorners Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_p_min(const ImZeroFB::SingleVec2 *p_min) {
    fbb_.AddStruct(CmdRectRoundedCorners::VT_P_MIN, p_min);
  }
  void add_p_max(const ImZeroFB::SingleVec2 *p_max) {
    fbb_.AddStruct(CmdRectRoundedCorners::VT_P_MAX, p_max);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdRectRoundedCorners::VT_COL, col, 0);
  }
  void add_rounding_top_left(float rounding_top_left) {
    fbb_.AddElement<float>(CmdRectRoundedCorners::VT_ROUNDING_TOP_LEFT, rounding_top_left, 0.0f);
  }
  void add_rounding_top_right(float rounding_top_right) {
    fbb_.AddElement<float>(CmdRectRoundedCorners::VT_ROUNDING_TOP_RIGHT, rounding_top_right, 0.0f);
  }
  void add_rounding_bottom_right(float rounding_bottom_right) {
    fbb_.AddElement<float>(CmdRectRoundedCorners::VT_ROUNDING_BOTTOM_RIGHT, rounding_bottom_right, 0.0f);
  }
  void add_rounding_bottom_left(float rounding_bottom_left) {
    fbb_.AddElement<float>(CmdRectRoundedCorners::VT_ROUNDING_BOTTOM_LEFT, rounding_bottom_left, 0.0f);
  }
  void add_thickness(float thickness) {
    fbb_.AddElement<float>(CmdRectRoundedCorners::VT_THICKNESS, thickness, 0.0f);
  }
  explicit CmdRectRoundedCornersBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdRectRoundedCorners> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdRectRoundedCorners>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdRectRoundedCorners> CreateCmdRectRoundedCorners(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const ImZeroFB::SingleVec2 *p_min = nullptr,
    const ImZeroFB::SingleVec2 *p_max = nullptr,
    uint32_t col = 0,
    float rounding_top_left = 0.0f,
    float rounding_top_right = 0.0f,
    float rounding_bottom_right = 0.0f,
    float rounding_bottom_left = 0.0f,
    float thickness = 0.0f) {
  CmdRectRoundedCornersBuilder builder_(_fbb);
  builder_.add_thickness(thickness);
  builder_.add_rounding_bottom_left(rounding_bottom_left);
  builder_.add_rounding_bottom_right(rounding_bottom_right);
  builder_.add_rounding_top_right(rounding_top_right);
  builder_.add_rounding_top_left(rounding_top_left);
  builder_.add_col(col);
  builder_.add_p_max(p_max);
  builder_.add_p_min(p_min);
  return builder_.Finish();
}

struct CmdRectRoundedFilled FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdRectRoundedFilledBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CmdRectRoundedFilledTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_P_MIN = 4,
    VT_P_MAX = 6,
    VT_COL = 8,
    VT_ROUNDING = 10
  };
  const ImZeroFB::SingleVec2 *p_min() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_P_MIN);
  }
  const ImZeroFB::SingleVec2 *p_max() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_P_MAX);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  float rounding() const {
    return GetField<float>(VT_ROUNDING, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_P_MIN, 4) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_P_MAX, 4) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           VerifyField<float>(verifier, VT_ROUNDING, 4) &&
           verifier.EndTable();
  }
};

struct CmdRectRoundedFilledBuilder {
  typedef CmdRectRoundedFilled Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_p_min(const ImZeroFB::SingleVec2 *p_min) {
    fbb_.AddStruct(CmdRectRoundedFilled::VT_P_MIN, p_min);
  }
  void add_p_max(const ImZeroFB::SingleVec2 *p_max) {
    fbb_.AddStruct(CmdRectRoundedFilled::VT_P_MAX, p_max);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdRectRoundedFilled::VT_COL, col, 0);
  }
  void add_rounding(float rounding) {
    fbb_.AddElement<float>(CmdRectRoundedFilled::VT_ROUNDING, rounding, 0.0f);
  }
  explicit CmdRectRoundedFilledBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdRectRoundedFilled> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdRectRoundedFilled>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdRectRoundedFilled> CreateCmdRectRoundedFilled(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const ImZeroFB::SingleVec2 *p_min = nullptr,
    const ImZeroFB::SingleVec2 *p_max = nullptr,
    uint32_t col = 0,
    float rounding = 0.0f) {
  CmdRectRoundedFilledBuilder builder_(_fbb);
  builder_.add_rounding(rounding);
  builder_.add_col(col);
  builder_.add_p_max(p_max);
  builder_.add_p_min(p_min);
  return builder_.Finish();
}

struct CmdRectRoundedCornersFilled FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdRectRoundedCornersFilledBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CmdRectRoundedCornersFilledTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_P_MIN = 4,
    VT_P_MAX = 6,
    VT_COL = 8,
    VT_ROUNDING_TOP_LEFT = 10,
    VT_ROUNDING_TOP_RIGHT = 12,
    VT_ROUNDING_BOTTOM_RIGHT = 14,
    VT_ROUNDING_BOTTOM_LEFT = 16
  };
  const ImZeroFB::SingleVec2 *p_min() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_P_MIN);
  }
  const ImZeroFB::SingleVec2 *p_max() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_P_MAX);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  float rounding_top_left() const {
    return GetField<float>(VT_ROUNDING_TOP_LEFT, 0.0f);
  }
  float rounding_top_right() const {
    return GetField<float>(VT_ROUNDING_TOP_RIGHT, 0.0f);
  }
  float rounding_bottom_right() const {
    return GetField<float>(VT_ROUNDING_BOTTOM_RIGHT, 0.0f);
  }
  float rounding_bottom_left() const {
    return GetField<float>(VT_ROUNDING_BOTTOM_LEFT, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_P_MIN, 4) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_P_MAX, 4) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           VerifyField<float>(verifier, VT_ROUNDING_TOP_LEFT, 4) &&
           VerifyField<float>(verifier, VT_ROUNDING_TOP_RIGHT, 4) &&
           VerifyField<float>(verifier, VT_ROUNDING_BOTTOM_RIGHT, 4) &&
           VerifyField<float>(verifier, VT_ROUNDING_BOTTOM_LEFT, 4) &&
           verifier.EndTable();
  }
};

struct CmdRectRoundedCornersFilledBuilder {
  typedef CmdRectRoundedCornersFilled Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_p_min(const ImZeroFB::SingleVec2 *p_min) {
    fbb_.AddStruct(CmdRectRoundedCornersFilled::VT_P_MIN, p_min);
  }
  void add_p_max(const ImZeroFB::SingleVec2 *p_max) {
    fbb_.AddStruct(CmdRectRoundedCornersFilled::VT_P_MAX, p_max);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdRectRoundedCornersFilled::VT_COL, col, 0);
  }
  void add_rounding_top_left(float rounding_top_left) {
    fbb_.AddElement<float>(CmdRectRoundedCornersFilled::VT_ROUNDING_TOP_LEFT, rounding_top_left, 0.0f);
  }
  void add_rounding_top_right(float rounding_top_right) {
    fbb_.AddElement<float>(CmdRectRoundedCornersFilled::VT_ROUNDING_TOP_RIGHT, rounding_top_right, 0.0f);
  }
  void add_rounding_bottom_right(float rounding_bottom_right) {
    fbb_.AddElement<float>(CmdRectRoundedCornersFilled::VT_ROUNDING_BOTTOM_RIGHT, rounding_bottom_right, 0.0f);
  }
  void add_rounding_bottom_left(float rounding_bottom_left) {
    fbb_.AddElement<float>(CmdRectRoundedCornersFilled::VT_ROUNDING_BOTTOM_LEFT, rounding_bottom_left, 0.0f);
  }
  explicit CmdRectRoundedCornersFilledBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdRectRoundedCornersFilled> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdRectRoundedCornersFilled>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdRectRoundedCornersFilled> CreateCmdRectRoundedCornersFilled(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const ImZeroFB::SingleVec2 *p_min = nullptr,
    const ImZeroFB::SingleVec2 *p_max = nullptr,
    uint32_t col = 0,
    float rounding_top_left = 0.0f,
    float rounding_top_right = 0.0f,
    float rounding_bottom_right = 0.0f,
    float rounding_bottom_left = 0.0f) {
  CmdRectRoundedCornersFilledBuilder builder_(_fbb);
  builder_.add_rounding_bottom_left(rounding_bottom_left);
  builder_.add_rounding_bottom_right(rounding_bottom_right);
  builder_.add_rounding_top_right(rounding_top_right);
  builder_.add_rounding_top_left(rounding_top_left);
  builder_.add_col(col);
  builder_.add_p_max(p_max);
  builder_.add_p_min(p_min);
  return builder_.Finish();
}

struct CmdQuad FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdQuadBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CmdQuadTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_P1 = 4,
    VT_P2 = 6,
    VT_P3 = 8,
    VT_P4 = 10,
    VT_COL = 12,
    VT_THICKNESS = 14
  };
  const ImZeroFB::SingleVec2 *p1() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_P1);
  }
  const ImZeroFB::SingleVec2 *p2() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_P2);
  }
  const ImZeroFB::SingleVec2 *p3() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_P3);
  }
  const ImZeroFB::SingleVec2 *p4() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_P4);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  float thickness() const {
    return GetField<float>(VT_THICKNESS, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_P1, 4) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_P2, 4) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_P3, 4) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_P4, 4) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           VerifyField<float>(verifier, VT_THICKNESS, 4) &&
           verifier.EndTable();
  }
};

struct CmdQuadBuilder {
  typedef CmdQuad Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_p1(const ImZeroFB::SingleVec2 *p1) {
    fbb_.AddStruct(CmdQuad::VT_P1, p1);
  }
  void add_p2(const ImZeroFB::SingleVec2 *p2) {
    fbb_.AddStruct(CmdQuad::VT_P2, p2);
  }
  void add_p3(const ImZeroFB::SingleVec2 *p3) {
    fbb_.AddStruct(CmdQuad::VT_P3, p3);
  }
  void add_p4(const ImZeroFB::SingleVec2 *p4) {
    fbb_.AddStruct(CmdQuad::VT_P4, p4);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdQuad::VT_COL, col, 0);
  }
  void add_thickness(float thickness) {
    fbb_.AddElement<float>(CmdQuad::VT_THICKNESS, thickness, 0.0f);
  }
  explicit CmdQuadBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdQuad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdQuad>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdQuad> CreateCmdQuad(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const ImZeroFB::SingleVec2 *p1 = nullptr,
    const ImZeroFB::SingleVec2 *p2 = nullptr,
    const ImZeroFB::SingleVec2 *p3 = nullptr,
    const ImZeroFB::SingleVec2 *p4 = nullptr,
    uint32_t col = 0,
    float thickness = 0.0f) {
  CmdQuadBuilder builder_(_fbb);
  builder_.add_thickness(thickness);
  builder_.add_col(col);
  builder_.add_p4(p4);
  builder_.add_p3(p3);
  builder_.add_p2(p2);
  builder_.add_p1(p1);
  return builder_.Finish();
}

struct CmdQuadFilled FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdQuadFilledBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CmdQuadFilledTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_P1 = 4,
    VT_P2 = 6,
    VT_P3 = 8,
    VT_P4 = 10,
    VT_COL = 12
  };
  const ImZeroFB::SingleVec2 *p1() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_P1);
  }
  const ImZeroFB::SingleVec2 *p2() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_P2);
  }
  const ImZeroFB::SingleVec2 *p3() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_P3);
  }
  const ImZeroFB::SingleVec2 *p4() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_P4);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_P1, 4) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_P2, 4) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_P3, 4) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_P4, 4) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           verifier.EndTable();
  }
};

struct CmdQuadFilledBuilder {
  typedef CmdQuadFilled Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_p1(const ImZeroFB::SingleVec2 *p1) {
    fbb_.AddStruct(CmdQuadFilled::VT_P1, p1);
  }
  void add_p2(const ImZeroFB::SingleVec2 *p2) {
    fbb_.AddStruct(CmdQuadFilled::VT_P2, p2);
  }
  void add_p3(const ImZeroFB::SingleVec2 *p3) {
    fbb_.AddStruct(CmdQuadFilled::VT_P3, p3);
  }
  void add_p4(const ImZeroFB::SingleVec2 *p4) {
    fbb_.AddStruct(CmdQuadFilled::VT_P4, p4);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdQuadFilled::VT_COL, col, 0);
  }
  explicit CmdQuadFilledBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdQuadFilled> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdQuadFilled>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdQuadFilled> CreateCmdQuadFilled(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const ImZeroFB::SingleVec2 *p1 = nullptr,
    const ImZeroFB::SingleVec2 *p2 = nullptr,
    const ImZeroFB::SingleVec2 *p3 = nullptr,
    const ImZeroFB::SingleVec2 *p4 = nullptr,
    uint32_t col = 0) {
  CmdQuadFilledBuilder builder_(_fbb);
  builder_.add_col(col);
  builder_.add_p4(p4);
  builder_.add_p3(p3);
  builder_.add_p2(p2);
  builder_.add_p1(p1);
  return builder_.Finish();
}

struct CmdTriangle FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdTriangleBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CmdTriangleTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_P1 = 4,
    VT_P2 = 6,
    VT_P3 = 8,
    VT_COL = 10,
    VT_THICKNESS = 12
  };
  const ImZeroFB::SingleVec2 *p1() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_P1);
  }
  const ImZeroFB::SingleVec2 *p2() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_P2);
  }
  const ImZeroFB::SingleVec2 *p3() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_P3);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  float thickness() const {
    return GetField<float>(VT_THICKNESS, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_P1, 4) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_P2, 4) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_P3, 4) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           VerifyField<float>(verifier, VT_THICKNESS, 4) &&
           verifier.EndTable();
  }
};

struct CmdTriangleBuilder {
  typedef CmdTriangle Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_p1(const ImZeroFB::SingleVec2 *p1) {
    fbb_.AddStruct(CmdTriangle::VT_P1, p1);
  }
  void add_p2(const ImZeroFB::SingleVec2 *p2) {
    fbb_.AddStruct(CmdTriangle::VT_P2, p2);
  }
  void add_p3(const ImZeroFB::SingleVec2 *p3) {
    fbb_.AddStruct(CmdTriangle::VT_P3, p3);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdTriangle::VT_COL, col, 0);
  }
  void add_thickness(float thickness) {
    fbb_.AddElement<float>(CmdTriangle::VT_THICKNESS, thickness, 0.0f);
  }
  explicit CmdTriangleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdTriangle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdTriangle>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdTriangle> CreateCmdTriangle(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const ImZeroFB::SingleVec2 *p1 = nullptr,
    const ImZeroFB::SingleVec2 *p2 = nullptr,
    const ImZeroFB::SingleVec2 *p3 = nullptr,
    uint32_t col = 0,
    float thickness = 0.0f) {
  CmdTriangleBuilder builder_(_fbb);
  builder_.add_thickness(thickness);
  builder_.add_col(col);
  builder_.add_p3(p3);
  builder_.add_p2(p2);
  builder_.add_p1(p1);
  return builder_.Finish();
}

struct CmdTriangleFilled FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdTriangleFilledBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CmdTriangleFilledTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_P1 = 4,
    VT_P2 = 6,
    VT_P3 = 8,
    VT_COL = 10
  };
  const ImZeroFB::SingleVec2 *p1() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_P1);
  }
  const ImZeroFB::SingleVec2 *p2() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_P2);
  }
  const ImZeroFB::SingleVec2 *p3() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_P3);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_P1, 4) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_P2, 4) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_P3, 4) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           verifier.EndTable();
  }
};

struct CmdTriangleFilledBuilder {
  typedef CmdTriangleFilled Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_p1(const ImZeroFB::SingleVec2 *p1) {
    fbb_.AddStruct(CmdTriangleFilled::VT_P1, p1);
  }
  void add_p2(const ImZeroFB::SingleVec2 *p2) {
    fbb_.AddStruct(CmdTriangleFilled::VT_P2, p2);
  }
  void add_p3(const ImZeroFB::SingleVec2 *p3) {
    fbb_.AddStruct(CmdTriangleFilled::VT_P3, p3);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdTriangleFilled::VT_COL, col, 0);
  }
  explicit CmdTriangleFilledBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdTriangleFilled> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdTriangleFilled>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdTriangleFilled> CreateCmdTriangleFilled(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const ImZeroFB::SingleVec2 *p1 = nullptr,
    const ImZeroFB::SingleVec2 *p2 = nullptr,
    const ImZeroFB::SingleVec2 *p3 = nullptr,
    uint32_t col = 0) {
  CmdTriangleFilledBuilder builder_(_fbb);
  builder_.add_col(col);
  builder_.add_p3(p3);
  builder_.add_p2(p2);
  builder_.add_p1(p1);
  return builder_.Finish();
}

struct CmdCircle FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdCircleBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CmdCircleTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CENTER = 4,
    VT_RADIUS = 6,
    VT_COL = 8,
    VT_NUM_SEGMENTS = 10,
    VT_THICKNESS = 12
  };
  const ImZeroFB::SingleVec2 *center() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_CENTER);
  }
  float radius() const {
    return GetField<float>(VT_RADIUS, 0.0f);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  int32_t num_segments() const {
    return GetField<int32_t>(VT_NUM_SEGMENTS, 0);
  }
  float thickness() const {
    return GetField<float>(VT_THICKNESS, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_CENTER, 4) &&
           VerifyField<float>(verifier, VT_RADIUS, 4) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           VerifyField<int32_t>(verifier, VT_NUM_SEGMENTS, 4) &&
           VerifyField<float>(verifier, VT_THICKNESS, 4) &&
           verifier.EndTable();
  }
};

struct CmdCircleBuilder {
  typedef CmdCircle Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_center(const ImZeroFB::SingleVec2 *center) {
    fbb_.AddStruct(CmdCircle::VT_CENTER, center);
  }
  void add_radius(float radius) {
    fbb_.AddElement<float>(CmdCircle::VT_RADIUS, radius, 0.0f);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdCircle::VT_COL, col, 0);
  }
  void add_num_segments(int32_t num_segments) {
    fbb_.AddElement<int32_t>(CmdCircle::VT_NUM_SEGMENTS, num_segments, 0);
  }
  void add_thickness(float thickness) {
    fbb_.AddElement<float>(CmdCircle::VT_THICKNESS, thickness, 0.0f);
  }
  explicit CmdCircleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdCircle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdCircle>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdCircle> CreateCmdCircle(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const ImZeroFB::SingleVec2 *center = nullptr,
    float radius = 0.0f,
    uint32_t col = 0,
    int32_t num_segments = 0,
    float thickness = 0.0f) {
  CmdCircleBuilder builder_(_fbb);
  builder_.add_thickness(thickness);
  builder_.add_num_segments(num_segments);
  builder_.add_col(col);
  builder_.add_radius(radius);
  builder_.add_center(center);
  return builder_.Finish();
}

struct CmdCircleFilled FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdCircleFilledBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CmdCircleFilledTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CENTER = 4,
    VT_RADIUS = 6,
    VT_COL = 8,
    VT_NUM_SEGMENTS = 10
  };
  const ImZeroFB::SingleVec2 *center() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_CENTER);
  }
  float radius() const {
    return GetField<float>(VT_RADIUS, 0.0f);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  int32_t num_segments() const {
    return GetField<int32_t>(VT_NUM_SEGMENTS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_CENTER, 4) &&
           VerifyField<float>(verifier, VT_RADIUS, 4) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           VerifyField<int32_t>(verifier, VT_NUM_SEGMENTS, 4) &&
           verifier.EndTable();
  }
};

struct CmdCircleFilledBuilder {
  typedef CmdCircleFilled Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_center(const ImZeroFB::SingleVec2 *center) {
    fbb_.AddStruct(CmdCircleFilled::VT_CENTER, center);
  }
  void add_radius(float radius) {
    fbb_.AddElement<float>(CmdCircleFilled::VT_RADIUS, radius, 0.0f);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdCircleFilled::VT_COL, col, 0);
  }
  void add_num_segments(int32_t num_segments) {
    fbb_.AddElement<int32_t>(CmdCircleFilled::VT_NUM_SEGMENTS, num_segments, 0);
  }
  explicit CmdCircleFilledBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdCircleFilled> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdCircleFilled>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdCircleFilled> CreateCmdCircleFilled(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const ImZeroFB::SingleVec2 *center = nullptr,
    float radius = 0.0f,
    uint32_t col = 0,
    int32_t num_segments = 0) {
  CmdCircleFilledBuilder builder_(_fbb);
  builder_.add_num_segments(num_segments);
  builder_.add_col(col);
  builder_.add_radius(radius);
  builder_.add_center(center);
  return builder_.Finish();
}

struct CmdNgon FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdNgonBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CmdNgonTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CENTER = 4,
    VT_RADIUS = 6,
    VT_COL = 8,
    VT_NUM_SEGMENTS = 10,
    VT_THICKNESS = 12
  };
  const ImZeroFB::SingleVec2 *center() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_CENTER);
  }
  float radius() const {
    return GetField<float>(VT_RADIUS, 0.0f);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  int32_t num_segments() const {
    return GetField<int32_t>(VT_NUM_SEGMENTS, 0);
  }
  float thickness() const {
    return GetField<float>(VT_THICKNESS, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_CENTER, 4) &&
           VerifyField<float>(verifier, VT_RADIUS, 4) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           VerifyField<int32_t>(verifier, VT_NUM_SEGMENTS, 4) &&
           VerifyField<float>(verifier, VT_THICKNESS, 4) &&
           verifier.EndTable();
  }
};

struct CmdNgonBuilder {
  typedef CmdNgon Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_center(const ImZeroFB::SingleVec2 *center) {
    fbb_.AddStruct(CmdNgon::VT_CENTER, center);
  }
  void add_radius(float radius) {
    fbb_.AddElement<float>(CmdNgon::VT_RADIUS, radius, 0.0f);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdNgon::VT_COL, col, 0);
  }
  void add_num_segments(int32_t num_segments) {
    fbb_.AddElement<int32_t>(CmdNgon::VT_NUM_SEGMENTS, num_segments, 0);
  }
  void add_thickness(float thickness) {
    fbb_.AddElement<float>(CmdNgon::VT_THICKNESS, thickness, 0.0f);
  }
  explicit CmdNgonBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdNgon> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdNgon>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdNgon> CreateCmdNgon(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const ImZeroFB::SingleVec2 *center = nullptr,
    float radius = 0.0f,
    uint32_t col = 0,
    int32_t num_segments = 0,
    float thickness = 0.0f) {
  CmdNgonBuilder builder_(_fbb);
  builder_.add_thickness(thickness);
  builder_.add_num_segments(num_segments);
  builder_.add_col(col);
  builder_.add_radius(radius);
  builder_.add_center(center);
  return builder_.Finish();
}

struct CmdNgonFilled FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdNgonFilledBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CmdNgonFilledTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CENTER = 4,
    VT_RADIUS = 6,
    VT_COL = 8,
    VT_NUM_SEGMENTS = 10
  };
  const ImZeroFB::SingleVec2 *center() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_CENTER);
  }
  float radius() const {
    return GetField<float>(VT_RADIUS, 0.0f);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  int32_t num_segments() const {
    return GetField<int32_t>(VT_NUM_SEGMENTS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_CENTER, 4) &&
           VerifyField<float>(verifier, VT_RADIUS, 4) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           VerifyField<int32_t>(verifier, VT_NUM_SEGMENTS, 4) &&
           verifier.EndTable();
  }
};

struct CmdNgonFilledBuilder {
  typedef CmdNgonFilled Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_center(const ImZeroFB::SingleVec2 *center) {
    fbb_.AddStruct(CmdNgonFilled::VT_CENTER, center);
  }
  void add_radius(float radius) {
    fbb_.AddElement<float>(CmdNgonFilled::VT_RADIUS, radius, 0.0f);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdNgonFilled::VT_COL, col, 0);
  }
  void add_num_segments(int32_t num_segments) {
    fbb_.AddElement<int32_t>(CmdNgonFilled::VT_NUM_SEGMENTS, num_segments, 0);
  }
  explicit CmdNgonFilledBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdNgonFilled> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdNgonFilled>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdNgonFilled> CreateCmdNgonFilled(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const ImZeroFB::SingleVec2 *center = nullptr,
    float radius = 0.0f,
    uint32_t col = 0,
    int32_t num_segments = 0) {
  CmdNgonFilledBuilder builder_(_fbb);
  builder_.add_num_segments(num_segments);
  builder_.add_col(col);
  builder_.add_radius(radius);
  builder_.add_center(center);
  return builder_.Finish();
}

struct CmdEllipse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdEllipseBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CmdEllipseTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CENTER = 4,
    VT_RADIUS = 6,
    VT_COL = 8,
    VT_ROT = 10,
    VT_NUM_SEGMENTS = 12,
    VT_THICKNESS = 14
  };
  const ImZeroFB::SingleVec2 *center() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_CENTER);
  }
  const ImZeroFB::SingleVec2 *radius() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_RADIUS);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  float rot() const {
    return GetField<float>(VT_ROT, 0.0f);
  }
  int32_t num_segments() const {
    return GetField<int32_t>(VT_NUM_SEGMENTS, 0);
  }
  float thickness() const {
    return GetField<float>(VT_THICKNESS, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_CENTER, 4) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_RADIUS, 4) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           VerifyField<float>(verifier, VT_ROT, 4) &&
           VerifyField<int32_t>(verifier, VT_NUM_SEGMENTS, 4) &&
           VerifyField<float>(verifier, VT_THICKNESS, 4) &&
           verifier.EndTable();
  }
};

struct CmdEllipseBuilder {
  typedef CmdEllipse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_center(const ImZeroFB::SingleVec2 *center) {
    fbb_.AddStruct(CmdEllipse::VT_CENTER, center);
  }
  void add_radius(const ImZeroFB::SingleVec2 *radius) {
    fbb_.AddStruct(CmdEllipse::VT_RADIUS, radius);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdEllipse::VT_COL, col, 0);
  }
  void add_rot(float rot) {
    fbb_.AddElement<float>(CmdEllipse::VT_ROT, rot, 0.0f);
  }
  void add_num_segments(int32_t num_segments) {
    fbb_.AddElement<int32_t>(CmdEllipse::VT_NUM_SEGMENTS, num_segments, 0);
  }
  void add_thickness(float thickness) {
    fbb_.AddElement<float>(CmdEllipse::VT_THICKNESS, thickness, 0.0f);
  }
  explicit CmdEllipseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdEllipse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdEllipse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdEllipse> CreateCmdEllipse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const ImZeroFB::SingleVec2 *center = nullptr,
    const ImZeroFB::SingleVec2 *radius = nullptr,
    uint32_t col = 0,
    float rot = 0.0f,
    int32_t num_segments = 0,
    float thickness = 0.0f) {
  CmdEllipseBuilder builder_(_fbb);
  builder_.add_thickness(thickness);
  builder_.add_num_segments(num_segments);
  builder_.add_rot(rot);
  builder_.add_col(col);
  builder_.add_radius(radius);
  builder_.add_center(center);
  return builder_.Finish();
}

struct CmdEllipseFilled FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdEllipseFilledBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CmdEllipseFilledTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CENTER = 4,
    VT_RADIUS = 6,
    VT_COL = 8,
    VT_ROT = 10,
    VT_NUM_SEGMENTS = 12
  };
  const ImZeroFB::SingleVec2 *center() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_CENTER);
  }
  const ImZeroFB::SingleVec2 *radius() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_RADIUS);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  float rot() const {
    return GetField<float>(VT_ROT, 0.0f);
  }
  int32_t num_segments() const {
    return GetField<int32_t>(VT_NUM_SEGMENTS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_CENTER, 4) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_RADIUS, 4) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           VerifyField<float>(verifier, VT_ROT, 4) &&
           VerifyField<int32_t>(verifier, VT_NUM_SEGMENTS, 4) &&
           verifier.EndTable();
  }
};

struct CmdEllipseFilledBuilder {
  typedef CmdEllipseFilled Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_center(const ImZeroFB::SingleVec2 *center) {
    fbb_.AddStruct(CmdEllipseFilled::VT_CENTER, center);
  }
  void add_radius(const ImZeroFB::SingleVec2 *radius) {
    fbb_.AddStruct(CmdEllipseFilled::VT_RADIUS, radius);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdEllipseFilled::VT_COL, col, 0);
  }
  void add_rot(float rot) {
    fbb_.AddElement<float>(CmdEllipseFilled::VT_ROT, rot, 0.0f);
  }
  void add_num_segments(int32_t num_segments) {
    fbb_.AddElement<int32_t>(CmdEllipseFilled::VT_NUM_SEGMENTS, num_segments, 0);
  }
  explicit CmdEllipseFilledBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdEllipseFilled> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdEllipseFilled>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdEllipseFilled> CreateCmdEllipseFilled(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const ImZeroFB::SingleVec2 *center = nullptr,
    const ImZeroFB::SingleVec2 *radius = nullptr,
    uint32_t col = 0,
    float rot = 0.0f,
    int32_t num_segments = 0) {
  CmdEllipseFilledBuilder builder_(_fbb);
  builder_.add_num_segments(num_segments);
  builder_.add_rot(rot);
  builder_.add_col(col);
  builder_.add_radius(radius);
  builder_.add_center(center);
  return builder_.Finish();
}

struct CmdBezierCubic FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdBezierCubicBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CmdBezierCubicTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_P1 = 4,
    VT_P2 = 6,
    VT_P3 = 8,
    VT_P4 = 10,
    VT_COL = 12,
    VT_THICKNESS = 14,
    VT_NUM_SEGMENTS = 16
  };
  const ImZeroFB::SingleVec2 *p1() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_P1);
  }
  const ImZeroFB::SingleVec2 *p2() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_P2);
  }
  const ImZeroFB::SingleVec2 *p3() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_P3);
  }
  const ImZeroFB::SingleVec2 *p4() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_P4);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  float thickness() const {
    return GetField<float>(VT_THICKNESS, 0.0f);
  }
  int32_t num_segments() const {
    return GetField<int32_t>(VT_NUM_SEGMENTS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_P1, 4) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_P2, 4) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_P3, 4) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_P4, 4) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           VerifyField<float>(verifier, VT_THICKNESS, 4) &&
           VerifyField<int32_t>(verifier, VT_NUM_SEGMENTS, 4) &&
           verifier.EndTable();
  }
};

struct CmdBezierCubicBuilder {
  typedef CmdBezierCubic Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_p1(const ImZeroFB::SingleVec2 *p1) {
    fbb_.AddStruct(CmdBezierCubic::VT_P1, p1);
  }
  void add_p2(const ImZeroFB::SingleVec2 *p2) {
    fbb_.AddStruct(CmdBezierCubic::VT_P2, p2);
  }
  void add_p3(const ImZeroFB::SingleVec2 *p3) {
    fbb_.AddStruct(CmdBezierCubic::VT_P3, p3);
  }
  void add_p4(const ImZeroFB::SingleVec2 *p4) {
    fbb_.AddStruct(CmdBezierCubic::VT_P4, p4);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdBezierCubic::VT_COL, col, 0);
  }
  void add_thickness(float thickness) {
    fbb_.AddElement<float>(CmdBezierCubic::VT_THICKNESS, thickness, 0.0f);
  }
  void add_num_segments(int32_t num_segments) {
    fbb_.AddElement<int32_t>(CmdBezierCubic::VT_NUM_SEGMENTS, num_segments, 0);
  }
  explicit CmdBezierCubicBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdBezierCubic> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdBezierCubic>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdBezierCubic> CreateCmdBezierCubic(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const ImZeroFB::SingleVec2 *p1 = nullptr,
    const ImZeroFB::SingleVec2 *p2 = nullptr,
    const ImZeroFB::SingleVec2 *p3 = nullptr,
    const ImZeroFB::SingleVec2 *p4 = nullptr,
    uint32_t col = 0,
    float thickness = 0.0f,
    int32_t num_segments = 0) {
  CmdBezierCubicBuilder builder_(_fbb);
  builder_.add_num_segments(num_segments);
  builder_.add_thickness(thickness);
  builder_.add_col(col);
  builder_.add_p4(p4);
  builder_.add_p3(p3);
  builder_.add_p2(p2);
  builder_.add_p1(p1);
  return builder_.Finish();
}

struct CmdBezierQuadratic FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdBezierQuadraticBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CmdBezierQuadraticTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_P1 = 4,
    VT_P2 = 6,
    VT_P3 = 8,
    VT_COL = 10,
    VT_THICKNESS = 12,
    VT_NUM_SEGMENTS = 14
  };
  const ImZeroFB::SingleVec2 *p1() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_P1);
  }
  const ImZeroFB::SingleVec2 *p2() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_P2);
  }
  const ImZeroFB::SingleVec2 *p3() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_P3);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  float thickness() const {
    return GetField<float>(VT_THICKNESS, 0.0f);
  }
  int32_t num_segments() const {
    return GetField<int32_t>(VT_NUM_SEGMENTS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_P1, 4) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_P2, 4) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_P3, 4) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           VerifyField<float>(verifier, VT_THICKNESS, 4) &&
           VerifyField<int32_t>(verifier, VT_NUM_SEGMENTS, 4) &&
           verifier.EndTable();
  }
};

struct CmdBezierQuadraticBuilder {
  typedef CmdBezierQuadratic Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_p1(const ImZeroFB::SingleVec2 *p1) {
    fbb_.AddStruct(CmdBezierQuadratic::VT_P1, p1);
  }
  void add_p2(const ImZeroFB::SingleVec2 *p2) {
    fbb_.AddStruct(CmdBezierQuadratic::VT_P2, p2);
  }
  void add_p3(const ImZeroFB::SingleVec2 *p3) {
    fbb_.AddStruct(CmdBezierQuadratic::VT_P3, p3);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdBezierQuadratic::VT_COL, col, 0);
  }
  void add_thickness(float thickness) {
    fbb_.AddElement<float>(CmdBezierQuadratic::VT_THICKNESS, thickness, 0.0f);
  }
  void add_num_segments(int32_t num_segments) {
    fbb_.AddElement<int32_t>(CmdBezierQuadratic::VT_NUM_SEGMENTS, num_segments, 0);
  }
  explicit CmdBezierQuadraticBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdBezierQuadratic> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdBezierQuadratic>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdBezierQuadratic> CreateCmdBezierQuadratic(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const ImZeroFB::SingleVec2 *p1 = nullptr,
    const ImZeroFB::SingleVec2 *p2 = nullptr,
    const ImZeroFB::SingleVec2 *p3 = nullptr,
    uint32_t col = 0,
    float thickness = 0.0f,
    int32_t num_segments = 0) {
  CmdBezierQuadraticBuilder builder_(_fbb);
  builder_.add_num_segments(num_segments);
  builder_.add_thickness(thickness);
  builder_.add_col(col);
  builder_.add_p3(p3);
  builder_.add_p2(p2);
  builder_.add_p1(p1);
  return builder_.Finish();
}

struct CmdImage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdImageBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CmdImageTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USER_TEXTURE_ID = 4,
    VT_P_MIN = 6,
    VT_P_MAX = 8,
    VT_UV_MIN = 10,
    VT_UV_MAX = 12,
    VT_COL = 14
  };
  uint64_t user_texture_id() const {
    return GetField<uint64_t>(VT_USER_TEXTURE_ID, 0);
  }
  const ImZeroFB::SingleVec2 *p_min() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_P_MIN);
  }
  const ImZeroFB::SingleVec2 *p_max() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_P_MAX);
  }
  const ImZeroFB::SingleVec2 *uv_min() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_UV_MIN);
  }
  const ImZeroFB::SingleVec2 *uv_max() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_UV_MAX);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_USER_TEXTURE_ID, 8) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_P_MIN, 4) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_P_MAX, 4) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_UV_MIN, 4) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_UV_MAX, 4) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           verifier.EndTable();
  }
};

struct CmdImageBuilder {
  typedef CmdImage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_user_texture_id(uint64_t user_texture_id) {
    fbb_.AddElement<uint64_t>(CmdImage::VT_USER_TEXTURE_ID, user_texture_id, 0);
  }
  void add_p_min(const ImZeroFB::SingleVec2 *p_min) {
    fbb_.AddStruct(CmdImage::VT_P_MIN, p_min);
  }
  void add_p_max(const ImZeroFB::SingleVec2 *p_max) {
    fbb_.AddStruct(CmdImage::VT_P_MAX, p_max);
  }
  void add_uv_min(const ImZeroFB::SingleVec2 *uv_min) {
    fbb_.AddStruct(CmdImage::VT_UV_MIN, uv_min);
  }
  void add_uv_max(const ImZeroFB::SingleVec2 *uv_max) {
    fbb_.AddStruct(CmdImage::VT_UV_MAX, uv_max);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdImage::VT_COL, col, 0);
  }
  explicit CmdImageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdImage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdImage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdImage> CreateCmdImage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t user_texture_id = 0,
    const ImZeroFB::SingleVec2 *p_min = nullptr,
    const ImZeroFB::SingleVec2 *p_max = nullptr,
    const ImZeroFB::SingleVec2 *uv_min = nullptr,
    const ImZeroFB::SingleVec2 *uv_max = nullptr,
    uint32_t col = 0) {
  CmdImageBuilder builder_(_fbb);
  builder_.add_user_texture_id(user_texture_id);
  builder_.add_col(col);
  builder_.add_uv_max(uv_max);
  builder_.add_uv_min(uv_min);
  builder_.add_p_max(p_max);
  builder_.add_p_min(p_min);
  return builder_.Finish();
}

struct CmdImageQuad FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdImageQuadBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CmdImageQuadTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USER_TEXTURE_ID = 4,
    VT_P1 = 6,
    VT_P2 = 8,
    VT_P3 = 10,
    VT_P4 = 12,
    VT_UV1 = 14,
    VT_UV2 = 16,
    VT_UV3 = 18,
    VT_UV4 = 20,
    VT_COL = 22
  };
  uint64_t user_texture_id() const {
    return GetField<uint64_t>(VT_USER_TEXTURE_ID, 0);
  }
  const ImZeroFB::SingleVec2 *p1() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_P1);
  }
  const ImZeroFB::SingleVec2 *p2() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_P2);
  }
  const ImZeroFB::SingleVec2 *p3() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_P3);
  }
  const ImZeroFB::SingleVec2 *p4() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_P4);
  }
  const ImZeroFB::SingleVec2 *uv1() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_UV1);
  }
  const ImZeroFB::SingleVec2 *uv2() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_UV2);
  }
  const ImZeroFB::SingleVec2 *uv3() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_UV3);
  }
  const ImZeroFB::SingleVec2 *uv4() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_UV4);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_USER_TEXTURE_ID, 8) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_P1, 4) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_P2, 4) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_P3, 4) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_P4, 4) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_UV1, 4) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_UV2, 4) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_UV3, 4) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_UV4, 4) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           verifier.EndTable();
  }
};

struct CmdImageQuadBuilder {
  typedef CmdImageQuad Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_user_texture_id(uint64_t user_texture_id) {
    fbb_.AddElement<uint64_t>(CmdImageQuad::VT_USER_TEXTURE_ID, user_texture_id, 0);
  }
  void add_p1(const ImZeroFB::SingleVec2 *p1) {
    fbb_.AddStruct(CmdImageQuad::VT_P1, p1);
  }
  void add_p2(const ImZeroFB::SingleVec2 *p2) {
    fbb_.AddStruct(CmdImageQuad::VT_P2, p2);
  }
  void add_p3(const ImZeroFB::SingleVec2 *p3) {
    fbb_.AddStruct(CmdImageQuad::VT_P3, p3);
  }
  void add_p4(const ImZeroFB::SingleVec2 *p4) {
    fbb_.AddStruct(CmdImageQuad::VT_P4, p4);
  }
  void add_uv1(const ImZeroFB::SingleVec2 *uv1) {
    fbb_.AddStruct(CmdImageQuad::VT_UV1, uv1);
  }
  void add_uv2(const ImZeroFB::SingleVec2 *uv2) {
    fbb_.AddStruct(CmdImageQuad::VT_UV2, uv2);
  }
  void add_uv3(const ImZeroFB::SingleVec2 *uv3) {
    fbb_.AddStruct(CmdImageQuad::VT_UV3, uv3);
  }
  void add_uv4(const ImZeroFB::SingleVec2 *uv4) {
    fbb_.AddStruct(CmdImageQuad::VT_UV4, uv4);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdImageQuad::VT_COL, col, 0);
  }
  explicit CmdImageQuadBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdImageQuad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdImageQuad>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdImageQuad> CreateCmdImageQuad(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t user_texture_id = 0,
    const ImZeroFB::SingleVec2 *p1 = nullptr,
    const ImZeroFB::SingleVec2 *p2 = nullptr,
    const ImZeroFB::SingleVec2 *p3 = nullptr,
    const ImZeroFB::SingleVec2 *p4 = nullptr,
    const ImZeroFB::SingleVec2 *uv1 = nullptr,
    const ImZeroFB::SingleVec2 *uv2 = nullptr,
    const ImZeroFB::SingleVec2 *uv3 = nullptr,
    const ImZeroFB::SingleVec2 *uv4 = nullptr,
    uint32_t col = 0) {
  CmdImageQuadBuilder builder_(_fbb);
  builder_.add_user_texture_id(user_texture_id);
  builder_.add_col(col);
  builder_.add_uv4(uv4);
  builder_.add_uv3(uv3);
  builder_.add_uv2(uv2);
  builder_.add_uv1(uv1);
  builder_.add_p4(p4);
  builder_.add_p3(p3);
  builder_.add_p2(p2);
  builder_.add_p1(p1);
  return builder_.Finish();
}

struct CmdImageRounded FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdImageRoundedBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CmdImageRoundedTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USER_TEXTURE_ID = 4,
    VT_P_MIN = 6,
    VT_P_MAX = 8,
    VT_UV_MIN = 10,
    VT_UV_MAX = 12,
    VT_COL = 14,
    VT_ROUNDING = 16,
    VT_FLAGS = 18
  };
  uint64_t user_texture_id() const {
    return GetField<uint64_t>(VT_USER_TEXTURE_ID, 0);
  }
  const ImZeroFB::SingleVec2 *p_min() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_P_MIN);
  }
  const ImZeroFB::SingleVec2 *p_max() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_P_MAX);
  }
  const ImZeroFB::SingleVec2 *uv_min() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_UV_MIN);
  }
  const ImZeroFB::SingleVec2 *uv_max() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_UV_MAX);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  float rounding() const {
    return GetField<float>(VT_ROUNDING, 0.0f);
  }
  uint32_t flags() const {
    return GetField<uint32_t>(VT_FLAGS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_USER_TEXTURE_ID, 8) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_P_MIN, 4) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_P_MAX, 4) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_UV_MIN, 4) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_UV_MAX, 4) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           VerifyField<float>(verifier, VT_ROUNDING, 4) &&
           VerifyField<uint32_t>(verifier, VT_FLAGS, 4) &&
           verifier.EndTable();
  }
};

struct CmdImageRoundedBuilder {
  typedef CmdImageRounded Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_user_texture_id(uint64_t user_texture_id) {
    fbb_.AddElement<uint64_t>(CmdImageRounded::VT_USER_TEXTURE_ID, user_texture_id, 0);
  }
  void add_p_min(const ImZeroFB::SingleVec2 *p_min) {
    fbb_.AddStruct(CmdImageRounded::VT_P_MIN, p_min);
  }
  void add_p_max(const ImZeroFB::SingleVec2 *p_max) {
    fbb_.AddStruct(CmdImageRounded::VT_P_MAX, p_max);
  }
  void add_uv_min(const ImZeroFB::SingleVec2 *uv_min) {
    fbb_.AddStruct(CmdImageRounded::VT_UV_MIN, uv_min);
  }
  void add_uv_max(const ImZeroFB::SingleVec2 *uv_max) {
    fbb_.AddStruct(CmdImageRounded::VT_UV_MAX, uv_max);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdImageRounded::VT_COL, col, 0);
  }
  void add_rounding(float rounding) {
    fbb_.AddElement<float>(CmdImageRounded::VT_ROUNDING, rounding, 0.0f);
  }
  void add_flags(uint32_t flags) {
    fbb_.AddElement<uint32_t>(CmdImageRounded::VT_FLAGS, flags, 0);
  }
  explicit CmdImageRoundedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdImageRounded> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdImageRounded>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdImageRounded> CreateCmdImageRounded(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t user_texture_id = 0,
    const ImZeroFB::SingleVec2 *p_min = nullptr,
    const ImZeroFB::SingleVec2 *p_max = nullptr,
    const ImZeroFB::SingleVec2 *uv_min = nullptr,
    const ImZeroFB::SingleVec2 *uv_max = nullptr,
    uint32_t col = 0,
    float rounding = 0.0f,
    uint32_t flags = 0) {
  CmdImageRoundedBuilder builder_(_fbb);
  builder_.add_user_texture_id(user_texture_id);
  builder_.add_flags(flags);
  builder_.add_rounding(rounding);
  builder_.add_col(col);
  builder_.add_uv_max(uv_max);
  builder_.add_uv_min(uv_min);
  builder_.add_p_max(p_max);
  builder_.add_p_min(p_min);
  return builder_.Finish();
}

struct CmdPushClipRect FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdPushClipRectBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CmdPushClipRectTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RECT = 4,
    VT_INTERSECTED_WITH_CURRENT_CLIP_RECT = 6
  };
  const ImZeroFB::SingleVec4 *rect() const {
    return GetStruct<const ImZeroFB::SingleVec4 *>(VT_RECT);
  }
  bool intersected_with_current_clip_rect() const {
    return GetField<uint8_t>(VT_INTERSECTED_WITH_CURRENT_CLIP_RECT, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<ImZeroFB::SingleVec4>(verifier, VT_RECT, 4) &&
           VerifyField<uint8_t>(verifier, VT_INTERSECTED_WITH_CURRENT_CLIP_RECT, 1) &&
           verifier.EndTable();
  }
};

struct CmdPushClipRectBuilder {
  typedef CmdPushClipRect Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_rect(const ImZeroFB::SingleVec4 *rect) {
    fbb_.AddStruct(CmdPushClipRect::VT_RECT, rect);
  }
  void add_intersected_with_current_clip_rect(bool intersected_with_current_clip_rect) {
    fbb_.AddElement<uint8_t>(CmdPushClipRect::VT_INTERSECTED_WITH_CURRENT_CLIP_RECT, static_cast<uint8_t>(intersected_with_current_clip_rect), 0);
  }
  explicit CmdPushClipRectBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdPushClipRect> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdPushClipRect>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdPushClipRect> CreateCmdPushClipRect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const ImZeroFB::SingleVec4 *rect = nullptr,
    bool intersected_with_current_clip_rect = false) {
  CmdPushClipRectBuilder builder_(_fbb);
  builder_.add_rect(rect);
  builder_.add_intersected_with_current_clip_rect(intersected_with_current_clip_rect);
  return builder_.Finish();
}

struct CmdPopClipRect FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdPopClipRectBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CmdPopClipRectTypeTable();
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct CmdPopClipRectBuilder {
  typedef CmdPopClipRect Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit CmdPopClipRectBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdPopClipRect> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdPopClipRect>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdPopClipRect> CreateCmdPopClipRect(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  CmdPopClipRectBuilder builder_(_fbb);
  return builder_.Finish();
}

struct CmdRenderText FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdRenderTextBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CmdRenderTextTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IMFONT = 4,
    VT_SIZE = 6,
    VT_POS = 8,
    VT_COL = 10,
    VT_CLIP_RECT = 12,
    VT_TEXT = 14
  };
  uint64_t imfont() const {
    return GetField<uint64_t>(VT_IMFONT, 0);
  }
  float size() const {
    return GetField<float>(VT_SIZE, 0.0f);
  }
  const ImZeroFB::SingleVec2 *pos() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_POS);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  const ImZeroFB::SingleVec4 *clip_rect() const {
    return GetStruct<const ImZeroFB::SingleVec4 *>(VT_CLIP_RECT);
  }
  const ::flatbuffers::String *text() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TEXT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_IMFONT, 8) &&
           VerifyField<float>(verifier, VT_SIZE, 4) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_POS, 4) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           VerifyField<ImZeroFB::SingleVec4>(verifier, VT_CLIP_RECT, 4) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           verifier.EndTable();
  }
};

struct CmdRenderTextBuilder {
  typedef CmdRenderText Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_imfont(uint64_t imfont) {
    fbb_.AddElement<uint64_t>(CmdRenderText::VT_IMFONT, imfont, 0);
  }
  void add_size(float size) {
    fbb_.AddElement<float>(CmdRenderText::VT_SIZE, size, 0.0f);
  }
  void add_pos(const ImZeroFB::SingleVec2 *pos) {
    fbb_.AddStruct(CmdRenderText::VT_POS, pos);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdRenderText::VT_COL, col, 0);
  }
  void add_clip_rect(const ImZeroFB::SingleVec4 *clip_rect) {
    fbb_.AddStruct(CmdRenderText::VT_CLIP_RECT, clip_rect);
  }
  void add_text(::flatbuffers::Offset<::flatbuffers::String> text) {
    fbb_.AddOffset(CmdRenderText::VT_TEXT, text);
  }
  explicit CmdRenderTextBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdRenderText> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdRenderText>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdRenderText> CreateCmdRenderText(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t imfont = 0,
    float size = 0.0f,
    const ImZeroFB::SingleVec2 *pos = nullptr,
    uint32_t col = 0,
    const ImZeroFB::SingleVec4 *clip_rect = nullptr,
    ::flatbuffers::Offset<::flatbuffers::String> text = 0) {
  CmdRenderTextBuilder builder_(_fbb);
  builder_.add_imfont(imfont);
  builder_.add_text(text);
  builder_.add_clip_rect(clip_rect);
  builder_.add_col(col);
  builder_.add_pos(pos);
  builder_.add_size(size);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CmdRenderText> CreateCmdRenderTextDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t imfont = 0,
    float size = 0.0f,
    const ImZeroFB::SingleVec2 *pos = nullptr,
    uint32_t col = 0,
    const ImZeroFB::SingleVec4 *clip_rect = nullptr,
    const char *text = nullptr) {
  auto text__ = text ? _fbb.CreateString(text) : 0;
  return ImZeroFB::CreateCmdRenderText(
      _fbb,
      imfont,
      size,
      pos,
      col,
      clip_rect,
      text__);
}

struct CmdRenderParagraph FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdRenderParagraphBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CmdRenderParagraphTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IMFONT = 4,
    VT_SIZE = 6,
    VT_POS = 8,
    VT_COL = 10,
    VT_CLIP_RECT = 12,
    VT_TEXT = 14,
    VT_WRAP_WIDTH = 16,
    VT_LETTER_SPACING = 18,
    VT_TEXT_ALIGN = 20,
    VT_TEXT_DIRECTION = 22
  };
  uint64_t imfont() const {
    return GetField<uint64_t>(VT_IMFONT, 0);
  }
  float size() const {
    return GetField<float>(VT_SIZE, 0.0f);
  }
  const ImZeroFB::SingleVec2 *pos() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_POS);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  const ImZeroFB::SingleVec4 *clip_rect() const {
    return GetStruct<const ImZeroFB::SingleVec4 *>(VT_CLIP_RECT);
  }
  const ::flatbuffers::String *text() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TEXT);
  }
  float wrap_width() const {
    return GetField<float>(VT_WRAP_WIDTH, 0.0f);
  }
  float letter_spacing() const {
    return GetField<float>(VT_LETTER_SPACING, 0.0f);
  }
  ImZeroFB::TextAlignFlags text_align() const {
    return static_cast<ImZeroFB::TextAlignFlags>(GetField<uint8_t>(VT_TEXT_ALIGN, 0));
  }
  ImZeroFB::TextDirection text_direction() const {
    return static_cast<ImZeroFB::TextDirection>(GetField<uint8_t>(VT_TEXT_DIRECTION, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_IMFONT, 8) &&
           VerifyField<float>(verifier, VT_SIZE, 4) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_POS, 4) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           VerifyField<ImZeroFB::SingleVec4>(verifier, VT_CLIP_RECT, 4) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           VerifyField<float>(verifier, VT_WRAP_WIDTH, 4) &&
           VerifyField<float>(verifier, VT_LETTER_SPACING, 4) &&
           VerifyField<uint8_t>(verifier, VT_TEXT_ALIGN, 1) &&
           VerifyField<uint8_t>(verifier, VT_TEXT_DIRECTION, 1) &&
           verifier.EndTable();
  }
};

struct CmdRenderParagraphBuilder {
  typedef CmdRenderParagraph Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_imfont(uint64_t imfont) {
    fbb_.AddElement<uint64_t>(CmdRenderParagraph::VT_IMFONT, imfont, 0);
  }
  void add_size(float size) {
    fbb_.AddElement<float>(CmdRenderParagraph::VT_SIZE, size, 0.0f);
  }
  void add_pos(const ImZeroFB::SingleVec2 *pos) {
    fbb_.AddStruct(CmdRenderParagraph::VT_POS, pos);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdRenderParagraph::VT_COL, col, 0);
  }
  void add_clip_rect(const ImZeroFB::SingleVec4 *clip_rect) {
    fbb_.AddStruct(CmdRenderParagraph::VT_CLIP_RECT, clip_rect);
  }
  void add_text(::flatbuffers::Offset<::flatbuffers::String> text) {
    fbb_.AddOffset(CmdRenderParagraph::VT_TEXT, text);
  }
  void add_wrap_width(float wrap_width) {
    fbb_.AddElement<float>(CmdRenderParagraph::VT_WRAP_WIDTH, wrap_width, 0.0f);
  }
  void add_letter_spacing(float letter_spacing) {
    fbb_.AddElement<float>(CmdRenderParagraph::VT_LETTER_SPACING, letter_spacing, 0.0f);
  }
  void add_text_align(ImZeroFB::TextAlignFlags text_align) {
    fbb_.AddElement<uint8_t>(CmdRenderParagraph::VT_TEXT_ALIGN, static_cast<uint8_t>(text_align), 0);
  }
  void add_text_direction(ImZeroFB::TextDirection text_direction) {
    fbb_.AddElement<uint8_t>(CmdRenderParagraph::VT_TEXT_DIRECTION, static_cast<uint8_t>(text_direction), 0);
  }
  explicit CmdRenderParagraphBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdRenderParagraph> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdRenderParagraph>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdRenderParagraph> CreateCmdRenderParagraph(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t imfont = 0,
    float size = 0.0f,
    const ImZeroFB::SingleVec2 *pos = nullptr,
    uint32_t col = 0,
    const ImZeroFB::SingleVec4 *clip_rect = nullptr,
    ::flatbuffers::Offset<::flatbuffers::String> text = 0,
    float wrap_width = 0.0f,
    float letter_spacing = 0.0f,
    ImZeroFB::TextAlignFlags text_align = ImZeroFB::TextAlignFlags_left,
    ImZeroFB::TextDirection text_direction = ImZeroFB::TextDirection_ltr) {
  CmdRenderParagraphBuilder builder_(_fbb);
  builder_.add_imfont(imfont);
  builder_.add_letter_spacing(letter_spacing);
  builder_.add_wrap_width(wrap_width);
  builder_.add_text(text);
  builder_.add_clip_rect(clip_rect);
  builder_.add_col(col);
  builder_.add_pos(pos);
  builder_.add_size(size);
  builder_.add_text_direction(text_direction);
  builder_.add_text_align(text_align);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CmdRenderParagraph> CreateCmdRenderParagraphDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t imfont = 0,
    float size = 0.0f,
    const ImZeroFB::SingleVec2 *pos = nullptr,
    uint32_t col = 0,
    const ImZeroFB::SingleVec4 *clip_rect = nullptr,
    const char *text = nullptr,
    float wrap_width = 0.0f,
    float letter_spacing = 0.0f,
    ImZeroFB::TextAlignFlags text_align = ImZeroFB::TextAlignFlags_left,
    ImZeroFB::TextDirection text_direction = ImZeroFB::TextDirection_ltr) {
  auto text__ = text ? _fbb.CreateString(text) : 0;
  return ImZeroFB::CreateCmdRenderParagraph(
      _fbb,
      imfont,
      size,
      pos,
      col,
      clip_rect,
      text__,
      wrap_width,
      letter_spacing,
      text_align,
      text_direction);
}

struct CmdRenderUnicodeCodepoint FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdRenderUnicodeCodepointBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CmdRenderUnicodeCodepointTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IMFONT = 4,
    VT_SIZE = 6,
    VT_POS = 8,
    VT_COL = 10,
    VT_CLIP_RECT = 12,
    VT_CODEPOINT = 14
  };
  uint64_t imfont() const {
    return GetField<uint64_t>(VT_IMFONT, 0);
  }
  float size() const {
    return GetField<float>(VT_SIZE, 0.0f);
  }
  const ImZeroFB::SingleVec2 *pos() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_POS);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  const ImZeroFB::SingleVec4 *clip_rect() const {
    return GetStruct<const ImZeroFB::SingleVec4 *>(VT_CLIP_RECT);
  }
  uint32_t codepoint() const {
    return GetField<uint32_t>(VT_CODEPOINT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_IMFONT, 8) &&
           VerifyField<float>(verifier, VT_SIZE, 4) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_POS, 4) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           VerifyField<ImZeroFB::SingleVec4>(verifier, VT_CLIP_RECT, 4) &&
           VerifyField<uint32_t>(verifier, VT_CODEPOINT, 4) &&
           verifier.EndTable();
  }
};

struct CmdRenderUnicodeCodepointBuilder {
  typedef CmdRenderUnicodeCodepoint Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_imfont(uint64_t imfont) {
    fbb_.AddElement<uint64_t>(CmdRenderUnicodeCodepoint::VT_IMFONT, imfont, 0);
  }
  void add_size(float size) {
    fbb_.AddElement<float>(CmdRenderUnicodeCodepoint::VT_SIZE, size, 0.0f);
  }
  void add_pos(const ImZeroFB::SingleVec2 *pos) {
    fbb_.AddStruct(CmdRenderUnicodeCodepoint::VT_POS, pos);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdRenderUnicodeCodepoint::VT_COL, col, 0);
  }
  void add_clip_rect(const ImZeroFB::SingleVec4 *clip_rect) {
    fbb_.AddStruct(CmdRenderUnicodeCodepoint::VT_CLIP_RECT, clip_rect);
  }
  void add_codepoint(uint32_t codepoint) {
    fbb_.AddElement<uint32_t>(CmdRenderUnicodeCodepoint::VT_CODEPOINT, codepoint, 0);
  }
  explicit CmdRenderUnicodeCodepointBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdRenderUnicodeCodepoint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdRenderUnicodeCodepoint>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdRenderUnicodeCodepoint> CreateCmdRenderUnicodeCodepoint(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t imfont = 0,
    float size = 0.0f,
    const ImZeroFB::SingleVec2 *pos = nullptr,
    uint32_t col = 0,
    const ImZeroFB::SingleVec4 *clip_rect = nullptr,
    uint32_t codepoint = 0) {
  CmdRenderUnicodeCodepointBuilder builder_(_fbb);
  builder_.add_imfont(imfont);
  builder_.add_codepoint(codepoint);
  builder_.add_clip_rect(clip_rect);
  builder_.add_col(col);
  builder_.add_pos(pos);
  builder_.add_size(size);
  return builder_.Finish();
}

struct CmdTranslation FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdTranslationBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CmdTranslationTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TRANSLATION = 4
  };
  const ImZeroFB::SingleVec2 *translation() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_TRANSLATION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_TRANSLATION, 4) &&
           verifier.EndTable();
  }
};

struct CmdTranslationBuilder {
  typedef CmdTranslation Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_translation(const ImZeroFB::SingleVec2 *translation) {
    fbb_.AddStruct(CmdTranslation::VT_TRANSLATION, translation);
  }
  explicit CmdTranslationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdTranslation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdTranslation>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdTranslation> CreateCmdTranslation(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const ImZeroFB::SingleVec2 *translation = nullptr) {
  CmdTranslationBuilder builder_(_fbb);
  builder_.add_translation(translation);
  return builder_.Finish();
}

struct PopTranslation FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PopTranslationBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PopTranslationTypeTable();
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct PopTranslationBuilder {
  typedef PopTranslation Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit PopTranslationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PopTranslation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PopTranslation>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PopTranslation> CreatePopTranslation(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  PopTranslationBuilder builder_(_fbb);
  return builder_.Finish();
}

struct CmdPushRotation FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdPushRotationBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CmdPushRotationTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COS_ALPHA = 4,
    VT_SIN_ALPHA = 6
  };
  float cos_alpha() const {
    return GetField<float>(VT_COS_ALPHA, 0.0f);
  }
  float sin_alpha() const {
    return GetField<float>(VT_SIN_ALPHA, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_COS_ALPHA, 4) &&
           VerifyField<float>(verifier, VT_SIN_ALPHA, 4) &&
           verifier.EndTable();
  }
};

struct CmdPushRotationBuilder {
  typedef CmdPushRotation Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_cos_alpha(float cos_alpha) {
    fbb_.AddElement<float>(CmdPushRotation::VT_COS_ALPHA, cos_alpha, 0.0f);
  }
  void add_sin_alpha(float sin_alpha) {
    fbb_.AddElement<float>(CmdPushRotation::VT_SIN_ALPHA, sin_alpha, 0.0f);
  }
  explicit CmdPushRotationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdPushRotation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdPushRotation>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdPushRotation> CreateCmdPushRotation(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float cos_alpha = 0.0f,
    float sin_alpha = 0.0f) {
  CmdPushRotationBuilder builder_(_fbb);
  builder_.add_sin_alpha(sin_alpha);
  builder_.add_cos_alpha(cos_alpha);
  return builder_.Finish();
}

struct CmdPopRotation FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdPopRotationBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CmdPopRotationTypeTable();
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct CmdPopRotationBuilder {
  typedef CmdPopRotation Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit CmdPopRotationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdPopRotation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdPopRotation>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdPopRotation> CreateCmdPopRotation(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  CmdPopRotationBuilder builder_(_fbb);
  return builder_.Finish();
}

struct CmdRectFilledMultiColor FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdRectFilledMultiColorBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CmdRectFilledMultiColorTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_P_MIN = 4,
    VT_P_MAX = 6,
    VT_COL_UPR_LEFT = 8,
    VT_COL_UPR_RIGHT = 10,
    VT_COL_BOT_RIGHT = 12,
    VT_COL_BOT_LEFT = 14
  };
  const ImZeroFB::SingleVec2 *p_min() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_P_MIN);
  }
  const ImZeroFB::SingleVec2 *p_max() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_P_MAX);
  }
  uint32_t col_upr_left() const {
    return GetField<uint32_t>(VT_COL_UPR_LEFT, 0);
  }
  uint32_t col_upr_right() const {
    return GetField<uint32_t>(VT_COL_UPR_RIGHT, 0);
  }
  uint32_t col_bot_right() const {
    return GetField<uint32_t>(VT_COL_BOT_RIGHT, 0);
  }
  uint32_t col_bot_left() const {
    return GetField<uint32_t>(VT_COL_BOT_LEFT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_P_MIN, 4) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_P_MAX, 4) &&
           VerifyField<uint32_t>(verifier, VT_COL_UPR_LEFT, 4) &&
           VerifyField<uint32_t>(verifier, VT_COL_UPR_RIGHT, 4) &&
           VerifyField<uint32_t>(verifier, VT_COL_BOT_RIGHT, 4) &&
           VerifyField<uint32_t>(verifier, VT_COL_BOT_LEFT, 4) &&
           verifier.EndTable();
  }
};

struct CmdRectFilledMultiColorBuilder {
  typedef CmdRectFilledMultiColor Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_p_min(const ImZeroFB::SingleVec2 *p_min) {
    fbb_.AddStruct(CmdRectFilledMultiColor::VT_P_MIN, p_min);
  }
  void add_p_max(const ImZeroFB::SingleVec2 *p_max) {
    fbb_.AddStruct(CmdRectFilledMultiColor::VT_P_MAX, p_max);
  }
  void add_col_upr_left(uint32_t col_upr_left) {
    fbb_.AddElement<uint32_t>(CmdRectFilledMultiColor::VT_COL_UPR_LEFT, col_upr_left, 0);
  }
  void add_col_upr_right(uint32_t col_upr_right) {
    fbb_.AddElement<uint32_t>(CmdRectFilledMultiColor::VT_COL_UPR_RIGHT, col_upr_right, 0);
  }
  void add_col_bot_right(uint32_t col_bot_right) {
    fbb_.AddElement<uint32_t>(CmdRectFilledMultiColor::VT_COL_BOT_RIGHT, col_bot_right, 0);
  }
  void add_col_bot_left(uint32_t col_bot_left) {
    fbb_.AddElement<uint32_t>(CmdRectFilledMultiColor::VT_COL_BOT_LEFT, col_bot_left, 0);
  }
  explicit CmdRectFilledMultiColorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdRectFilledMultiColor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdRectFilledMultiColor>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdRectFilledMultiColor> CreateCmdRectFilledMultiColor(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const ImZeroFB::SingleVec2 *p_min = nullptr,
    const ImZeroFB::SingleVec2 *p_max = nullptr,
    uint32_t col_upr_left = 0,
    uint32_t col_upr_right = 0,
    uint32_t col_bot_right = 0,
    uint32_t col_bot_left = 0) {
  CmdRectFilledMultiColorBuilder builder_(_fbb);
  builder_.add_col_bot_left(col_bot_left);
  builder_.add_col_bot_right(col_bot_right);
  builder_.add_col_upr_right(col_upr_right);
  builder_.add_col_upr_left(col_upr_left);
  builder_.add_p_max(p_max);
  builder_.add_p_min(p_min);
  return builder_.Finish();
}

struct CmdWrappedDrawList FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdWrappedDrawListBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CmdWrappedDrawListTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BUFFER = 4
  };
  const ::flatbuffers::Vector<uint8_t> *buffer() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_BUFFER);
  }
  const ImZeroFB::DrawList *buffer_nested_root() const {
    const auto _f = buffer();
    return _f ? ::flatbuffers::GetRoot<ImZeroFB::DrawList>(_f->Data())
              : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BUFFER) &&
           verifier.VerifyVector(buffer()) &&
           verifier.VerifyNestedFlatBuffer<ImZeroFB::DrawList>(buffer(), nullptr) &&
           verifier.EndTable();
  }
};

struct CmdWrappedDrawListBuilder {
  typedef CmdWrappedDrawList Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_buffer(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> buffer) {
    fbb_.AddOffset(CmdWrappedDrawList::VT_BUFFER, buffer);
  }
  explicit CmdWrappedDrawListBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdWrappedDrawList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdWrappedDrawList>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdWrappedDrawList> CreateCmdWrappedDrawList(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> buffer = 0) {
  CmdWrappedDrawListBuilder builder_(_fbb);
  builder_.add_buffer(buffer);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CmdWrappedDrawList> CreateCmdWrappedDrawListDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *buffer = nullptr) {
  auto buffer__ = buffer ? _fbb.CreateVector<uint8_t>(*buffer) : 0;
  return ImZeroFB::CreateCmdWrappedDrawList(
      _fbb,
      buffer__);
}

struct CmdVertexDraw FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdVertexDrawBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CmdVertexDrawTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLIP_RECT = 4,
    VT_ELEMENT_COUNT = 6,
    VT_INDEX_OFFSET = 8,
    VT_VTX_OFFSET = 10
  };
  const ImZeroFB::SingleVec4 *clip_rect() const {
    return GetStruct<const ImZeroFB::SingleVec4 *>(VT_CLIP_RECT);
  }
  uint32_t element_count() const {
    return GetField<uint32_t>(VT_ELEMENT_COUNT, 0);
  }
  uint32_t index_offset() const {
    return GetField<uint32_t>(VT_INDEX_OFFSET, 0);
  }
  uint32_t vtx_offset() const {
    return GetField<uint32_t>(VT_VTX_OFFSET, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<ImZeroFB::SingleVec4>(verifier, VT_CLIP_RECT, 4) &&
           VerifyField<uint32_t>(verifier, VT_ELEMENT_COUNT, 4) &&
           VerifyField<uint32_t>(verifier, VT_INDEX_OFFSET, 4) &&
           VerifyField<uint32_t>(verifier, VT_VTX_OFFSET, 4) &&
           verifier.EndTable();
  }
};

struct CmdVertexDrawBuilder {
  typedef CmdVertexDraw Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_clip_rect(const ImZeroFB::SingleVec4 *clip_rect) {
    fbb_.AddStruct(CmdVertexDraw::VT_CLIP_RECT, clip_rect);
  }
  void add_element_count(uint32_t element_count) {
    fbb_.AddElement<uint32_t>(CmdVertexDraw::VT_ELEMENT_COUNT, element_count, 0);
  }
  void add_index_offset(uint32_t index_offset) {
    fbb_.AddElement<uint32_t>(CmdVertexDraw::VT_INDEX_OFFSET, index_offset, 0);
  }
  void add_vtx_offset(uint32_t vtx_offset) {
    fbb_.AddElement<uint32_t>(CmdVertexDraw::VT_VTX_OFFSET, vtx_offset, 0);
  }
  explicit CmdVertexDrawBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdVertexDraw> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdVertexDraw>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdVertexDraw> CreateCmdVertexDraw(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const ImZeroFB::SingleVec4 *clip_rect = nullptr,
    uint32_t element_count = 0,
    uint32_t index_offset = 0,
    uint32_t vtx_offset = 0) {
  CmdVertexDrawBuilder builder_(_fbb);
  builder_.add_vtx_offset(vtx_offset);
  builder_.add_index_offset(index_offset);
  builder_.add_element_count(element_count);
  builder_.add_clip_rect(clip_rect);
  return builder_.Finish();
}

struct CmdSimpleVertexDraw FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdSimpleVertexDrawBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CmdSimpleVertexDrawTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLIP_RECT = 4,
    VT_POS_XY = 6,
    VT_COL = 8
  };
  const ImZeroFB::SingleVec4 *clip_rect() const {
    return GetStruct<const ImZeroFB::SingleVec4 *>(VT_CLIP_RECT);
  }
  const ::flatbuffers::Vector<float> *pos_xy() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_POS_XY);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<ImZeroFB::SingleVec4>(verifier, VT_CLIP_RECT, 4) &&
           VerifyOffset(verifier, VT_POS_XY) &&
           verifier.VerifyVector(pos_xy()) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           verifier.EndTable();
  }
};

struct CmdSimpleVertexDrawBuilder {
  typedef CmdSimpleVertexDraw Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_clip_rect(const ImZeroFB::SingleVec4 *clip_rect) {
    fbb_.AddStruct(CmdSimpleVertexDraw::VT_CLIP_RECT, clip_rect);
  }
  void add_pos_xy(::flatbuffers::Offset<::flatbuffers::Vector<float>> pos_xy) {
    fbb_.AddOffset(CmdSimpleVertexDraw::VT_POS_XY, pos_xy);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdSimpleVertexDraw::VT_COL, col, 0);
  }
  explicit CmdSimpleVertexDrawBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdSimpleVertexDraw> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdSimpleVertexDraw>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdSimpleVertexDraw> CreateCmdSimpleVertexDraw(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const ImZeroFB::SingleVec4 *clip_rect = nullptr,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> pos_xy = 0,
    uint32_t col = 0) {
  CmdSimpleVertexDrawBuilder builder_(_fbb);
  builder_.add_col(col);
  builder_.add_pos_xy(pos_xy);
  builder_.add_clip_rect(clip_rect);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CmdSimpleVertexDraw> CreateCmdSimpleVertexDrawDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const ImZeroFB::SingleVec4 *clip_rect = nullptr,
    const std::vector<float> *pos_xy = nullptr,
    uint32_t col = 0) {
  auto pos_xy__ = pos_xy ? _fbb.CreateVector<float>(*pos_xy) : 0;
  return ImZeroFB::CreateCmdSimpleVertexDraw(
      _fbb,
      clip_rect,
      pos_xy__,
      col);
}

struct CmdSvgPathSubset FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdSvgPathSubsetBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CmdSvgPathSubsetTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SVG = 4,
    VT_COL = 6,
    VT_STROKE = 8,
    VT_FILL = 10
  };
  const ::flatbuffers::String *svg() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SVG);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  bool stroke() const {
    return GetField<uint8_t>(VT_STROKE, 0) != 0;
  }
  bool fill() const {
    return GetField<uint8_t>(VT_FILL, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SVG) &&
           verifier.VerifyString(svg()) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           VerifyField<uint8_t>(verifier, VT_STROKE, 1) &&
           VerifyField<uint8_t>(verifier, VT_FILL, 1) &&
           verifier.EndTable();
  }
};

struct CmdSvgPathSubsetBuilder {
  typedef CmdSvgPathSubset Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_svg(::flatbuffers::Offset<::flatbuffers::String> svg) {
    fbb_.AddOffset(CmdSvgPathSubset::VT_SVG, svg);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdSvgPathSubset::VT_COL, col, 0);
  }
  void add_stroke(bool stroke) {
    fbb_.AddElement<uint8_t>(CmdSvgPathSubset::VT_STROKE, static_cast<uint8_t>(stroke), 0);
  }
  void add_fill(bool fill) {
    fbb_.AddElement<uint8_t>(CmdSvgPathSubset::VT_FILL, static_cast<uint8_t>(fill), 0);
  }
  explicit CmdSvgPathSubsetBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdSvgPathSubset> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdSvgPathSubset>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdSvgPathSubset> CreateCmdSvgPathSubset(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> svg = 0,
    uint32_t col = 0,
    bool stroke = false,
    bool fill = false) {
  CmdSvgPathSubsetBuilder builder_(_fbb);
  builder_.add_col(col);
  builder_.add_svg(svg);
  builder_.add_fill(fill);
  builder_.add_stroke(stroke);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CmdSvgPathSubset> CreateCmdSvgPathSubsetDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *svg = nullptr,
    uint32_t col = 0,
    bool stroke = false,
    bool fill = false) {
  auto svg__ = svg ? _fbb.CreateString(svg) : 0;
  return ImZeroFB::CreateCmdSvgPathSubset(
      _fbb,
      svg__,
      col,
      stroke,
      fill);
}

struct CmdPath FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdPathBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CmdPathTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OFFSET = 4,
    VT_VERBS = 6,
    VT_POINTS_XY = 8,
    VT_CONIC_WEIGHTS = 10,
    VT_COL = 12,
    VT_STROKE = 14,
    VT_FILL = 16,
    VT_FILL_TYPE = 18
  };
  const ImZeroFB::SingleVec2 *offset() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_OFFSET);
  }
  const ::flatbuffers::Vector<uint8_t> *verbs() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_VERBS);
  }
  const ::flatbuffers::Vector<float> *points_xy() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_POINTS_XY);
  }
  const ::flatbuffers::Vector<float> *conic_weights() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_CONIC_WEIGHTS);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  bool stroke() const {
    return GetField<uint8_t>(VT_STROKE, 0) != 0;
  }
  bool fill() const {
    return GetField<uint8_t>(VT_FILL, 0) != 0;
  }
  ImZeroFB::PathFillType fill_type() const {
    return static_cast<ImZeroFB::PathFillType>(GetField<uint8_t>(VT_FILL_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_OFFSET, 4) &&
           VerifyOffset(verifier, VT_VERBS) &&
           verifier.VerifyVector(verbs()) &&
           VerifyOffset(verifier, VT_POINTS_XY) &&
           verifier.VerifyVector(points_xy()) &&
           VerifyOffset(verifier, VT_CONIC_WEIGHTS) &&
           verifier.VerifyVector(conic_weights()) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           VerifyField<uint8_t>(verifier, VT_STROKE, 1) &&
           VerifyField<uint8_t>(verifier, VT_FILL, 1) &&
           VerifyField<uint8_t>(verifier, VT_FILL_TYPE, 1) &&
           verifier.EndTable();
  }
};

struct CmdPathBuilder {
  typedef CmdPath Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_offset(const ImZeroFB::SingleVec2 *offset) {
    fbb_.AddStruct(CmdPath::VT_OFFSET, offset);
  }
  void add_verbs(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> verbs) {
    fbb_.AddOffset(CmdPath::VT_VERBS, verbs);
  }
  void add_points_xy(::flatbuffers::Offset<::flatbuffers::Vector<float>> points_xy) {
    fbb_.AddOffset(CmdPath::VT_POINTS_XY, points_xy);
  }
  void add_conic_weights(::flatbuffers::Offset<::flatbuffers::Vector<float>> conic_weights) {
    fbb_.AddOffset(CmdPath::VT_CONIC_WEIGHTS, conic_weights);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdPath::VT_COL, col, 0);
  }
  void add_stroke(bool stroke) {
    fbb_.AddElement<uint8_t>(CmdPath::VT_STROKE, static_cast<uint8_t>(stroke), 0);
  }
  void add_fill(bool fill) {
    fbb_.AddElement<uint8_t>(CmdPath::VT_FILL, static_cast<uint8_t>(fill), 0);
  }
  void add_fill_type(ImZeroFB::PathFillType fill_type) {
    fbb_.AddElement<uint8_t>(CmdPath::VT_FILL_TYPE, static_cast<uint8_t>(fill_type), 0);
  }
  explicit CmdPathBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdPath> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdPath>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdPath> CreateCmdPath(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const ImZeroFB::SingleVec2 *offset = nullptr,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> verbs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> points_xy = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> conic_weights = 0,
    uint32_t col = 0,
    bool stroke = false,
    bool fill = false,
    ImZeroFB::PathFillType fill_type = ImZeroFB::PathFillType_winding) {
  CmdPathBuilder builder_(_fbb);
  builder_.add_col(col);
  builder_.add_conic_weights(conic_weights);
  builder_.add_points_xy(points_xy);
  builder_.add_verbs(verbs);
  builder_.add_offset(offset);
  builder_.add_fill_type(fill_type);
  builder_.add_fill(fill);
  builder_.add_stroke(stroke);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CmdPath> CreateCmdPathDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const ImZeroFB::SingleVec2 *offset = nullptr,
    const std::vector<uint8_t> *verbs = nullptr,
    const std::vector<float> *points_xy = nullptr,
    const std::vector<float> *conic_weights = nullptr,
    uint32_t col = 0,
    bool stroke = false,
    bool fill = false,
    ImZeroFB::PathFillType fill_type = ImZeroFB::PathFillType_winding) {
  auto verbs__ = verbs ? _fbb.CreateVector<uint8_t>(*verbs) : 0;
  auto points_xy__ = points_xy ? _fbb.CreateVector<float>(*points_xy) : 0;
  auto conic_weights__ = conic_weights ? _fbb.CreateVector<float>(*conic_weights) : 0;
  return ImZeroFB::CreateCmdPath(
      _fbb,
      offset,
      verbs__,
      points_xy__,
      conic_weights__,
      col,
      stroke,
      fill,
      fill_type);
}

struct SingleVectorCmdDto FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SingleVectorCmdDtoBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SingleVectorCmdDtoTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ARG_TYPE = 4,
    VT_ARG = 6
  };
  ImZeroFB::VectorCmdArg arg_type() const {
    return static_cast<ImZeroFB::VectorCmdArg>(GetField<uint8_t>(VT_ARG_TYPE, 0));
  }
  const void *arg() const {
    return GetPointer<const void *>(VT_ARG);
  }
  template<typename T> const T *arg_as() const;
  const ImZeroFB::CmdRegisterFont *arg_as_CmdRegisterFont() const {
    return arg_type() == ImZeroFB::VectorCmdArg_CmdRegisterFont ? static_cast<const ImZeroFB::CmdRegisterFont *>(arg()) : nullptr;
  }
  const ImZeroFB::CmdPolyline *arg_as_CmdPolyline() const {
    return arg_type() == ImZeroFB::VectorCmdArg_CmdPolyline ? static_cast<const ImZeroFB::CmdPolyline *>(arg()) : nullptr;
  }
  const ImZeroFB::CmdConvexPolyFilled *arg_as_CmdConvexPolyFilled() const {
    return arg_type() == ImZeroFB::VectorCmdArg_CmdConvexPolyFilled ? static_cast<const ImZeroFB::CmdConvexPolyFilled *>(arg()) : nullptr;
  }
  const ImZeroFB::CmdLine *arg_as_CmdLine() const {
    return arg_type() == ImZeroFB::VectorCmdArg_CmdLine ? static_cast<const ImZeroFB::CmdLine *>(arg()) : nullptr;
  }
  const ImZeroFB::CmdRectRounded *arg_as_CmdRectRounded() const {
    return arg_type() == ImZeroFB::VectorCmdArg_CmdRectRounded ? static_cast<const ImZeroFB::CmdRectRounded *>(arg()) : nullptr;
  }
  const ImZeroFB::CmdRectRoundedCorners *arg_as_CmdRectRoundedCorners() const {
    return arg_type() == ImZeroFB::VectorCmdArg_CmdRectRoundedCorners ? static_cast<const ImZeroFB::CmdRectRoundedCorners *>(arg()) : nullptr;
  }
  const ImZeroFB::CmdRectRoundedFilled *arg_as_CmdRectRoundedFilled() const {
    return arg_type() == ImZeroFB::VectorCmdArg_CmdRectRoundedFilled ? static_cast<const ImZeroFB::CmdRectRoundedFilled *>(arg()) : nullptr;
  }
  const ImZeroFB::CmdRectRoundedCornersFilled *arg_as_CmdRectRoundedCornersFilled() const {
    return arg_type() == ImZeroFB::VectorCmdArg_CmdRectRoundedCornersFilled ? static_cast<const ImZeroFB::CmdRectRoundedCornersFilled *>(arg()) : nullptr;
  }
  const ImZeroFB::CmdQuad *arg_as_CmdQuad() const {
    return arg_type() == ImZeroFB::VectorCmdArg_CmdQuad ? static_cast<const ImZeroFB::CmdQuad *>(arg()) : nullptr;
  }
  const ImZeroFB::CmdQuadFilled *arg_as_CmdQuadFilled() const {
    return arg_type() == ImZeroFB::VectorCmdArg_CmdQuadFilled ? static_cast<const ImZeroFB::CmdQuadFilled *>(arg()) : nullptr;
  }
  const ImZeroFB::CmdTriangle *arg_as_CmdTriangle() const {
    return arg_type() == ImZeroFB::VectorCmdArg_CmdTriangle ? static_cast<const ImZeroFB::CmdTriangle *>(arg()) : nullptr;
  }
  const ImZeroFB::CmdTriangleFilled *arg_as_CmdTriangleFilled() const {
    return arg_type() == ImZeroFB::VectorCmdArg_CmdTriangleFilled ? static_cast<const ImZeroFB::CmdTriangleFilled *>(arg()) : nullptr;
  }
  const ImZeroFB::CmdCircle *arg_as_CmdCircle() const {
    return arg_type() == ImZeroFB::VectorCmdArg_CmdCircle ? static_cast<const ImZeroFB::CmdCircle *>(arg()) : nullptr;
  }
  const ImZeroFB::CmdCircleFilled *arg_as_CmdCircleFilled() const {
    return arg_type() == ImZeroFB::VectorCmdArg_CmdCircleFilled ? static_cast<const ImZeroFB::CmdCircleFilled *>(arg()) : nullptr;
  }
  const ImZeroFB::CmdNgon *arg_as_CmdNgon() const {
    return arg_type() == ImZeroFB::VectorCmdArg_CmdNgon ? static_cast<const ImZeroFB::CmdNgon *>(arg()) : nullptr;
  }
  const ImZeroFB::CmdNgonFilled *arg_as_CmdNgonFilled() const {
    return arg_type() == ImZeroFB::VectorCmdArg_CmdNgonFilled ? static_cast<const ImZeroFB::CmdNgonFilled *>(arg()) : nullptr;
  }
  const ImZeroFB::CmdEllipse *arg_as_CmdEllipse() const {
    return arg_type() == ImZeroFB::VectorCmdArg_CmdEllipse ? static_cast<const ImZeroFB::CmdEllipse *>(arg()) : nullptr;
  }
  const ImZeroFB::CmdEllipseFilled *arg_as_CmdEllipseFilled() const {
    return arg_type() == ImZeroFB::VectorCmdArg_CmdEllipseFilled ? static_cast<const ImZeroFB::CmdEllipseFilled *>(arg()) : nullptr;
  }
  const ImZeroFB::CmdBezierCubic *arg_as_CmdBezierCubic() const {
    return arg_type() == ImZeroFB::VectorCmdArg_CmdBezierCubic ? static_cast<const ImZeroFB::CmdBezierCubic *>(arg()) : nullptr;
  }
  const ImZeroFB::CmdBezierQuadratic *arg_as_CmdBezierQuadratic() const {
    return arg_type() == ImZeroFB::VectorCmdArg_CmdBezierQuadratic ? static_cast<const ImZeroFB::CmdBezierQuadratic *>(arg()) : nullptr;
  }
  const ImZeroFB::CmdImage *arg_as_CmdImage() const {
    return arg_type() == ImZeroFB::VectorCmdArg_CmdImage ? static_cast<const ImZeroFB::CmdImage *>(arg()) : nullptr;
  }
  const ImZeroFB::CmdImageQuad *arg_as_CmdImageQuad() const {
    return arg_type() == ImZeroFB::VectorCmdArg_CmdImageQuad ? static_cast<const ImZeroFB::CmdImageQuad *>(arg()) : nullptr;
  }
  const ImZeroFB::CmdImageRounded *arg_as_CmdImageRounded() const {
    return arg_type() == ImZeroFB::VectorCmdArg_CmdImageRounded ? static_cast<const ImZeroFB::CmdImageRounded *>(arg()) : nullptr;
  }
  const ImZeroFB::CmdPushClipRect *arg_as_CmdPushClipRect() const {
    return arg_type() == ImZeroFB::VectorCmdArg_CmdPushClipRect ? static_cast<const ImZeroFB::CmdPushClipRect *>(arg()) : nullptr;
  }
  const ImZeroFB::CmdPopClipRect *arg_as_CmdPopClipRect() const {
    return arg_type() == ImZeroFB::VectorCmdArg_CmdPopClipRect ? static_cast<const ImZeroFB::CmdPopClipRect *>(arg()) : nullptr;
  }
  const ImZeroFB::CmdRenderText *arg_as_CmdRenderText() const {
    return arg_type() == ImZeroFB::VectorCmdArg_CmdRenderText ? static_cast<const ImZeroFB::CmdRenderText *>(arg()) : nullptr;
  }
  const ImZeroFB::CmdRenderParagraph *arg_as_CmdRenderParagraph() const {
    return arg_type() == ImZeroFB::VectorCmdArg_CmdRenderParagraph ? static_cast<const ImZeroFB::CmdRenderParagraph *>(arg()) : nullptr;
  }
  const ImZeroFB::CmdRenderUnicodeCodepoint *arg_as_CmdRenderUnicodeCodepoint() const {
    return arg_type() == ImZeroFB::VectorCmdArg_CmdRenderUnicodeCodepoint ? static_cast<const ImZeroFB::CmdRenderUnicodeCodepoint *>(arg()) : nullptr;
  }
  const ImZeroFB::CmdRectFilledMultiColor *arg_as_CmdRectFilledMultiColor() const {
    return arg_type() == ImZeroFB::VectorCmdArg_CmdRectFilledMultiColor ? static_cast<const ImZeroFB::CmdRectFilledMultiColor *>(arg()) : nullptr;
  }
  const ImZeroFB::CmdWrappedDrawList *arg_as_CmdWrappedDrawList() const {
    return arg_type() == ImZeroFB::VectorCmdArg_CmdWrappedDrawList ? static_cast<const ImZeroFB::CmdWrappedDrawList *>(arg()) : nullptr;
  }
  const ImZeroFB::CmdVertexDraw *arg_as_CmdVertexDraw() const {
    return arg_type() == ImZeroFB::VectorCmdArg_CmdVertexDraw ? static_cast<const ImZeroFB::CmdVertexDraw *>(arg()) : nullptr;
  }
  const ImZeroFB::CmdPushRotation *arg_as_CmdPushRotation() const {
    return arg_type() == ImZeroFB::VectorCmdArg_CmdPushRotation ? static_cast<const ImZeroFB::CmdPushRotation *>(arg()) : nullptr;
  }
  const ImZeroFB::CmdPopRotation *arg_as_CmdPopRotation() const {
    return arg_type() == ImZeroFB::VectorCmdArg_CmdPopRotation ? static_cast<const ImZeroFB::CmdPopRotation *>(arg()) : nullptr;
  }
  const ImZeroFB::CmdSimpleVertexDraw *arg_as_CmdSimpleVertexDraw() const {
    return arg_type() == ImZeroFB::VectorCmdArg_CmdSimpleVertexDraw ? static_cast<const ImZeroFB::CmdSimpleVertexDraw *>(arg()) : nullptr;
  }
  const ImZeroFB::CmdSvgPathSubset *arg_as_CmdSvgPathSubset() const {
    return arg_type() == ImZeroFB::VectorCmdArg_CmdSvgPathSubset ? static_cast<const ImZeroFB::CmdSvgPathSubset *>(arg()) : nullptr;
  }
  const ImZeroFB::CmdPath *arg_as_CmdPath() const {
    return arg_type() == ImZeroFB::VectorCmdArg_CmdPath ? static_cast<const ImZeroFB::CmdPath *>(arg()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ARG_TYPE, 1) &&
           VerifyOffset(verifier, VT_ARG) &&
           VerifyVectorCmdArg(verifier, arg(), arg_type()) &&
           verifier.EndTable();
  }
};

template<> inline const ImZeroFB::CmdRegisterFont *SingleVectorCmdDto::arg_as<ImZeroFB::CmdRegisterFont>() const {
  return arg_as_CmdRegisterFont();
}

template<> inline const ImZeroFB::CmdPolyline *SingleVectorCmdDto::arg_as<ImZeroFB::CmdPolyline>() const {
  return arg_as_CmdPolyline();
}

template<> inline const ImZeroFB::CmdConvexPolyFilled *SingleVectorCmdDto::arg_as<ImZeroFB::CmdConvexPolyFilled>() const {
  return arg_as_CmdConvexPolyFilled();
}

template<> inline const ImZeroFB::CmdLine *SingleVectorCmdDto::arg_as<ImZeroFB::CmdLine>() const {
  return arg_as_CmdLine();
}

template<> inline const ImZeroFB::CmdRectRounded *SingleVectorCmdDto::arg_as<ImZeroFB::CmdRectRounded>() const {
  return arg_as_CmdRectRounded();
}

template<> inline const ImZeroFB::CmdRectRoundedCorners *SingleVectorCmdDto::arg_as<ImZeroFB::CmdRectRoundedCorners>() const {
  return arg_as_CmdRectRoundedCorners();
}

template<> inline const ImZeroFB::CmdRectRoundedFilled *SingleVectorCmdDto::arg_as<ImZeroFB::CmdRectRoundedFilled>() const {
  return arg_as_CmdRectRoundedFilled();
}

template<> inline const ImZeroFB::CmdRectRoundedCornersFilled *SingleVectorCmdDto::arg_as<ImZeroFB::CmdRectRoundedCornersFilled>() const {
  return arg_as_CmdRectRoundedCornersFilled();
}

template<> inline const ImZeroFB::CmdQuad *SingleVectorCmdDto::arg_as<ImZeroFB::CmdQuad>() const {
  return arg_as_CmdQuad();
}

template<> inline const ImZeroFB::CmdQuadFilled *SingleVectorCmdDto::arg_as<ImZeroFB::CmdQuadFilled>() const {
  return arg_as_CmdQuadFilled();
}

template<> inline const ImZeroFB::CmdTriangle *SingleVectorCmdDto::arg_as<ImZeroFB::CmdTriangle>() const {
  return arg_as_CmdTriangle();
}

template<> inline const ImZeroFB::CmdTriangleFilled *SingleVectorCmdDto::arg_as<ImZeroFB::CmdTriangleFilled>() const {
  return arg_as_CmdTriangleFilled();
}

template<> inline const ImZeroFB::CmdCircle *SingleVectorCmdDto::arg_as<ImZeroFB::CmdCircle>() const {
  return arg_as_CmdCircle();
}

template<> inline const ImZeroFB::CmdCircleFilled *SingleVectorCmdDto::arg_as<ImZeroFB::CmdCircleFilled>() const {
  return arg_as_CmdCircleFilled();
}

template<> inline const ImZeroFB::CmdNgon *SingleVectorCmdDto::arg_as<ImZeroFB::CmdNgon>() const {
  return arg_as_CmdNgon();
}

template<> inline const ImZeroFB::CmdNgonFilled *SingleVectorCmdDto::arg_as<ImZeroFB::CmdNgonFilled>() const {
  return arg_as_CmdNgonFilled();
}

template<> inline const ImZeroFB::CmdEllipse *SingleVectorCmdDto::arg_as<ImZeroFB::CmdEllipse>() const {
  return arg_as_CmdEllipse();
}

template<> inline const ImZeroFB::CmdEllipseFilled *SingleVectorCmdDto::arg_as<ImZeroFB::CmdEllipseFilled>() const {
  return arg_as_CmdEllipseFilled();
}

template<> inline const ImZeroFB::CmdBezierCubic *SingleVectorCmdDto::arg_as<ImZeroFB::CmdBezierCubic>() const {
  return arg_as_CmdBezierCubic();
}

template<> inline const ImZeroFB::CmdBezierQuadratic *SingleVectorCmdDto::arg_as<ImZeroFB::CmdBezierQuadratic>() const {
  return arg_as_CmdBezierQuadratic();
}

template<> inline const ImZeroFB::CmdImage *SingleVectorCmdDto::arg_as<ImZeroFB::CmdImage>() const {
  return arg_as_CmdImage();
}

template<> inline const ImZeroFB::CmdImageQuad *SingleVectorCmdDto::arg_as<ImZeroFB::CmdImageQuad>() const {
  return arg_as_CmdImageQuad();
}

template<> inline const ImZeroFB::CmdImageRounded *SingleVectorCmdDto::arg_as<ImZeroFB::CmdImageRounded>() const {
  return arg_as_CmdImageRounded();
}

template<> inline const ImZeroFB::CmdPushClipRect *SingleVectorCmdDto::arg_as<ImZeroFB::CmdPushClipRect>() const {
  return arg_as_CmdPushClipRect();
}

template<> inline const ImZeroFB::CmdPopClipRect *SingleVectorCmdDto::arg_as<ImZeroFB::CmdPopClipRect>() const {
  return arg_as_CmdPopClipRect();
}

template<> inline const ImZeroFB::CmdRenderText *SingleVectorCmdDto::arg_as<ImZeroFB::CmdRenderText>() const {
  return arg_as_CmdRenderText();
}

template<> inline const ImZeroFB::CmdRenderParagraph *SingleVectorCmdDto::arg_as<ImZeroFB::CmdRenderParagraph>() const {
  return arg_as_CmdRenderParagraph();
}

template<> inline const ImZeroFB::CmdRenderUnicodeCodepoint *SingleVectorCmdDto::arg_as<ImZeroFB::CmdRenderUnicodeCodepoint>() const {
  return arg_as_CmdRenderUnicodeCodepoint();
}

template<> inline const ImZeroFB::CmdRectFilledMultiColor *SingleVectorCmdDto::arg_as<ImZeroFB::CmdRectFilledMultiColor>() const {
  return arg_as_CmdRectFilledMultiColor();
}

template<> inline const ImZeroFB::CmdWrappedDrawList *SingleVectorCmdDto::arg_as<ImZeroFB::CmdWrappedDrawList>() const {
  return arg_as_CmdWrappedDrawList();
}

template<> inline const ImZeroFB::CmdVertexDraw *SingleVectorCmdDto::arg_as<ImZeroFB::CmdVertexDraw>() const {
  return arg_as_CmdVertexDraw();
}

template<> inline const ImZeroFB::CmdPushRotation *SingleVectorCmdDto::arg_as<ImZeroFB::CmdPushRotation>() const {
  return arg_as_CmdPushRotation();
}

template<> inline const ImZeroFB::CmdPopRotation *SingleVectorCmdDto::arg_as<ImZeroFB::CmdPopRotation>() const {
  return arg_as_CmdPopRotation();
}

template<> inline const ImZeroFB::CmdSimpleVertexDraw *SingleVectorCmdDto::arg_as<ImZeroFB::CmdSimpleVertexDraw>() const {
  return arg_as_CmdSimpleVertexDraw();
}

template<> inline const ImZeroFB::CmdSvgPathSubset *SingleVectorCmdDto::arg_as<ImZeroFB::CmdSvgPathSubset>() const {
  return arg_as_CmdSvgPathSubset();
}

template<> inline const ImZeroFB::CmdPath *SingleVectorCmdDto::arg_as<ImZeroFB::CmdPath>() const {
  return arg_as_CmdPath();
}

struct SingleVectorCmdDtoBuilder {
  typedef SingleVectorCmdDto Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_arg_type(ImZeroFB::VectorCmdArg arg_type) {
    fbb_.AddElement<uint8_t>(SingleVectorCmdDto::VT_ARG_TYPE, static_cast<uint8_t>(arg_type), 0);
  }
  void add_arg(::flatbuffers::Offset<void> arg) {
    fbb_.AddOffset(SingleVectorCmdDto::VT_ARG, arg);
  }
  explicit SingleVectorCmdDtoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SingleVectorCmdDto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SingleVectorCmdDto>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SingleVectorCmdDto> CreateSingleVectorCmdDto(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ImZeroFB::VectorCmdArg arg_type = ImZeroFB::VectorCmdArg_NONE,
    ::flatbuffers::Offset<void> arg = 0) {
  SingleVectorCmdDtoBuilder builder_(_fbb);
  builder_.add_arg(arg);
  builder_.add_arg_type(arg_type);
  return builder_.Finish();
}

struct VertexData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VertexDataBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return VertexDataTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POS_XY = 4,
    VT_TEXTURE_UV = 6,
    VT_COL = 8,
    VT_INDICES = 10
  };
  const ::flatbuffers::Vector<float> *pos_xy() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_POS_XY);
  }
  const ::flatbuffers::Vector<float> *texture_uv() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_TEXTURE_UV);
  }
  const ::flatbuffers::Vector<uint32_t> *col() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_COL);
  }
  const ::flatbuffers::Vector<uint16_t> *indices() const {
    return GetPointer<const ::flatbuffers::Vector<uint16_t> *>(VT_INDICES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_POS_XY) &&
           verifier.VerifyVector(pos_xy()) &&
           VerifyOffset(verifier, VT_TEXTURE_UV) &&
           verifier.VerifyVector(texture_uv()) &&
           VerifyOffset(verifier, VT_COL) &&
           verifier.VerifyVector(col()) &&
           VerifyOffset(verifier, VT_INDICES) &&
           verifier.VerifyVector(indices()) &&
           verifier.EndTable();
  }
};

struct VertexDataBuilder {
  typedef VertexData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pos_xy(::flatbuffers::Offset<::flatbuffers::Vector<float>> pos_xy) {
    fbb_.AddOffset(VertexData::VT_POS_XY, pos_xy);
  }
  void add_texture_uv(::flatbuffers::Offset<::flatbuffers::Vector<float>> texture_uv) {
    fbb_.AddOffset(VertexData::VT_TEXTURE_UV, texture_uv);
  }
  void add_col(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> col) {
    fbb_.AddOffset(VertexData::VT_COL, col);
  }
  void add_indices(::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> indices) {
    fbb_.AddOffset(VertexData::VT_INDICES, indices);
  }
  explicit VertexDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VertexData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VertexData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VertexData> CreateVertexData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> pos_xy = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> texture_uv = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> col = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> indices = 0) {
  VertexDataBuilder builder_(_fbb);
  builder_.add_indices(indices);
  builder_.add_col(col);
  builder_.add_texture_uv(texture_uv);
  builder_.add_pos_xy(pos_xy);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<VertexData> CreateVertexDataDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *pos_xy = nullptr,
    const std::vector<float> *texture_uv = nullptr,
    const std::vector<uint32_t> *col = nullptr,
    const std::vector<uint16_t> *indices = nullptr) {
  auto pos_xy__ = pos_xy ? _fbb.CreateVector<float>(*pos_xy) : 0;
  auto texture_uv__ = texture_uv ? _fbb.CreateVector<float>(*texture_uv) : 0;
  auto col__ = col ? _fbb.CreateVector<uint32_t>(*col) : 0;
  auto indices__ = indices ? _fbb.CreateVector<uint16_t>(*indices) : 0;
  return ImZeroFB::CreateVertexData(
      _fbb,
      pos_xy__,
      texture_uv__,
      col__,
      indices__);
}

struct DrawList FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DrawListBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DrawListTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FLAGS = 4,
    VT_NAME = 6,
    VT_VERTICES = 8,
    VT_CMDS = 10
  };
  ImZeroFB::DrawListFlags flags() const {
    return static_cast<ImZeroFB::DrawListFlags>(GetField<uint8_t>(VT_FLAGS, 0));
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ImZeroFB::VertexData *vertices() const {
    return GetPointer<const ImZeroFB::VertexData *>(VT_VERTICES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<ImZeroFB::SingleVectorCmdDto>> *cmds() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ImZeroFB::SingleVectorCmdDto>> *>(VT_CMDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_FLAGS, 1) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_VERTICES) &&
           verifier.VerifyTable(vertices()) &&
           VerifyOffset(verifier, VT_CMDS) &&
           verifier.VerifyVector(cmds()) &&
           verifier.VerifyVectorOfTables(cmds()) &&
           verifier.EndTable();
  }
};

struct DrawListBuilder {
  typedef DrawList Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_flags(ImZeroFB::DrawListFlags flags) {
    fbb_.AddElement<uint8_t>(DrawList::VT_FLAGS, static_cast<uint8_t>(flags), 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(DrawList::VT_NAME, name);
  }
  void add_vertices(::flatbuffers::Offset<ImZeroFB::VertexData> vertices) {
    fbb_.AddOffset(DrawList::VT_VERTICES, vertices);
  }
  void add_cmds(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ImZeroFB::SingleVectorCmdDto>>> cmds) {
    fbb_.AddOffset(DrawList::VT_CMDS, cmds);
  }
  explicit DrawListBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DrawList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DrawList>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DrawList> CreateDrawList(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ImZeroFB::DrawListFlags flags = ImZeroFB::DrawListFlags_None,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<ImZeroFB::VertexData> vertices = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ImZeroFB::SingleVectorCmdDto>>> cmds = 0) {
  DrawListBuilder builder_(_fbb);
  builder_.add_cmds(cmds);
  builder_.add_vertices(vertices);
  builder_.add_name(name);
  builder_.add_flags(flags);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DrawList> CreateDrawListDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ImZeroFB::DrawListFlags flags = ImZeroFB::DrawListFlags_None,
    const char *name = nullptr,
    ::flatbuffers::Offset<ImZeroFB::VertexData> vertices = 0,
    const std::vector<::flatbuffers::Offset<ImZeroFB::SingleVectorCmdDto>> *cmds = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto cmds__ = cmds ? _fbb.CreateVector<::flatbuffers::Offset<ImZeroFB::SingleVectorCmdDto>>(*cmds) : 0;
  return ImZeroFB::CreateDrawList(
      _fbb,
      flags,
      name__,
      vertices,
      cmds__);
}

struct IoRecord FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IoRecordBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return IoRecordTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FLAGS = 4
  };
  ImZeroFB::IoFlags flags() const {
    return static_cast<ImZeroFB::IoFlags>(GetField<uint16_t>(VT_FLAGS, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_FLAGS, 2) &&
           verifier.EndTable();
  }
};

struct IoRecordBuilder {
  typedef IoRecord Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_flags(ImZeroFB::IoFlags flags) {
    fbb_.AddElement<uint16_t>(IoRecord::VT_FLAGS, static_cast<uint16_t>(flags), 0);
  }
  explicit IoRecordBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<IoRecord> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<IoRecord>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<IoRecord> CreateIoRecord(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ImZeroFB::IoFlags flags = ImZeroFB::IoFlags_None) {
  IoRecordBuilder builder_(_fbb);
  builder_.add_flags(flags);
  return builder_.Finish();
}

struct EventMouseMotion FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EventMouseMotionBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return EventMouseMotionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POS = 4,
    VT_MOUSE_ID = 6,
    VT_IS_TOUCH = 8
  };
  const ImZeroFB::SingleVec2 *pos() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_POS);
  }
  uint32_t mouse_id() const {
    return GetField<uint32_t>(VT_MOUSE_ID, 0);
  }
  bool is_touch() const {
    return GetField<uint8_t>(VT_IS_TOUCH, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_POS, 4) &&
           VerifyField<uint32_t>(verifier, VT_MOUSE_ID, 4) &&
           VerifyField<uint8_t>(verifier, VT_IS_TOUCH, 1) &&
           verifier.EndTable();
  }
};

struct EventMouseMotionBuilder {
  typedef EventMouseMotion Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pos(const ImZeroFB::SingleVec2 *pos) {
    fbb_.AddStruct(EventMouseMotion::VT_POS, pos);
  }
  void add_mouse_id(uint32_t mouse_id) {
    fbb_.AddElement<uint32_t>(EventMouseMotion::VT_MOUSE_ID, mouse_id, 0);
  }
  void add_is_touch(bool is_touch) {
    fbb_.AddElement<uint8_t>(EventMouseMotion::VT_IS_TOUCH, static_cast<uint8_t>(is_touch), 0);
  }
  explicit EventMouseMotionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EventMouseMotion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EventMouseMotion>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EventMouseMotion> CreateEventMouseMotion(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const ImZeroFB::SingleVec2 *pos = nullptr,
    uint32_t mouse_id = 0,
    bool is_touch = false) {
  EventMouseMotionBuilder builder_(_fbb);
  builder_.add_mouse_id(mouse_id);
  builder_.add_pos(pos);
  builder_.add_is_touch(is_touch);
  return builder_.Finish();
}

struct EventMouseWheel FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EventMouseWheelBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return EventMouseWheelTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POS = 4,
    VT_MOUSE_ID = 6,
    VT_IS_TOUCH = 8
  };
  const ImZeroFB::SingleVec2 *pos() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_POS);
  }
  uint32_t mouse_id() const {
    return GetField<uint32_t>(VT_MOUSE_ID, 0);
  }
  bool is_touch() const {
    return GetField<uint8_t>(VT_IS_TOUCH, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_POS, 4) &&
           VerifyField<uint32_t>(verifier, VT_MOUSE_ID, 4) &&
           VerifyField<uint8_t>(verifier, VT_IS_TOUCH, 1) &&
           verifier.EndTable();
  }
};

struct EventMouseWheelBuilder {
  typedef EventMouseWheel Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pos(const ImZeroFB::SingleVec2 *pos) {
    fbb_.AddStruct(EventMouseWheel::VT_POS, pos);
  }
  void add_mouse_id(uint32_t mouse_id) {
    fbb_.AddElement<uint32_t>(EventMouseWheel::VT_MOUSE_ID, mouse_id, 0);
  }
  void add_is_touch(bool is_touch) {
    fbb_.AddElement<uint8_t>(EventMouseWheel::VT_IS_TOUCH, static_cast<uint8_t>(is_touch), 0);
  }
  explicit EventMouseWheelBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EventMouseWheel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EventMouseWheel>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EventMouseWheel> CreateEventMouseWheel(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const ImZeroFB::SingleVec2 *pos = nullptr,
    uint32_t mouse_id = 0,
    bool is_touch = false) {
  EventMouseWheelBuilder builder_(_fbb);
  builder_.add_mouse_id(mouse_id);
  builder_.add_pos(pos);
  builder_.add_is_touch(is_touch);
  return builder_.Finish();
}

struct EventMouseButton FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EventMouseButtonBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return EventMouseButtonTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POS = 4,
    VT_MOUSE_ID = 6,
    VT_IS_TOUCH = 8,
    VT_BUTTON = 10,
    VT_TYPE = 12
  };
  const ImZeroFB::SingleVec2 *pos() const {
    return GetStruct<const ImZeroFB::SingleVec2 *>(VT_POS);
  }
  uint32_t mouse_id() const {
    return GetField<uint32_t>(VT_MOUSE_ID, 0);
  }
  bool is_touch() const {
    return GetField<uint8_t>(VT_IS_TOUCH, 0) != 0;
  }
  ImZeroFB::MouseButton button() const {
    return static_cast<ImZeroFB::MouseButton>(GetField<uint8_t>(VT_BUTTON, 0));
  }
  ImZeroFB::MouseButtonEventType type() const {
    return static_cast<ImZeroFB::MouseButtonEventType>(GetField<uint8_t>(VT_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<ImZeroFB::SingleVec2>(verifier, VT_POS, 4) &&
           VerifyField<uint32_t>(verifier, VT_MOUSE_ID, 4) &&
           VerifyField<uint8_t>(verifier, VT_IS_TOUCH, 1) &&
           VerifyField<uint8_t>(verifier, VT_BUTTON, 1) &&
           VerifyField<uint8_t>(verifier, VT_TYPE, 1) &&
           verifier.EndTable();
  }
};

struct EventMouseButtonBuilder {
  typedef EventMouseButton Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pos(const ImZeroFB::SingleVec2 *pos) {
    fbb_.AddStruct(EventMouseButton::VT_POS, pos);
  }
  void add_mouse_id(uint32_t mouse_id) {
    fbb_.AddElement<uint32_t>(EventMouseButton::VT_MOUSE_ID, mouse_id, 0);
  }
  void add_is_touch(bool is_touch) {
    fbb_.AddElement<uint8_t>(EventMouseButton::VT_IS_TOUCH, static_cast<uint8_t>(is_touch), 0);
  }
  void add_button(ImZeroFB::MouseButton button) {
    fbb_.AddElement<uint8_t>(EventMouseButton::VT_BUTTON, static_cast<uint8_t>(button), 0);
  }
  void add_type(ImZeroFB::MouseButtonEventType type) {
    fbb_.AddElement<uint8_t>(EventMouseButton::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  explicit EventMouseButtonBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EventMouseButton> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EventMouseButton>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EventMouseButton> CreateEventMouseButton(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const ImZeroFB::SingleVec2 *pos = nullptr,
    uint32_t mouse_id = 0,
    bool is_touch = false,
    ImZeroFB::MouseButton button = ImZeroFB::MouseButton_None,
    ImZeroFB::MouseButtonEventType type = ImZeroFB::MouseButtonEventType_Up) {
  EventMouseButtonBuilder builder_(_fbb);
  builder_.add_mouse_id(mouse_id);
  builder_.add_pos(pos);
  builder_.add_type(type);
  builder_.add_button(button);
  builder_.add_is_touch(is_touch);
  return builder_.Finish();
}

struct EventTextInput FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EventTextInputBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return EventTextInputTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEXT = 4
  };
  const ::flatbuffers::String *text() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TEXT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           verifier.EndTable();
  }
};

struct EventTextInputBuilder {
  typedef EventTextInput Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_text(::flatbuffers::Offset<::flatbuffers::String> text) {
    fbb_.AddOffset(EventTextInput::VT_TEXT, text);
  }
  explicit EventTextInputBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EventTextInput> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EventTextInput>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EventTextInput> CreateEventTextInput(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> text = 0) {
  EventTextInputBuilder builder_(_fbb);
  builder_.add_text(text);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<EventTextInput> CreateEventTextInputDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *text = nullptr) {
  auto text__ = text ? _fbb.CreateString(text) : 0;
  return ImZeroFB::CreateEventTextInput(
      _fbb,
      text__);
}

struct EventKeyboard FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EventKeyboardBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return EventKeyboardTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODIFIERS = 4,
    VT_CODE = 6,
    VT_IS_DOWN = 8,
    VT_NATIVE_SYM = 10,
    VT_SCANCODE = 12
  };
  ImZeroFB::KeyModifiers modifiers() const {
    return static_cast<ImZeroFB::KeyModifiers>(GetField<uint8_t>(VT_MODIFIERS, 0));
  }
  ImZeroFB::KeyCode code() const {
    return static_cast<ImZeroFB::KeyCode>(GetField<uint32_t>(VT_CODE, 0));
  }
  bool is_down() const {
    return GetField<uint8_t>(VT_IS_DOWN, 0) != 0;
  }
  uint32_t native_sym() const {
    return GetField<uint32_t>(VT_NATIVE_SYM, 0);
  }
  uint32_t scancode() const {
    return GetField<uint32_t>(VT_SCANCODE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MODIFIERS, 1) &&
           VerifyField<uint32_t>(verifier, VT_CODE, 4) &&
           VerifyField<uint8_t>(verifier, VT_IS_DOWN, 1) &&
           VerifyField<uint32_t>(verifier, VT_NATIVE_SYM, 4) &&
           VerifyField<uint32_t>(verifier, VT_SCANCODE, 4) &&
           verifier.EndTable();
  }
};

struct EventKeyboardBuilder {
  typedef EventKeyboard Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_modifiers(ImZeroFB::KeyModifiers modifiers) {
    fbb_.AddElement<uint8_t>(EventKeyboard::VT_MODIFIERS, static_cast<uint8_t>(modifiers), 0);
  }
  void add_code(ImZeroFB::KeyCode code) {
    fbb_.AddElement<uint32_t>(EventKeyboard::VT_CODE, static_cast<uint32_t>(code), 0);
  }
  void add_is_down(bool is_down) {
    fbb_.AddElement<uint8_t>(EventKeyboard::VT_IS_DOWN, static_cast<uint8_t>(is_down), 0);
  }
  void add_native_sym(uint32_t native_sym) {
    fbb_.AddElement<uint32_t>(EventKeyboard::VT_NATIVE_SYM, native_sym, 0);
  }
  void add_scancode(uint32_t scancode) {
    fbb_.AddElement<uint32_t>(EventKeyboard::VT_SCANCODE, scancode, 0);
  }
  explicit EventKeyboardBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EventKeyboard> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EventKeyboard>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EventKeyboard> CreateEventKeyboard(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ImZeroFB::KeyModifiers modifiers = ImZeroFB::KeyModifiers_None,
    ImZeroFB::KeyCode code = ImZeroFB::KeyCode_Key_None,
    bool is_down = false,
    uint32_t native_sym = 0,
    uint32_t scancode = 0) {
  EventKeyboardBuilder builder_(_fbb);
  builder_.add_scancode(scancode);
  builder_.add_native_sym(native_sym);
  builder_.add_code(code);
  builder_.add_is_down(is_down);
  builder_.add_modifiers(modifiers);
  return builder_.Finish();
}

struct InputEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef InputEventBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return InputEventTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EVENT_TYPE = 4,
    VT_EVENT = 6
  };
  ImZeroFB::UserInteraction event_type() const {
    return static_cast<ImZeroFB::UserInteraction>(GetField<uint8_t>(VT_EVENT_TYPE, 0));
  }
  const void *event() const {
    return GetPointer<const void *>(VT_EVENT);
  }
  template<typename T> const T *event_as() const;
  const ImZeroFB::EventMouseMotion *event_as_EventMouseMotion() const {
    return event_type() == ImZeroFB::UserInteraction_EventMouseMotion ? static_cast<const ImZeroFB::EventMouseMotion *>(event()) : nullptr;
  }
  const ImZeroFB::EventMouseWheel *event_as_EventMouseWheel() const {
    return event_type() == ImZeroFB::UserInteraction_EventMouseWheel ? static_cast<const ImZeroFB::EventMouseWheel *>(event()) : nullptr;
  }
  const ImZeroFB::EventMouseButton *event_as_EventMouseButton() const {
    return event_type() == ImZeroFB::UserInteraction_EventMouseButton ? static_cast<const ImZeroFB::EventMouseButton *>(event()) : nullptr;
  }
  const ImZeroFB::EventTextInput *event_as_EventTextInput() const {
    return event_type() == ImZeroFB::UserInteraction_EventTextInput ? static_cast<const ImZeroFB::EventTextInput *>(event()) : nullptr;
  }
  const ImZeroFB::EventKeyboard *event_as_EventKeyboard() const {
    return event_type() == ImZeroFB::UserInteraction_EventKeyboard ? static_cast<const ImZeroFB::EventKeyboard *>(event()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_EVENT_TYPE, 1) &&
           VerifyOffset(verifier, VT_EVENT) &&
           VerifyUserInteraction(verifier, event(), event_type()) &&
           verifier.EndTable();
  }
};

template<> inline const ImZeroFB::EventMouseMotion *InputEvent::event_as<ImZeroFB::EventMouseMotion>() const {
  return event_as_EventMouseMotion();
}

template<> inline const ImZeroFB::EventMouseWheel *InputEvent::event_as<ImZeroFB::EventMouseWheel>() const {
  return event_as_EventMouseWheel();
}

template<> inline const ImZeroFB::EventMouseButton *InputEvent::event_as<ImZeroFB::EventMouseButton>() const {
  return event_as_EventMouseButton();
}

template<> inline const ImZeroFB::EventTextInput *InputEvent::event_as<ImZeroFB::EventTextInput>() const {
  return event_as_EventTextInput();
}

template<> inline const ImZeroFB::EventKeyboard *InputEvent::event_as<ImZeroFB::EventKeyboard>() const {
  return event_as_EventKeyboard();
}

struct InputEventBuilder {
  typedef InputEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_event_type(ImZeroFB::UserInteraction event_type) {
    fbb_.AddElement<uint8_t>(InputEvent::VT_EVENT_TYPE, static_cast<uint8_t>(event_type), 0);
  }
  void add_event(::flatbuffers::Offset<void> event) {
    fbb_.AddOffset(InputEvent::VT_EVENT, event);
  }
  explicit InputEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<InputEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<InputEvent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<InputEvent> CreateInputEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ImZeroFB::UserInteraction event_type = ImZeroFB::UserInteraction_NONE,
    ::flatbuffers::Offset<void> event = 0) {
  InputEventBuilder builder_(_fbb);
  builder_.add_event(event);
  builder_.add_event_type(event_type);
  return builder_.Finish();
}

inline bool VerifyVectorCmdArg(::flatbuffers::Verifier &verifier, const void *obj, VectorCmdArg type) {
  switch (type) {
    case VectorCmdArg_NONE: {
      return true;
    }
    case VectorCmdArg_CmdRegisterFont: {
      auto ptr = reinterpret_cast<const ImZeroFB::CmdRegisterFont *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdPolyline: {
      auto ptr = reinterpret_cast<const ImZeroFB::CmdPolyline *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdConvexPolyFilled: {
      auto ptr = reinterpret_cast<const ImZeroFB::CmdConvexPolyFilled *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdLine: {
      auto ptr = reinterpret_cast<const ImZeroFB::CmdLine *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdRectRounded: {
      auto ptr = reinterpret_cast<const ImZeroFB::CmdRectRounded *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdRectRoundedCorners: {
      auto ptr = reinterpret_cast<const ImZeroFB::CmdRectRoundedCorners *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdRectRoundedFilled: {
      auto ptr = reinterpret_cast<const ImZeroFB::CmdRectRoundedFilled *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdRectRoundedCornersFilled: {
      auto ptr = reinterpret_cast<const ImZeroFB::CmdRectRoundedCornersFilled *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdQuad: {
      auto ptr = reinterpret_cast<const ImZeroFB::CmdQuad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdQuadFilled: {
      auto ptr = reinterpret_cast<const ImZeroFB::CmdQuadFilled *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdTriangle: {
      auto ptr = reinterpret_cast<const ImZeroFB::CmdTriangle *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdTriangleFilled: {
      auto ptr = reinterpret_cast<const ImZeroFB::CmdTriangleFilled *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdCircle: {
      auto ptr = reinterpret_cast<const ImZeroFB::CmdCircle *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdCircleFilled: {
      auto ptr = reinterpret_cast<const ImZeroFB::CmdCircleFilled *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdNgon: {
      auto ptr = reinterpret_cast<const ImZeroFB::CmdNgon *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdNgonFilled: {
      auto ptr = reinterpret_cast<const ImZeroFB::CmdNgonFilled *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdEllipse: {
      auto ptr = reinterpret_cast<const ImZeroFB::CmdEllipse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdEllipseFilled: {
      auto ptr = reinterpret_cast<const ImZeroFB::CmdEllipseFilled *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdBezierCubic: {
      auto ptr = reinterpret_cast<const ImZeroFB::CmdBezierCubic *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdBezierQuadratic: {
      auto ptr = reinterpret_cast<const ImZeroFB::CmdBezierQuadratic *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdImage: {
      auto ptr = reinterpret_cast<const ImZeroFB::CmdImage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdImageQuad: {
      auto ptr = reinterpret_cast<const ImZeroFB::CmdImageQuad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdImageRounded: {
      auto ptr = reinterpret_cast<const ImZeroFB::CmdImageRounded *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdPushClipRect: {
      auto ptr = reinterpret_cast<const ImZeroFB::CmdPushClipRect *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdPopClipRect: {
      auto ptr = reinterpret_cast<const ImZeroFB::CmdPopClipRect *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdRenderText: {
      auto ptr = reinterpret_cast<const ImZeroFB::CmdRenderText *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdRenderParagraph: {
      auto ptr = reinterpret_cast<const ImZeroFB::CmdRenderParagraph *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdRenderUnicodeCodepoint: {
      auto ptr = reinterpret_cast<const ImZeroFB::CmdRenderUnicodeCodepoint *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdRectFilledMultiColor: {
      auto ptr = reinterpret_cast<const ImZeroFB::CmdRectFilledMultiColor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdWrappedDrawList: {
      auto ptr = reinterpret_cast<const ImZeroFB::CmdWrappedDrawList *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdVertexDraw: {
      auto ptr = reinterpret_cast<const ImZeroFB::CmdVertexDraw *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdPushRotation: {
      auto ptr = reinterpret_cast<const ImZeroFB::CmdPushRotation *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdPopRotation: {
      auto ptr = reinterpret_cast<const ImZeroFB::CmdPopRotation *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdSimpleVertexDraw: {
      auto ptr = reinterpret_cast<const ImZeroFB::CmdSimpleVertexDraw *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdSvgPathSubset: {
      auto ptr = reinterpret_cast<const ImZeroFB::CmdSvgPathSubset *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdPath: {
      auto ptr = reinterpret_cast<const ImZeroFB::CmdPath *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyVectorCmdArgVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyVectorCmdArg(
        verifier,  values->Get(i), types->GetEnum<VectorCmdArg>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyUserInteraction(::flatbuffers::Verifier &verifier, const void *obj, UserInteraction type) {
  switch (type) {
    case UserInteraction_NONE: {
      return true;
    }
    case UserInteraction_EventMouseMotion: {
      auto ptr = reinterpret_cast<const ImZeroFB::EventMouseMotion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case UserInteraction_EventMouseWheel: {
      auto ptr = reinterpret_cast<const ImZeroFB::EventMouseWheel *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case UserInteraction_EventMouseButton: {
      auto ptr = reinterpret_cast<const ImZeroFB::EventMouseButton *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case UserInteraction_EventTextInput: {
      auto ptr = reinterpret_cast<const ImZeroFB::EventTextInput *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case UserInteraction_EventKeyboard: {
      auto ptr = reinterpret_cast<const ImZeroFB::EventKeyboard *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyUserInteractionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyUserInteraction(
        verifier,  values->Get(i), types->GetEnum<UserInteraction>(i))) {
      return false;
    }
  }
  return true;
}

inline const ::flatbuffers::TypeTable *TextAlignFlagsTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    ImZeroFB::TextAlignFlagsTypeTable
  };
  static const char * const names[] = {
    "left",
    "right",
    "center",
    "justify"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *TextDirectionTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    ImZeroFB::TextDirectionTypeTable
  };
  static const char * const names[] = {
    "ltr",
    "rtl"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *PathVerbTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    ImZeroFB::PathVerbTypeTable
  };
  static const char * const names[] = {
    "move",
    "line",
    "quad",
    "conic",
    "cubic",
    "close",
    "done"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 7, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *PathFillTypeTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    ImZeroFB::PathFillTypeTypeTable
  };
  static const char * const names[] = {
    "winding",
    "evenOdd",
    "inverseWinding",
    "inverseEvenOdd"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *VectorCmdArgTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 2 },
    { ::flatbuffers::ET_SEQUENCE, 0, 3 },
    { ::flatbuffers::ET_SEQUENCE, 0, 4 },
    { ::flatbuffers::ET_SEQUENCE, 0, 5 },
    { ::flatbuffers::ET_SEQUENCE, 0, 6 },
    { ::flatbuffers::ET_SEQUENCE, 0, 7 },
    { ::flatbuffers::ET_SEQUENCE, 0, 8 },
    { ::flatbuffers::ET_SEQUENCE, 0, 9 },
    { ::flatbuffers::ET_SEQUENCE, 0, 10 },
    { ::flatbuffers::ET_SEQUENCE, 0, 11 },
    { ::flatbuffers::ET_SEQUENCE, 0, 12 },
    { ::flatbuffers::ET_SEQUENCE, 0, 13 },
    { ::flatbuffers::ET_SEQUENCE, 0, 14 },
    { ::flatbuffers::ET_SEQUENCE, 0, 15 },
    { ::flatbuffers::ET_SEQUENCE, 0, 16 },
    { ::flatbuffers::ET_SEQUENCE, 0, 17 },
    { ::flatbuffers::ET_SEQUENCE, 0, 18 },
    { ::flatbuffers::ET_SEQUENCE, 0, 19 },
    { ::flatbuffers::ET_SEQUENCE, 0, 20 },
    { ::flatbuffers::ET_SEQUENCE, 0, 21 },
    { ::flatbuffers::ET_SEQUENCE, 0, 22 },
    { ::flatbuffers::ET_SEQUENCE, 0, 23 },
    { ::flatbuffers::ET_SEQUENCE, 0, 24 },
    { ::flatbuffers::ET_SEQUENCE, 0, 25 },
    { ::flatbuffers::ET_SEQUENCE, 0, 26 },
    { ::flatbuffers::ET_SEQUENCE, 0, 27 },
    { ::flatbuffers::ET_SEQUENCE, 0, 28 },
    { ::flatbuffers::ET_SEQUENCE, 0, 29 },
    { ::flatbuffers::ET_SEQUENCE, 0, 30 },
    { ::flatbuffers::ET_SEQUENCE, 0, 31 },
    { ::flatbuffers::ET_SEQUENCE, 0, 32 },
    { ::flatbuffers::ET_SEQUENCE, 0, 33 },
    { ::flatbuffers::ET_SEQUENCE, 0, 34 },
    { ::flatbuffers::ET_SEQUENCE, 0, 35 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    ImZeroFB::CmdRegisterFontTypeTable,
    ImZeroFB::CmdPolylineTypeTable,
    ImZeroFB::CmdConvexPolyFilledTypeTable,
    ImZeroFB::CmdLineTypeTable,
    ImZeroFB::CmdRectRoundedTypeTable,
    ImZeroFB::CmdRectRoundedCornersTypeTable,
    ImZeroFB::CmdRectRoundedFilledTypeTable,
    ImZeroFB::CmdRectRoundedCornersFilledTypeTable,
    ImZeroFB::CmdQuadTypeTable,
    ImZeroFB::CmdQuadFilledTypeTable,
    ImZeroFB::CmdTriangleTypeTable,
    ImZeroFB::CmdTriangleFilledTypeTable,
    ImZeroFB::CmdCircleTypeTable,
    ImZeroFB::CmdCircleFilledTypeTable,
    ImZeroFB::CmdNgonTypeTable,
    ImZeroFB::CmdNgonFilledTypeTable,
    ImZeroFB::CmdEllipseTypeTable,
    ImZeroFB::CmdEllipseFilledTypeTable,
    ImZeroFB::CmdBezierCubicTypeTable,
    ImZeroFB::CmdBezierQuadraticTypeTable,
    ImZeroFB::CmdImageTypeTable,
    ImZeroFB::CmdImageQuadTypeTable,
    ImZeroFB::CmdImageRoundedTypeTable,
    ImZeroFB::CmdPushClipRectTypeTable,
    ImZeroFB::CmdPopClipRectTypeTable,
    ImZeroFB::CmdRenderTextTypeTable,
    ImZeroFB::CmdRenderParagraphTypeTable,
    ImZeroFB::CmdRenderUnicodeCodepointTypeTable,
    ImZeroFB::CmdRectFilledMultiColorTypeTable,
    ImZeroFB::CmdWrappedDrawListTypeTable,
    ImZeroFB::CmdVertexDrawTypeTable,
    ImZeroFB::CmdPushRotationTypeTable,
    ImZeroFB::CmdPopRotationTypeTable,
    ImZeroFB::CmdSimpleVertexDrawTypeTable,
    ImZeroFB::CmdSvgPathSubsetTypeTable,
    ImZeroFB::CmdPathTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "CmdRegisterFont",
    "CmdPolyline",
    "CmdConvexPolyFilled",
    "CmdLine",
    "CmdRectRounded",
    "CmdRectRoundedCorners",
    "CmdRectRoundedFilled",
    "CmdRectRoundedCornersFilled",
    "CmdQuad",
    "CmdQuadFilled",
    "CmdTriangle",
    "CmdTriangleFilled",
    "CmdCircle",
    "CmdCircleFilled",
    "CmdNgon",
    "CmdNgonFilled",
    "CmdEllipse",
    "CmdEllipseFilled",
    "CmdBezierCubic",
    "CmdBezierQuadratic",
    "CmdImage",
    "CmdImageQuad",
    "CmdImageRounded",
    "CmdPushClipRect",
    "CmdPopClipRect",
    "CmdRenderText",
    "CmdRenderParagraph",
    "CmdRenderUnicodeCodepoint",
    "CmdRectFilledMultiColor",
    "CmdWrappedDrawList",
    "CmdVertexDraw",
    "CmdPushRotation",
    "CmdPopRotation",
    "CmdSimpleVertexDraw",
    "CmdSvgPathSubset",
    "CmdPath"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_UNION, 37, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *DrawListFlagsTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    ImZeroFB::DrawListFlagsTypeTable
  };
  static const int64_t values[] = { 0, 1, 2, 4, 8 };
  static const char * const names[] = {
    "None",
    "AntiAliasedLines",
    "AntiAliasedFill",
    "AntiAliasedText",
    "AntiAliasedClipping"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 5, type_codes, type_refs, nullptr, values, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *IoFlagsTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_USHORT, 0, 0 },
    { ::flatbuffers::ET_USHORT, 0, 0 },
    { ::flatbuffers::ET_USHORT, 0, 0 },
    { ::flatbuffers::ET_USHORT, 0, 0 },
    { ::flatbuffers::ET_USHORT, 0, 0 },
    { ::flatbuffers::ET_USHORT, 0, 0 },
    { ::flatbuffers::ET_USHORT, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    ImZeroFB::IoFlagsTypeTable
  };
  static const int64_t values[] = { 0, 1, 2, 4, 8, 16, 32 };
  static const char * const names[] = {
    "None",
    "WantCaptureMouse",
    "WantCaptureKeyboard",
    "WantTextInput",
    "WantSetMousePos",
    "NavIsActive",
    "NavIsVisible"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 7, type_codes, type_refs, nullptr, values, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *MouseButtonTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    ImZeroFB::MouseButtonTypeTable
  };
  static const char * const names[] = {
    "None",
    "Left",
    "Right",
    "Middle",
    "X1",
    "X2"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 6, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *MouseButtonEventTypeTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    ImZeroFB::MouseButtonEventTypeTypeTable
  };
  static const char * const names[] = {
    "Up",
    "Down"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *KeyModifiersTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    ImZeroFB::KeyModifiersTypeTable
  };
  static const int64_t values[] = { 0, 1, 2, 4, 8 };
  static const char * const names[] = {
    "None",
    "Ctrl",
    "Shift",
    "Alt",
    "Super"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 5, type_codes, type_refs, nullptr, values, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *KeyCodeTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    ImZeroFB::KeyCodeTypeTable
  };
  static const char * const names[] = {
    "Key_None",
    "Key_Tab",
    "Key_LeftArrow",
    "Key_RightArrow",
    "Key_UpArrow",
    "Key_DownArrow",
    "Key_PageUp",
    "Key_PageDown",
    "Key_Home",
    "Key_End",
    "Key_Insert",
    "Key_Delete",
    "Key_Backspace",
    "Key_Space",
    "Key_Enter",
    "Key_Escape",
    "Key_Apostrophe",
    "Key_Comma",
    "Key_Minus",
    "Key_Period",
    "Key_Slash",
    "Key_Semicolon",
    "Key_Equal",
    "Key_LeftBracket",
    "Key_Backslash",
    "Key_RightBracket",
    "Key_GraveAccent",
    "Key_CapsLock",
    "Key_ScrollLock",
    "Key_NumLock",
    "Key_PrintScreen",
    "Key_Pause",
    "Key_Keypad0",
    "Key_Keypad1",
    "Key_Keypad2",
    "Key_Keypad3",
    "Key_Keypad4",
    "Key_Keypad5",
    "Key_Keypad6",
    "Key_Keypad7",
    "Key_Keypad8",
    "Key_Keypad9",
    "Key_KeypadDecimal",
    "Key_KeypadDivide",
    "Key_KeypadMultiply",
    "Key_KeypadSubtract",
    "Key_KeypadAdd",
    "Key_KeypadEnter",
    "Key_KeypadEqual",
    "Key_LeftCtrl",
    "Key_LeftShift",
    "Key_LeftAlt",
    "Key_LeftSuper",
    "Key_RightCtrl",
    "Key_RightShift",
    "Key_RightAlt",
    "Key_RightSuper",
    "Key_Menu",
    "Key_0",
    "Key_1",
    "Key_2",
    "Key_3",
    "Key_4",
    "Key_5",
    "Key_6",
    "Key_7",
    "Key_8",
    "Key_9",
    "Key_A",
    "Key_B",
    "Key_C",
    "Key_D",
    "Key_E",
    "Key_F",
    "Key_G",
    "Key_H",
    "Key_I",
    "Key_J",
    "Key_K",
    "Key_L",
    "Key_M",
    "Key_N",
    "Key_O",
    "Key_P",
    "Key_Q",
    "Key_R",
    "Key_S",
    "Key_T",
    "Key_U",
    "Key_V",
    "Key_W",
    "Key_X",
    "Key_Y",
    "Key_Z",
    "Key_F1",
    "Key_F2",
    "Key_F3",
    "Key_F4",
    "Key_F5",
    "Key_F6",
    "Key_F7",
    "Key_F8",
    "Key_F9",
    "Key_F10",
    "Key_F11",
    "Key_F12",
    "Key_F13",
    "Key_F14",
    "Key_F15",
    "Key_F16",
    "Key_F17",
    "Key_F18",
    "Key_F19",
    "Key_F20",
    "Key_F21",
    "Key_F22",
    "Key_F23",
    "Key_F24",
    "Key_AppBack",
    "Key_AppForward"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 120, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *UserInteractionTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 2 },
    { ::flatbuffers::ET_SEQUENCE, 0, 3 },
    { ::flatbuffers::ET_SEQUENCE, 0, 4 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    ImZeroFB::EventMouseMotionTypeTable,
    ImZeroFB::EventMouseWheelTypeTable,
    ImZeroFB::EventMouseButtonTypeTable,
    ImZeroFB::EventTextInputTypeTable,
    ImZeroFB::EventKeyboardTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "EventMouseMotion",
    "EventMouseWheel",
    "EventMouseButton",
    "EventTextInput",
    "EventKeyboard"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_UNION, 6, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *SingleVec2TypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const int64_t values[] = { 0, 4, 8 };
  static const char * const names[] = {
    "x",
    "y"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_STRUCT, 2, type_codes, nullptr, nullptr, values, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *SingleVec4TypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const int64_t values[] = { 0, 4, 8, 12, 16 };
  static const char * const names[] = {
    "x",
    "y",
    "z",
    "w"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_STRUCT, 4, type_codes, nullptr, nullptr, values, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ArrayOfVec2TypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_FLOAT, 1, -1 },
    { ::flatbuffers::ET_FLOAT, 1, -1 }
  };
  static const char * const names[] = {
    "xs",
    "ys"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ArrayOfVec4TypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_FLOAT, 1, -1 },
    { ::flatbuffers::ET_FLOAT, 1, -1 },
    { ::flatbuffers::ET_FLOAT, 1, -1 },
    { ::flatbuffers::ET_FLOAT, 1, -1 }
  };
  static const char * const names[] = {
    "xs",
    "ys",
    "zs",
    "ws"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *CmdRegisterFontTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "name",
    "url",
    "subpixel"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *CmdPolylineTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    ImZeroFB::ArrayOfVec2TypeTable
  };
  static const char * const names[] = {
    "points",
    "col",
    "flags",
    "thickness"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *CmdConvexPolyFilledTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    ImZeroFB::ArrayOfVec2TypeTable
  };
  static const char * const names[] = {
    "points",
    "col"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *CmdLineTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    ImZeroFB::SingleVec2TypeTable
  };
  static const char * const names[] = {
    "p1",
    "p2",
    "col",
    "thickness"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *CmdRectRoundedTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    ImZeroFB::SingleVec2TypeTable
  };
  static const char * const names[] = {
    "p_min",
    "p_max",
    "col",
    "rounding",
    "thickness"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *CmdRectRoundedCornersTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    ImZeroFB::SingleVec2TypeTable
  };
  static const char * const names[] = {
    "p_min",
    "p_max",
    "col",
    "rounding_top_left",
    "rounding_top_right",
    "rounding_bottom_right",
    "rounding_bottom_left",
    "thickness"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 8, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *CmdRectRoundedFilledTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    ImZeroFB::SingleVec2TypeTable
  };
  static const char * const names[] = {
    "p_min",
    "p_max",
    "col",
    "rounding"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *CmdRectRoundedCornersFilledTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    ImZeroFB::SingleVec2TypeTable
  };
  static const char * const names[] = {
    "p_min",
    "p_max",
    "col",
    "rounding_top_left",
    "rounding_top_right",
    "rounding_bottom_right",
    "rounding_bottom_left"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 7, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *CmdQuadTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    ImZeroFB::SingleVec2TypeTable
  };
  static const char * const names[] = {
    "p1",
    "p2",
    "p3",
    "p4",
    "col",
    "thickness"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *CmdQuadFilledTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    ImZeroFB::SingleVec2TypeTable
  };
  static const char * const names[] = {
    "p1",
    "p2",
    "p3",
    "p4",
    "col"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *CmdTriangleTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    ImZeroFB::SingleVec2TypeTable
  };
  static const char * const names[] = {
    "p1",
    "p2",
    "p3",
    "col",
    "thickness"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *CmdTriangleFilledTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    ImZeroFB::SingleVec2TypeTable
  };
  static const char * const names[] = {
    "p1",
    "p2",
    "p3",
    "col"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *CmdCircleTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    ImZeroFB::SingleVec2TypeTable
  };
  static const char * const names[] = {
    "center",
    "radius",
    "col",
    "num_segments",
    "thickness"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *CmdCircleFilledTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    ImZeroFB::SingleVec2TypeTable
  };
  static const char * const names[] = {
    "center",
    "radius",
    "col",
    "num_segments"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *CmdNgonTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    ImZeroFB::SingleVec2TypeTable
  };
  static const char * const names[] = {
    "center",
    "radius",
    "col",
    "num_segments",
    "thickness"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *CmdNgonFilledTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    ImZeroFB::SingleVec2TypeTable
  };
  static const char * const names[] = {
    "center",
    "radius",
    "col",
    "num_segments"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *CmdEllipseTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    ImZeroFB::SingleVec2TypeTable
  };
  static const char * const names[] = {
    "center",
    "radius",
    "col",
    "rot",
    "num_segments",
    "thickness"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *CmdEllipseFilledTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    ImZeroFB::SingleVec2TypeTable
  };
  static const char * const names[] = {
    "center",
    "radius",
    "col",
    "rot",
    "num_segments"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *CmdBezierCubicTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    ImZeroFB::SingleVec2TypeTable
  };
  static const char * const names[] = {
    "p1",
    "p2",
    "p3",
    "p4",
    "col",
    "thickness",
    "num_segments"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 7, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *CmdBezierQuadraticTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    ImZeroFB::SingleVec2TypeTable
  };
  static const char * const names[] = {
    "p1",
    "p2",
    "p3",
    "col",
    "thickness",
    "num_segments"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *CmdImageTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_ULONG, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    ImZeroFB::SingleVec2TypeTable
  };
  static const char * const names[] = {
    "user_texture_id",
    "p_min",
    "p_max",
    "uv_min",
    "uv_max",
    "col"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *CmdImageQuadTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_ULONG, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    ImZeroFB::SingleVec2TypeTable
  };
  static const char * const names[] = {
    "user_texture_id",
    "p1",
    "p2",
    "p3",
    "p4",
    "uv1",
    "uv2",
    "uv3",
    "uv4",
    "col"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 10, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *CmdImageRoundedTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_ULONG, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    ImZeroFB::SingleVec2TypeTable
  };
  static const char * const names[] = {
    "user_texture_id",
    "p_min",
    "p_max",
    "uv_min",
    "uv_max",
    "col",
    "rounding",
    "flags"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 8, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *CmdPushClipRectTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_BOOL, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    ImZeroFB::SingleVec4TypeTable
  };
  static const char * const names[] = {
    "rect",
    "intersected_with_current_clip_rect"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *CmdPopClipRectTypeTable() {
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *CmdRenderTextTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_ULONG, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 },
    { ::flatbuffers::ET_STRING, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    ImZeroFB::SingleVec2TypeTable,
    ImZeroFB::SingleVec4TypeTable
  };
  static const char * const names[] = {
    "imfont",
    "size",
    "pos",
    "col",
    "clip_rect",
    "text"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *CmdRenderParagraphTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_ULONG, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_UCHAR, 0, 2 },
    { ::flatbuffers::ET_UCHAR, 0, 3 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    ImZeroFB::SingleVec2TypeTable,
    ImZeroFB::SingleVec4TypeTable,
    ImZeroFB::TextAlignFlagsTypeTable,
    ImZeroFB::TextDirectionTypeTable
  };
  static const char * const names[] = {
    "imfont",
    "size",
    "pos",
    "col",
    "clip_rect",
    "text",
    "wrap_width",
    "letter_spacing",
    "text_align",
    "text_direction"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 10, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *CmdRenderUnicodeCodepointTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_ULONG, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 },
    { ::flatbuffers::ET_UINT, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    ImZeroFB::SingleVec2TypeTable,
    ImZeroFB::SingleVec4TypeTable
  };
  static const char * const names[] = {
    "imfont",
    "size",
    "pos",
    "col",
    "clip_rect",
    "codepoint"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *CmdTranslationTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    ImZeroFB::SingleVec2TypeTable
  };
  static const char * const names[] = {
    "translation"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *PopTranslationTypeTable() {
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *CmdPushRotationTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "cos_alpha",
    "sin_alpha"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *CmdPopRotationTypeTable() {
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *CmdRectFilledMultiColorTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    ImZeroFB::SingleVec2TypeTable
  };
  static const char * const names[] = {
    "p_min",
    "p_max",
    "col_upr_left",
    "col_upr_right",
    "col_bot_right",
    "col_bot_left"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *CmdWrappedDrawListTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UCHAR, 1, -1 }
  };
  static const char * const names[] = {
    "buffer"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *CmdVertexDrawTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    ImZeroFB::SingleVec4TypeTable
  };
  static const char * const names[] = {
    "clip_rect",
    "element_count",
    "index_offset",
    "vtx_offset"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *CmdSimpleVertexDrawTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_FLOAT, 1, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    ImZeroFB::SingleVec4TypeTable
  };
  static const char * const names[] = {
    "clip_rect",
    "pos_xy",
    "col"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *CmdSvgPathSubsetTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "svg",
    "col",
    "stroke",
    "fill"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *CmdPathTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 1, 1 },
    { ::flatbuffers::ET_FLOAT, 1, -1 },
    { ::flatbuffers::ET_FLOAT, 1, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_UCHAR, 0, 2 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    ImZeroFB::SingleVec2TypeTable,
    ImZeroFB::PathVerbTypeTable,
    ImZeroFB::PathFillTypeTypeTable
  };
  static const char * const names[] = {
    "offset",
    "verbs",
    "points_xy",
    "conic_weights",
    "col",
    "stroke",
    "fill",
    "fill_type"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 8, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *SingleVectorCmdDtoTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UTYPE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    ImZeroFB::VectorCmdArgTypeTable
  };
  static const char * const names[] = {
    "arg_type",
    "arg"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *VertexDataTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_FLOAT, 1, -1 },
    { ::flatbuffers::ET_FLOAT, 1, -1 },
    { ::flatbuffers::ET_UINT, 1, -1 },
    { ::flatbuffers::ET_USHORT, 1, -1 }
  };
  static const char * const names[] = {
    "pos_xy",
    "texture_uv",
    "col",
    "indices"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *DrawListTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 2 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    ImZeroFB::DrawListFlagsTypeTable,
    ImZeroFB::VertexDataTypeTable,
    ImZeroFB::SingleVectorCmdDtoTypeTable
  };
  static const char * const names[] = {
    "flags",
    "name",
    "vertices",
    "cmds"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *IoRecordTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_USHORT, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    ImZeroFB::IoFlagsTypeTable
  };
  static const char * const names[] = {
    "flags"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *EventMouseMotionTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    ImZeroFB::SingleVec2TypeTable
  };
  static const char * const names[] = {
    "pos",
    "mouse_id",
    "is_touch"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *EventMouseWheelTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    ImZeroFB::SingleVec2TypeTable
  };
  static const char * const names[] = {
    "pos",
    "mouse_id",
    "is_touch"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *EventMouseButtonTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_UCHAR, 0, 1 },
    { ::flatbuffers::ET_UCHAR, 0, 2 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    ImZeroFB::SingleVec2TypeTable,
    ImZeroFB::MouseButtonTypeTable,
    ImZeroFB::MouseButtonEventTypeTypeTable
  };
  static const char * const names[] = {
    "pos",
    "mouse_id",
    "is_touch",
    "button",
    "type"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *EventTextInputTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "text"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *EventKeyboardTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 1 },
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    ImZeroFB::KeyModifiersTypeTable,
    ImZeroFB::KeyCodeTypeTable
  };
  static const char * const names[] = {
    "modifiers",
    "code",
    "is_down",
    "native_sym",
    "scancode"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *InputEventTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UTYPE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    ImZeroFB::UserInteractionTypeTable
  };
  static const char * const names[] = {
    "event_type",
    "event"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ImZeroFB::DrawList *GetDrawList(const void *buf) {
  return ::flatbuffers::GetRoot<ImZeroFB::DrawList>(buf);
}

inline const ImZeroFB::DrawList *GetSizePrefixedDrawList(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<ImZeroFB::DrawList>(buf);
}

inline bool VerifyDrawListBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ImZeroFB::DrawList>(nullptr);
}

inline bool VerifySizePrefixedDrawListBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ImZeroFB::DrawList>(nullptr);
}

inline void FinishDrawListBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<ImZeroFB::DrawList> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedDrawListBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<ImZeroFB::DrawList> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace ImZeroFB

#endif  // FLATBUFFERS_GENERATED_IMZEROFB_IMZEROFB_H_
