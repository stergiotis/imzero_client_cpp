// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_VECTORCMD_VECTORCMDFB_H_
#define FLATBUFFERS_GENERATED_VECTORCMD_VECTORCMDFB_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

namespace VectorCmdFB {

struct SingleVec2;

struct SingleVec4;

struct ArrayOfVec2;
struct ArrayOfVec2Builder;

struct ArrayOfVec4;
struct ArrayOfVec4Builder;

struct CmdRegisterFont;
struct CmdRegisterFontBuilder;

struct CmdPolyline;
struct CmdPolylineBuilder;

struct CmdConvexPolyFilled;
struct CmdConvexPolyFilledBuilder;

struct CmdLine;
struct CmdLineBuilder;

struct CmdRectRounded;
struct CmdRectRoundedBuilder;

struct CmdRectRoundedCorners;
struct CmdRectRoundedCornersBuilder;

struct CmdRectRoundedFilled;
struct CmdRectRoundedFilledBuilder;

struct CmdRectRoundedCornersFilled;
struct CmdRectRoundedCornersFilledBuilder;

struct CmdQuad;
struct CmdQuadBuilder;

struct CmdQuadFilled;
struct CmdQuadFilledBuilder;

struct CmdTriangle;
struct CmdTriangleBuilder;

struct CmdTriangleFilled;
struct CmdTriangleFilledBuilder;

struct CmdCircle;
struct CmdCircleBuilder;

struct CmdCircleFilled;
struct CmdCircleFilledBuilder;

struct CmdNgon;
struct CmdNgonBuilder;

struct CmdNgonFilled;
struct CmdNgonFilledBuilder;

struct CmdEllipse;
struct CmdEllipseBuilder;

struct CmdEllipseFilled;
struct CmdEllipseFilledBuilder;

struct CmdBezierCubic;
struct CmdBezierCubicBuilder;

struct CmdBezierQuadratic;
struct CmdBezierQuadraticBuilder;

struct CmdImage;
struct CmdImageBuilder;

struct CmdImageQuad;
struct CmdImageQuadBuilder;

struct CmdImageRounded;
struct CmdImageRoundedBuilder;

struct CmdPushClipRect;
struct CmdPushClipRectBuilder;

struct CmdPopClipRect;
struct CmdPopClipRectBuilder;

struct CmdRenderText;
struct CmdRenderTextBuilder;

struct CmdRenderParagraph;
struct CmdRenderParagraphBuilder;

struct CmdRenderUnicodeCodepoint;
struct CmdRenderUnicodeCodepointBuilder;

struct CmdTranslation;
struct CmdTranslationBuilder;

struct PopTranslation;
struct PopTranslationBuilder;

struct CmdPushRotation;
struct CmdPushRotationBuilder;

struct CmdPopRotation;
struct CmdPopRotationBuilder;

struct CmdRectFilledMultiColor;
struct CmdRectFilledMultiColorBuilder;

struct CmdWrappedDrawList;
struct CmdWrappedDrawListBuilder;

struct CmdVertexDraw;
struct CmdVertexDrawBuilder;

struct CmdSimpleVertexDraw;
struct CmdSimpleVertexDrawBuilder;

struct CmdSvgPathSubset;
struct CmdSvgPathSubsetBuilder;

struct CmdPath;
struct CmdPathBuilder;

struct SingleVectorCmdDto;
struct SingleVectorCmdDtoBuilder;

struct VertexData;
struct VertexDataBuilder;

struct DrawList;
struct DrawListBuilder;

struct IoRecord;
struct IoRecordBuilder;

enum TextAlignFlags : uint8_t {
  TextAlignFlags_left = 0,
  TextAlignFlags_right = 1,
  TextAlignFlags_center = 2,
  TextAlignFlags_justify = 3,
  TextAlignFlags_MIN = TextAlignFlags_left,
  TextAlignFlags_MAX = TextAlignFlags_justify
};

inline const TextAlignFlags (&EnumValuesTextAlignFlags())[4] {
  static const TextAlignFlags values[] = {
    TextAlignFlags_left,
    TextAlignFlags_right,
    TextAlignFlags_center,
    TextAlignFlags_justify
  };
  return values;
}

inline const char * const *EnumNamesTextAlignFlags() {
  static const char * const names[5] = {
    "left",
    "right",
    "center",
    "justify",
    nullptr
  };
  return names;
}

inline const char *EnumNameTextAlignFlags(TextAlignFlags e) {
  if (::flatbuffers::IsOutRange(e, TextAlignFlags_left, TextAlignFlags_justify)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTextAlignFlags()[index];
}

enum PathVerb : uint8_t {
  PathVerb_move = 0,
  PathVerb_line = 1,
  PathVerb_quad = 2,
  PathVerb_conic = 3,
  PathVerb_cubic = 4,
  PathVerb_close = 5,
  PathVerb_done = 6,
  PathVerb_MIN = PathVerb_move,
  PathVerb_MAX = PathVerb_done
};

inline const PathVerb (&EnumValuesPathVerb())[7] {
  static const PathVerb values[] = {
    PathVerb_move,
    PathVerb_line,
    PathVerb_quad,
    PathVerb_conic,
    PathVerb_cubic,
    PathVerb_close,
    PathVerb_done
  };
  return values;
}

inline const char * const *EnumNamesPathVerb() {
  static const char * const names[8] = {
    "move",
    "line",
    "quad",
    "conic",
    "cubic",
    "close",
    "done",
    nullptr
  };
  return names;
}

inline const char *EnumNamePathVerb(PathVerb e) {
  if (::flatbuffers::IsOutRange(e, PathVerb_move, PathVerb_done)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPathVerb()[index];
}

enum PathFillType : uint8_t {
  PathFillType_winding = 0,
  PathFillType_evenOdd = 1,
  PathFillType_inverseWinding = 2,
  PathFillType_inverseEvenOdd = 3,
  PathFillType_MIN = PathFillType_winding,
  PathFillType_MAX = PathFillType_inverseEvenOdd
};

inline const PathFillType (&EnumValuesPathFillType())[4] {
  static const PathFillType values[] = {
    PathFillType_winding,
    PathFillType_evenOdd,
    PathFillType_inverseWinding,
    PathFillType_inverseEvenOdd
  };
  return values;
}

inline const char * const *EnumNamesPathFillType() {
  static const char * const names[5] = {
    "winding",
    "evenOdd",
    "inverseWinding",
    "inverseEvenOdd",
    nullptr
  };
  return names;
}

inline const char *EnumNamePathFillType(PathFillType e) {
  if (::flatbuffers::IsOutRange(e, PathFillType_winding, PathFillType_inverseEvenOdd)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPathFillType()[index];
}

enum VectorCmdArg : uint8_t {
  VectorCmdArg_NONE = 0,
  VectorCmdArg_CmdRegisterFont = 1,
  VectorCmdArg_CmdPolyline = 2,
  VectorCmdArg_CmdConvexPolyFilled = 3,
  VectorCmdArg_CmdLine = 4,
  VectorCmdArg_CmdRectRounded = 5,
  VectorCmdArg_CmdRectRoundedCorners = 6,
  VectorCmdArg_CmdRectRoundedFilled = 7,
  VectorCmdArg_CmdRectRoundedCornersFilled = 8,
  VectorCmdArg_CmdQuad = 9,
  VectorCmdArg_CmdQuadFilled = 10,
  VectorCmdArg_CmdTriangle = 11,
  VectorCmdArg_CmdTriangleFilled = 12,
  VectorCmdArg_CmdCircle = 13,
  VectorCmdArg_CmdCircleFilled = 14,
  VectorCmdArg_CmdNgon = 15,
  VectorCmdArg_CmdNgonFilled = 16,
  VectorCmdArg_CmdEllipse = 17,
  VectorCmdArg_CmdEllipseFilled = 18,
  VectorCmdArg_CmdBezierCubic = 19,
  VectorCmdArg_CmdBezierQuadratic = 20,
  VectorCmdArg_CmdImage = 21,
  VectorCmdArg_CmdImageQuad = 22,
  VectorCmdArg_CmdImageRounded = 23,
  VectorCmdArg_CmdPushClipRect = 24,
  VectorCmdArg_CmdPopClipRect = 25,
  VectorCmdArg_CmdRenderText = 26,
  VectorCmdArg_CmdRenderParagraph = 27,
  VectorCmdArg_CmdRenderUnicodeCodepoint = 28,
  VectorCmdArg_CmdRectFilledMultiColor = 29,
  VectorCmdArg_CmdWrappedDrawList = 30,
  VectorCmdArg_CmdVertexDraw = 31,
  VectorCmdArg_CmdPushRotation = 32,
  VectorCmdArg_CmdPopRotation = 33,
  VectorCmdArg_CmdSimpleVertexDraw = 34,
  VectorCmdArg_CmdSvgPathSubset = 35,
  VectorCmdArg_CmdPath = 36,
  VectorCmdArg_MIN = VectorCmdArg_NONE,
  VectorCmdArg_MAX = VectorCmdArg_CmdPath
};

inline const VectorCmdArg (&EnumValuesVectorCmdArg())[37] {
  static const VectorCmdArg values[] = {
    VectorCmdArg_NONE,
    VectorCmdArg_CmdRegisterFont,
    VectorCmdArg_CmdPolyline,
    VectorCmdArg_CmdConvexPolyFilled,
    VectorCmdArg_CmdLine,
    VectorCmdArg_CmdRectRounded,
    VectorCmdArg_CmdRectRoundedCorners,
    VectorCmdArg_CmdRectRoundedFilled,
    VectorCmdArg_CmdRectRoundedCornersFilled,
    VectorCmdArg_CmdQuad,
    VectorCmdArg_CmdQuadFilled,
    VectorCmdArg_CmdTriangle,
    VectorCmdArg_CmdTriangleFilled,
    VectorCmdArg_CmdCircle,
    VectorCmdArg_CmdCircleFilled,
    VectorCmdArg_CmdNgon,
    VectorCmdArg_CmdNgonFilled,
    VectorCmdArg_CmdEllipse,
    VectorCmdArg_CmdEllipseFilled,
    VectorCmdArg_CmdBezierCubic,
    VectorCmdArg_CmdBezierQuadratic,
    VectorCmdArg_CmdImage,
    VectorCmdArg_CmdImageQuad,
    VectorCmdArg_CmdImageRounded,
    VectorCmdArg_CmdPushClipRect,
    VectorCmdArg_CmdPopClipRect,
    VectorCmdArg_CmdRenderText,
    VectorCmdArg_CmdRenderParagraph,
    VectorCmdArg_CmdRenderUnicodeCodepoint,
    VectorCmdArg_CmdRectFilledMultiColor,
    VectorCmdArg_CmdWrappedDrawList,
    VectorCmdArg_CmdVertexDraw,
    VectorCmdArg_CmdPushRotation,
    VectorCmdArg_CmdPopRotation,
    VectorCmdArg_CmdSimpleVertexDraw,
    VectorCmdArg_CmdSvgPathSubset,
    VectorCmdArg_CmdPath
  };
  return values;
}

inline const char * const *EnumNamesVectorCmdArg() {
  static const char * const names[38] = {
    "NONE",
    "CmdRegisterFont",
    "CmdPolyline",
    "CmdConvexPolyFilled",
    "CmdLine",
    "CmdRectRounded",
    "CmdRectRoundedCorners",
    "CmdRectRoundedFilled",
    "CmdRectRoundedCornersFilled",
    "CmdQuad",
    "CmdQuadFilled",
    "CmdTriangle",
    "CmdTriangleFilled",
    "CmdCircle",
    "CmdCircleFilled",
    "CmdNgon",
    "CmdNgonFilled",
    "CmdEllipse",
    "CmdEllipseFilled",
    "CmdBezierCubic",
    "CmdBezierQuadratic",
    "CmdImage",
    "CmdImageQuad",
    "CmdImageRounded",
    "CmdPushClipRect",
    "CmdPopClipRect",
    "CmdRenderText",
    "CmdRenderParagraph",
    "CmdRenderUnicodeCodepoint",
    "CmdRectFilledMultiColor",
    "CmdWrappedDrawList",
    "CmdVertexDraw",
    "CmdPushRotation",
    "CmdPopRotation",
    "CmdSimpleVertexDraw",
    "CmdSvgPathSubset",
    "CmdPath",
    nullptr
  };
  return names;
}

inline const char *EnumNameVectorCmdArg(VectorCmdArg e) {
  if (::flatbuffers::IsOutRange(e, VectorCmdArg_NONE, VectorCmdArg_CmdPath)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesVectorCmdArg()[index];
}

template<typename T> struct VectorCmdArgTraits {
  static const VectorCmdArg enum_value = VectorCmdArg_NONE;
};

template<> struct VectorCmdArgTraits<VectorCmdFB::CmdRegisterFont> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdRegisterFont;
};

template<> struct VectorCmdArgTraits<VectorCmdFB::CmdPolyline> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdPolyline;
};

template<> struct VectorCmdArgTraits<VectorCmdFB::CmdConvexPolyFilled> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdConvexPolyFilled;
};

template<> struct VectorCmdArgTraits<VectorCmdFB::CmdLine> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdLine;
};

template<> struct VectorCmdArgTraits<VectorCmdFB::CmdRectRounded> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdRectRounded;
};

template<> struct VectorCmdArgTraits<VectorCmdFB::CmdRectRoundedCorners> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdRectRoundedCorners;
};

template<> struct VectorCmdArgTraits<VectorCmdFB::CmdRectRoundedFilled> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdRectRoundedFilled;
};

template<> struct VectorCmdArgTraits<VectorCmdFB::CmdRectRoundedCornersFilled> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdRectRoundedCornersFilled;
};

template<> struct VectorCmdArgTraits<VectorCmdFB::CmdQuad> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdQuad;
};

template<> struct VectorCmdArgTraits<VectorCmdFB::CmdQuadFilled> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdQuadFilled;
};

template<> struct VectorCmdArgTraits<VectorCmdFB::CmdTriangle> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdTriangle;
};

template<> struct VectorCmdArgTraits<VectorCmdFB::CmdTriangleFilled> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdTriangleFilled;
};

template<> struct VectorCmdArgTraits<VectorCmdFB::CmdCircle> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdCircle;
};

template<> struct VectorCmdArgTraits<VectorCmdFB::CmdCircleFilled> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdCircleFilled;
};

template<> struct VectorCmdArgTraits<VectorCmdFB::CmdNgon> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdNgon;
};

template<> struct VectorCmdArgTraits<VectorCmdFB::CmdNgonFilled> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdNgonFilled;
};

template<> struct VectorCmdArgTraits<VectorCmdFB::CmdEllipse> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdEllipse;
};

template<> struct VectorCmdArgTraits<VectorCmdFB::CmdEllipseFilled> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdEllipseFilled;
};

template<> struct VectorCmdArgTraits<VectorCmdFB::CmdBezierCubic> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdBezierCubic;
};

template<> struct VectorCmdArgTraits<VectorCmdFB::CmdBezierQuadratic> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdBezierQuadratic;
};

template<> struct VectorCmdArgTraits<VectorCmdFB::CmdImage> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdImage;
};

template<> struct VectorCmdArgTraits<VectorCmdFB::CmdImageQuad> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdImageQuad;
};

template<> struct VectorCmdArgTraits<VectorCmdFB::CmdImageRounded> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdImageRounded;
};

template<> struct VectorCmdArgTraits<VectorCmdFB::CmdPushClipRect> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdPushClipRect;
};

template<> struct VectorCmdArgTraits<VectorCmdFB::CmdPopClipRect> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdPopClipRect;
};

template<> struct VectorCmdArgTraits<VectorCmdFB::CmdRenderText> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdRenderText;
};

template<> struct VectorCmdArgTraits<VectorCmdFB::CmdRenderParagraph> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdRenderParagraph;
};

template<> struct VectorCmdArgTraits<VectorCmdFB::CmdRenderUnicodeCodepoint> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdRenderUnicodeCodepoint;
};

template<> struct VectorCmdArgTraits<VectorCmdFB::CmdRectFilledMultiColor> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdRectFilledMultiColor;
};

template<> struct VectorCmdArgTraits<VectorCmdFB::CmdWrappedDrawList> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdWrappedDrawList;
};

template<> struct VectorCmdArgTraits<VectorCmdFB::CmdVertexDraw> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdVertexDraw;
};

template<> struct VectorCmdArgTraits<VectorCmdFB::CmdPushRotation> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdPushRotation;
};

template<> struct VectorCmdArgTraits<VectorCmdFB::CmdPopRotation> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdPopRotation;
};

template<> struct VectorCmdArgTraits<VectorCmdFB::CmdSimpleVertexDraw> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdSimpleVertexDraw;
};

template<> struct VectorCmdArgTraits<VectorCmdFB::CmdSvgPathSubset> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdSvgPathSubset;
};

template<> struct VectorCmdArgTraits<VectorCmdFB::CmdPath> {
  static const VectorCmdArg enum_value = VectorCmdArg_CmdPath;
};

bool VerifyVectorCmdArg(::flatbuffers::Verifier &verifier, const void *obj, VectorCmdArg type);
bool VerifyVectorCmdArgVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum DrawListFlags : uint8_t {
  DrawListFlags_None = 0,
  DrawListFlags_AntiAliasedLines = 1,
  DrawListFlags_AntiAliasedFill = 2,
  DrawListFlags_AntiAliasedText = 4,
  DrawListFlags_AntiAliasedClipping = 8,
  DrawListFlags_MIN = DrawListFlags_None,
  DrawListFlags_MAX = DrawListFlags_AntiAliasedClipping
};

inline const DrawListFlags (&EnumValuesDrawListFlags())[5] {
  static const DrawListFlags values[] = {
    DrawListFlags_None,
    DrawListFlags_AntiAliasedLines,
    DrawListFlags_AntiAliasedFill,
    DrawListFlags_AntiAliasedText,
    DrawListFlags_AntiAliasedClipping
  };
  return values;
}

inline const char * const *EnumNamesDrawListFlags() {
  static const char * const names[10] = {
    "None",
    "AntiAliasedLines",
    "AntiAliasedFill",
    "",
    "AntiAliasedText",
    "",
    "",
    "",
    "AntiAliasedClipping",
    nullptr
  };
  return names;
}

inline const char *EnumNameDrawListFlags(DrawListFlags e) {
  if (::flatbuffers::IsOutRange(e, DrawListFlags_None, DrawListFlags_AntiAliasedClipping)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDrawListFlags()[index];
}

enum IoFlags : uint16_t {
  IoFlags_None = 0,
  IoFlags_WantCaptureMouse = 1,
  IoFlags_WantCaptureKeyboard = 2,
  IoFlags_WantTextInput = 4,
  IoFlags_WantSetMousePos = 8,
  IoFlags_NavIsActive = 16,
  IoFlags_NavIsVisible = 32,
  IoFlags_MIN = IoFlags_None,
  IoFlags_MAX = IoFlags_NavIsVisible
};

inline const IoFlags (&EnumValuesIoFlags())[7] {
  static const IoFlags values[] = {
    IoFlags_None,
    IoFlags_WantCaptureMouse,
    IoFlags_WantCaptureKeyboard,
    IoFlags_WantTextInput,
    IoFlags_WantSetMousePos,
    IoFlags_NavIsActive,
    IoFlags_NavIsVisible
  };
  return values;
}

inline const char * const *EnumNamesIoFlags() {
  static const char * const names[34] = {
    "None",
    "WantCaptureMouse",
    "WantCaptureKeyboard",
    "",
    "WantTextInput",
    "",
    "",
    "",
    "WantSetMousePos",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "NavIsActive",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "NavIsVisible",
    nullptr
  };
  return names;
}

inline const char *EnumNameIoFlags(IoFlags e) {
  if (::flatbuffers::IsOutRange(e, IoFlags_None, IoFlags_NavIsVisible)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesIoFlags()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) SingleVec2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  SingleVec2()
      : x_(0),
        y_(0) {
  }
  SingleVec2(float _x, float _y)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(SingleVec2, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) SingleVec4 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  SingleVec4()
      : x_(0),
        y_(0),
        z_(0),
        w_(0) {
  }
  SingleVec4(float _x, float _y, float _z, float _w)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)),
        z_(::flatbuffers::EndianScalar(_z)),
        w_(::flatbuffers::EndianScalar(_w)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return ::flatbuffers::EndianScalar(z_);
  }
  float w() const {
    return ::flatbuffers::EndianScalar(w_);
  }
};
FLATBUFFERS_STRUCT_END(SingleVec4, 16);

struct ArrayOfVec2 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ArrayOfVec2Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_XS = 4,
    VT_YS = 6
  };
  const ::flatbuffers::Vector<float> *xs() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_XS);
  }
  const ::flatbuffers::Vector<float> *ys() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_YS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_XS) &&
           verifier.VerifyVector(xs()) &&
           VerifyOffset(verifier, VT_YS) &&
           verifier.VerifyVector(ys()) &&
           verifier.EndTable();
  }
};

struct ArrayOfVec2Builder {
  typedef ArrayOfVec2 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_xs(::flatbuffers::Offset<::flatbuffers::Vector<float>> xs) {
    fbb_.AddOffset(ArrayOfVec2::VT_XS, xs);
  }
  void add_ys(::flatbuffers::Offset<::flatbuffers::Vector<float>> ys) {
    fbb_.AddOffset(ArrayOfVec2::VT_YS, ys);
  }
  explicit ArrayOfVec2Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ArrayOfVec2> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ArrayOfVec2>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ArrayOfVec2> CreateArrayOfVec2(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> xs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> ys = 0) {
  ArrayOfVec2Builder builder_(_fbb);
  builder_.add_ys(ys);
  builder_.add_xs(xs);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ArrayOfVec2> CreateArrayOfVec2Direct(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *xs = nullptr,
    const std::vector<float> *ys = nullptr) {
  auto xs__ = xs ? _fbb.CreateVector<float>(*xs) : 0;
  auto ys__ = ys ? _fbb.CreateVector<float>(*ys) : 0;
  return VectorCmdFB::CreateArrayOfVec2(
      _fbb,
      xs__,
      ys__);
}

struct ArrayOfVec4 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ArrayOfVec4Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_XS = 4,
    VT_YS = 6,
    VT_ZS = 8,
    VT_WS = 10
  };
  const ::flatbuffers::Vector<float> *xs() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_XS);
  }
  const ::flatbuffers::Vector<float> *ys() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_YS);
  }
  const ::flatbuffers::Vector<float> *zs() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_ZS);
  }
  const ::flatbuffers::Vector<float> *ws() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_WS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_XS) &&
           verifier.VerifyVector(xs()) &&
           VerifyOffset(verifier, VT_YS) &&
           verifier.VerifyVector(ys()) &&
           VerifyOffset(verifier, VT_ZS) &&
           verifier.VerifyVector(zs()) &&
           VerifyOffset(verifier, VT_WS) &&
           verifier.VerifyVector(ws()) &&
           verifier.EndTable();
  }
};

struct ArrayOfVec4Builder {
  typedef ArrayOfVec4 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_xs(::flatbuffers::Offset<::flatbuffers::Vector<float>> xs) {
    fbb_.AddOffset(ArrayOfVec4::VT_XS, xs);
  }
  void add_ys(::flatbuffers::Offset<::flatbuffers::Vector<float>> ys) {
    fbb_.AddOffset(ArrayOfVec4::VT_YS, ys);
  }
  void add_zs(::flatbuffers::Offset<::flatbuffers::Vector<float>> zs) {
    fbb_.AddOffset(ArrayOfVec4::VT_ZS, zs);
  }
  void add_ws(::flatbuffers::Offset<::flatbuffers::Vector<float>> ws) {
    fbb_.AddOffset(ArrayOfVec4::VT_WS, ws);
  }
  explicit ArrayOfVec4Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ArrayOfVec4> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ArrayOfVec4>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ArrayOfVec4> CreateArrayOfVec4(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> xs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> ys = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> zs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> ws = 0) {
  ArrayOfVec4Builder builder_(_fbb);
  builder_.add_ws(ws);
  builder_.add_zs(zs);
  builder_.add_ys(ys);
  builder_.add_xs(xs);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ArrayOfVec4> CreateArrayOfVec4Direct(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *xs = nullptr,
    const std::vector<float> *ys = nullptr,
    const std::vector<float> *zs = nullptr,
    const std::vector<float> *ws = nullptr) {
  auto xs__ = xs ? _fbb.CreateVector<float>(*xs) : 0;
  auto ys__ = ys ? _fbb.CreateVector<float>(*ys) : 0;
  auto zs__ = zs ? _fbb.CreateVector<float>(*zs) : 0;
  auto ws__ = ws ? _fbb.CreateVector<float>(*ws) : 0;
  return VectorCmdFB::CreateArrayOfVec4(
      _fbb,
      xs__,
      ys__,
      zs__,
      ws__);
}

struct CmdRegisterFont FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdRegisterFontBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_URL = 6,
    VT_SUBPIXEL = 8
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *url() const {
    return GetPointer<const ::flatbuffers::String *>(VT_URL);
  }
  bool subpixel() const {
    return GetField<uint8_t>(VT_SUBPIXEL, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_URL) &&
           verifier.VerifyString(url()) &&
           VerifyField<uint8_t>(verifier, VT_SUBPIXEL, 1) &&
           verifier.EndTable();
  }
};

struct CmdRegisterFontBuilder {
  typedef CmdRegisterFont Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(CmdRegisterFont::VT_NAME, name);
  }
  void add_url(::flatbuffers::Offset<::flatbuffers::String> url) {
    fbb_.AddOffset(CmdRegisterFont::VT_URL, url);
  }
  void add_subpixel(bool subpixel) {
    fbb_.AddElement<uint8_t>(CmdRegisterFont::VT_SUBPIXEL, static_cast<uint8_t>(subpixel), 0);
  }
  explicit CmdRegisterFontBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdRegisterFont> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdRegisterFont>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdRegisterFont> CreateCmdRegisterFont(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> url = 0,
    bool subpixel = false) {
  CmdRegisterFontBuilder builder_(_fbb);
  builder_.add_url(url);
  builder_.add_name(name);
  builder_.add_subpixel(subpixel);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CmdRegisterFont> CreateCmdRegisterFontDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *url = nullptr,
    bool subpixel = false) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto url__ = url ? _fbb.CreateString(url) : 0;
  return VectorCmdFB::CreateCmdRegisterFont(
      _fbb,
      name__,
      url__,
      subpixel);
}

struct CmdPolyline FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdPolylineBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POINTS = 4,
    VT_COL = 6,
    VT_FLAGS = 8,
    VT_THICKNESS = 10
  };
  const VectorCmdFB::ArrayOfVec2 *points() const {
    return GetPointer<const VectorCmdFB::ArrayOfVec2 *>(VT_POINTS);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  uint32_t flags() const {
    return GetField<uint32_t>(VT_FLAGS, 0);
  }
  float thickness() const {
    return GetField<float>(VT_THICKNESS, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_POINTS) &&
           verifier.VerifyTable(points()) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           VerifyField<uint32_t>(verifier, VT_FLAGS, 4) &&
           VerifyField<float>(verifier, VT_THICKNESS, 4) &&
           verifier.EndTable();
  }
};

struct CmdPolylineBuilder {
  typedef CmdPolyline Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_points(::flatbuffers::Offset<VectorCmdFB::ArrayOfVec2> points) {
    fbb_.AddOffset(CmdPolyline::VT_POINTS, points);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdPolyline::VT_COL, col, 0);
  }
  void add_flags(uint32_t flags) {
    fbb_.AddElement<uint32_t>(CmdPolyline::VT_FLAGS, flags, 0);
  }
  void add_thickness(float thickness) {
    fbb_.AddElement<float>(CmdPolyline::VT_THICKNESS, thickness, 0.0f);
  }
  explicit CmdPolylineBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdPolyline> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdPolyline>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdPolyline> CreateCmdPolyline(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<VectorCmdFB::ArrayOfVec2> points = 0,
    uint32_t col = 0,
    uint32_t flags = 0,
    float thickness = 0.0f) {
  CmdPolylineBuilder builder_(_fbb);
  builder_.add_thickness(thickness);
  builder_.add_flags(flags);
  builder_.add_col(col);
  builder_.add_points(points);
  return builder_.Finish();
}

struct CmdConvexPolyFilled FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdConvexPolyFilledBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POINTS = 4,
    VT_COL = 6
  };
  const VectorCmdFB::ArrayOfVec2 *points() const {
    return GetPointer<const VectorCmdFB::ArrayOfVec2 *>(VT_POINTS);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_POINTS) &&
           verifier.VerifyTable(points()) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           verifier.EndTable();
  }
};

struct CmdConvexPolyFilledBuilder {
  typedef CmdConvexPolyFilled Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_points(::flatbuffers::Offset<VectorCmdFB::ArrayOfVec2> points) {
    fbb_.AddOffset(CmdConvexPolyFilled::VT_POINTS, points);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdConvexPolyFilled::VT_COL, col, 0);
  }
  explicit CmdConvexPolyFilledBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdConvexPolyFilled> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdConvexPolyFilled>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdConvexPolyFilled> CreateCmdConvexPolyFilled(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<VectorCmdFB::ArrayOfVec2> points = 0,
    uint32_t col = 0) {
  CmdConvexPolyFilledBuilder builder_(_fbb);
  builder_.add_col(col);
  builder_.add_points(points);
  return builder_.Finish();
}

struct CmdLine FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdLineBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_P1 = 4,
    VT_P2 = 6,
    VT_COL = 8,
    VT_THICKNESS = 10
  };
  const VectorCmdFB::SingleVec2 *p1() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_P1);
  }
  const VectorCmdFB::SingleVec2 *p2() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_P2);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  float thickness() const {
    return GetField<float>(VT_THICKNESS, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_P1, 4) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_P2, 4) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           VerifyField<float>(verifier, VT_THICKNESS, 4) &&
           verifier.EndTable();
  }
};

struct CmdLineBuilder {
  typedef CmdLine Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_p1(const VectorCmdFB::SingleVec2 *p1) {
    fbb_.AddStruct(CmdLine::VT_P1, p1);
  }
  void add_p2(const VectorCmdFB::SingleVec2 *p2) {
    fbb_.AddStruct(CmdLine::VT_P2, p2);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdLine::VT_COL, col, 0);
  }
  void add_thickness(float thickness) {
    fbb_.AddElement<float>(CmdLine::VT_THICKNESS, thickness, 0.0f);
  }
  explicit CmdLineBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdLine> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdLine>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdLine> CreateCmdLine(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const VectorCmdFB::SingleVec2 *p1 = nullptr,
    const VectorCmdFB::SingleVec2 *p2 = nullptr,
    uint32_t col = 0,
    float thickness = 0.0f) {
  CmdLineBuilder builder_(_fbb);
  builder_.add_thickness(thickness);
  builder_.add_col(col);
  builder_.add_p2(p2);
  builder_.add_p1(p1);
  return builder_.Finish();
}

struct CmdRectRounded FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdRectRoundedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_P_MIN = 4,
    VT_P_MAX = 6,
    VT_COL = 8,
    VT_ROUNDING = 10,
    VT_THICKNESS = 12
  };
  const VectorCmdFB::SingleVec2 *p_min() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_P_MIN);
  }
  const VectorCmdFB::SingleVec2 *p_max() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_P_MAX);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  float rounding() const {
    return GetField<float>(VT_ROUNDING, 0.0f);
  }
  float thickness() const {
    return GetField<float>(VT_THICKNESS, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_P_MIN, 4) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_P_MAX, 4) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           VerifyField<float>(verifier, VT_ROUNDING, 4) &&
           VerifyField<float>(verifier, VT_THICKNESS, 4) &&
           verifier.EndTable();
  }
};

struct CmdRectRoundedBuilder {
  typedef CmdRectRounded Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_p_min(const VectorCmdFB::SingleVec2 *p_min) {
    fbb_.AddStruct(CmdRectRounded::VT_P_MIN, p_min);
  }
  void add_p_max(const VectorCmdFB::SingleVec2 *p_max) {
    fbb_.AddStruct(CmdRectRounded::VT_P_MAX, p_max);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdRectRounded::VT_COL, col, 0);
  }
  void add_rounding(float rounding) {
    fbb_.AddElement<float>(CmdRectRounded::VT_ROUNDING, rounding, 0.0f);
  }
  void add_thickness(float thickness) {
    fbb_.AddElement<float>(CmdRectRounded::VT_THICKNESS, thickness, 0.0f);
  }
  explicit CmdRectRoundedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdRectRounded> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdRectRounded>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdRectRounded> CreateCmdRectRounded(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const VectorCmdFB::SingleVec2 *p_min = nullptr,
    const VectorCmdFB::SingleVec2 *p_max = nullptr,
    uint32_t col = 0,
    float rounding = 0.0f,
    float thickness = 0.0f) {
  CmdRectRoundedBuilder builder_(_fbb);
  builder_.add_thickness(thickness);
  builder_.add_rounding(rounding);
  builder_.add_col(col);
  builder_.add_p_max(p_max);
  builder_.add_p_min(p_min);
  return builder_.Finish();
}

struct CmdRectRoundedCorners FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdRectRoundedCornersBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_P_MIN = 4,
    VT_P_MAX = 6,
    VT_COL = 8,
    VT_ROUNDING_TOP_LEFT = 10,
    VT_ROUNDING_TOP_RIGHT = 12,
    VT_ROUNDING_BOTTOM_RIGHT = 14,
    VT_ROUNDING_BOTTOM_LEFT = 16,
    VT_THICKNESS = 18
  };
  const VectorCmdFB::SingleVec2 *p_min() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_P_MIN);
  }
  const VectorCmdFB::SingleVec2 *p_max() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_P_MAX);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  float rounding_top_left() const {
    return GetField<float>(VT_ROUNDING_TOP_LEFT, 0.0f);
  }
  float rounding_top_right() const {
    return GetField<float>(VT_ROUNDING_TOP_RIGHT, 0.0f);
  }
  float rounding_bottom_right() const {
    return GetField<float>(VT_ROUNDING_BOTTOM_RIGHT, 0.0f);
  }
  float rounding_bottom_left() const {
    return GetField<float>(VT_ROUNDING_BOTTOM_LEFT, 0.0f);
  }
  float thickness() const {
    return GetField<float>(VT_THICKNESS, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_P_MIN, 4) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_P_MAX, 4) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           VerifyField<float>(verifier, VT_ROUNDING_TOP_LEFT, 4) &&
           VerifyField<float>(verifier, VT_ROUNDING_TOP_RIGHT, 4) &&
           VerifyField<float>(verifier, VT_ROUNDING_BOTTOM_RIGHT, 4) &&
           VerifyField<float>(verifier, VT_ROUNDING_BOTTOM_LEFT, 4) &&
           VerifyField<float>(verifier, VT_THICKNESS, 4) &&
           verifier.EndTable();
  }
};

struct CmdRectRoundedCornersBuilder {
  typedef CmdRectRoundedCorners Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_p_min(const VectorCmdFB::SingleVec2 *p_min) {
    fbb_.AddStruct(CmdRectRoundedCorners::VT_P_MIN, p_min);
  }
  void add_p_max(const VectorCmdFB::SingleVec2 *p_max) {
    fbb_.AddStruct(CmdRectRoundedCorners::VT_P_MAX, p_max);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdRectRoundedCorners::VT_COL, col, 0);
  }
  void add_rounding_top_left(float rounding_top_left) {
    fbb_.AddElement<float>(CmdRectRoundedCorners::VT_ROUNDING_TOP_LEFT, rounding_top_left, 0.0f);
  }
  void add_rounding_top_right(float rounding_top_right) {
    fbb_.AddElement<float>(CmdRectRoundedCorners::VT_ROUNDING_TOP_RIGHT, rounding_top_right, 0.0f);
  }
  void add_rounding_bottom_right(float rounding_bottom_right) {
    fbb_.AddElement<float>(CmdRectRoundedCorners::VT_ROUNDING_BOTTOM_RIGHT, rounding_bottom_right, 0.0f);
  }
  void add_rounding_bottom_left(float rounding_bottom_left) {
    fbb_.AddElement<float>(CmdRectRoundedCorners::VT_ROUNDING_BOTTOM_LEFT, rounding_bottom_left, 0.0f);
  }
  void add_thickness(float thickness) {
    fbb_.AddElement<float>(CmdRectRoundedCorners::VT_THICKNESS, thickness, 0.0f);
  }
  explicit CmdRectRoundedCornersBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdRectRoundedCorners> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdRectRoundedCorners>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdRectRoundedCorners> CreateCmdRectRoundedCorners(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const VectorCmdFB::SingleVec2 *p_min = nullptr,
    const VectorCmdFB::SingleVec2 *p_max = nullptr,
    uint32_t col = 0,
    float rounding_top_left = 0.0f,
    float rounding_top_right = 0.0f,
    float rounding_bottom_right = 0.0f,
    float rounding_bottom_left = 0.0f,
    float thickness = 0.0f) {
  CmdRectRoundedCornersBuilder builder_(_fbb);
  builder_.add_thickness(thickness);
  builder_.add_rounding_bottom_left(rounding_bottom_left);
  builder_.add_rounding_bottom_right(rounding_bottom_right);
  builder_.add_rounding_top_right(rounding_top_right);
  builder_.add_rounding_top_left(rounding_top_left);
  builder_.add_col(col);
  builder_.add_p_max(p_max);
  builder_.add_p_min(p_min);
  return builder_.Finish();
}

struct CmdRectRoundedFilled FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdRectRoundedFilledBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_P_MIN = 4,
    VT_P_MAX = 6,
    VT_COL = 8,
    VT_ROUNDING = 10
  };
  const VectorCmdFB::SingleVec2 *p_min() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_P_MIN);
  }
  const VectorCmdFB::SingleVec2 *p_max() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_P_MAX);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  float rounding() const {
    return GetField<float>(VT_ROUNDING, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_P_MIN, 4) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_P_MAX, 4) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           VerifyField<float>(verifier, VT_ROUNDING, 4) &&
           verifier.EndTable();
  }
};

struct CmdRectRoundedFilledBuilder {
  typedef CmdRectRoundedFilled Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_p_min(const VectorCmdFB::SingleVec2 *p_min) {
    fbb_.AddStruct(CmdRectRoundedFilled::VT_P_MIN, p_min);
  }
  void add_p_max(const VectorCmdFB::SingleVec2 *p_max) {
    fbb_.AddStruct(CmdRectRoundedFilled::VT_P_MAX, p_max);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdRectRoundedFilled::VT_COL, col, 0);
  }
  void add_rounding(float rounding) {
    fbb_.AddElement<float>(CmdRectRoundedFilled::VT_ROUNDING, rounding, 0.0f);
  }
  explicit CmdRectRoundedFilledBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdRectRoundedFilled> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdRectRoundedFilled>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdRectRoundedFilled> CreateCmdRectRoundedFilled(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const VectorCmdFB::SingleVec2 *p_min = nullptr,
    const VectorCmdFB::SingleVec2 *p_max = nullptr,
    uint32_t col = 0,
    float rounding = 0.0f) {
  CmdRectRoundedFilledBuilder builder_(_fbb);
  builder_.add_rounding(rounding);
  builder_.add_col(col);
  builder_.add_p_max(p_max);
  builder_.add_p_min(p_min);
  return builder_.Finish();
}

struct CmdRectRoundedCornersFilled FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdRectRoundedCornersFilledBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_P_MIN = 4,
    VT_P_MAX = 6,
    VT_COL = 8,
    VT_ROUNDING_TOP_LEFT = 10,
    VT_ROUNDING_TOP_RIGHT = 12,
    VT_ROUNDING_BOTTOM_RIGHT = 14,
    VT_ROUNDING_BOTTOM_LEFT = 16
  };
  const VectorCmdFB::SingleVec2 *p_min() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_P_MIN);
  }
  const VectorCmdFB::SingleVec2 *p_max() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_P_MAX);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  float rounding_top_left() const {
    return GetField<float>(VT_ROUNDING_TOP_LEFT, 0.0f);
  }
  float rounding_top_right() const {
    return GetField<float>(VT_ROUNDING_TOP_RIGHT, 0.0f);
  }
  float rounding_bottom_right() const {
    return GetField<float>(VT_ROUNDING_BOTTOM_RIGHT, 0.0f);
  }
  float rounding_bottom_left() const {
    return GetField<float>(VT_ROUNDING_BOTTOM_LEFT, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_P_MIN, 4) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_P_MAX, 4) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           VerifyField<float>(verifier, VT_ROUNDING_TOP_LEFT, 4) &&
           VerifyField<float>(verifier, VT_ROUNDING_TOP_RIGHT, 4) &&
           VerifyField<float>(verifier, VT_ROUNDING_BOTTOM_RIGHT, 4) &&
           VerifyField<float>(verifier, VT_ROUNDING_BOTTOM_LEFT, 4) &&
           verifier.EndTable();
  }
};

struct CmdRectRoundedCornersFilledBuilder {
  typedef CmdRectRoundedCornersFilled Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_p_min(const VectorCmdFB::SingleVec2 *p_min) {
    fbb_.AddStruct(CmdRectRoundedCornersFilled::VT_P_MIN, p_min);
  }
  void add_p_max(const VectorCmdFB::SingleVec2 *p_max) {
    fbb_.AddStruct(CmdRectRoundedCornersFilled::VT_P_MAX, p_max);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdRectRoundedCornersFilled::VT_COL, col, 0);
  }
  void add_rounding_top_left(float rounding_top_left) {
    fbb_.AddElement<float>(CmdRectRoundedCornersFilled::VT_ROUNDING_TOP_LEFT, rounding_top_left, 0.0f);
  }
  void add_rounding_top_right(float rounding_top_right) {
    fbb_.AddElement<float>(CmdRectRoundedCornersFilled::VT_ROUNDING_TOP_RIGHT, rounding_top_right, 0.0f);
  }
  void add_rounding_bottom_right(float rounding_bottom_right) {
    fbb_.AddElement<float>(CmdRectRoundedCornersFilled::VT_ROUNDING_BOTTOM_RIGHT, rounding_bottom_right, 0.0f);
  }
  void add_rounding_bottom_left(float rounding_bottom_left) {
    fbb_.AddElement<float>(CmdRectRoundedCornersFilled::VT_ROUNDING_BOTTOM_LEFT, rounding_bottom_left, 0.0f);
  }
  explicit CmdRectRoundedCornersFilledBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdRectRoundedCornersFilled> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdRectRoundedCornersFilled>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdRectRoundedCornersFilled> CreateCmdRectRoundedCornersFilled(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const VectorCmdFB::SingleVec2 *p_min = nullptr,
    const VectorCmdFB::SingleVec2 *p_max = nullptr,
    uint32_t col = 0,
    float rounding_top_left = 0.0f,
    float rounding_top_right = 0.0f,
    float rounding_bottom_right = 0.0f,
    float rounding_bottom_left = 0.0f) {
  CmdRectRoundedCornersFilledBuilder builder_(_fbb);
  builder_.add_rounding_bottom_left(rounding_bottom_left);
  builder_.add_rounding_bottom_right(rounding_bottom_right);
  builder_.add_rounding_top_right(rounding_top_right);
  builder_.add_rounding_top_left(rounding_top_left);
  builder_.add_col(col);
  builder_.add_p_max(p_max);
  builder_.add_p_min(p_min);
  return builder_.Finish();
}

struct CmdQuad FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdQuadBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_P1 = 4,
    VT_P2 = 6,
    VT_P3 = 8,
    VT_P4 = 10,
    VT_COL = 12,
    VT_THICKNESS = 14
  };
  const VectorCmdFB::SingleVec2 *p1() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_P1);
  }
  const VectorCmdFB::SingleVec2 *p2() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_P2);
  }
  const VectorCmdFB::SingleVec2 *p3() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_P3);
  }
  const VectorCmdFB::SingleVec2 *p4() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_P4);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  float thickness() const {
    return GetField<float>(VT_THICKNESS, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_P1, 4) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_P2, 4) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_P3, 4) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_P4, 4) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           VerifyField<float>(verifier, VT_THICKNESS, 4) &&
           verifier.EndTable();
  }
};

struct CmdQuadBuilder {
  typedef CmdQuad Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_p1(const VectorCmdFB::SingleVec2 *p1) {
    fbb_.AddStruct(CmdQuad::VT_P1, p1);
  }
  void add_p2(const VectorCmdFB::SingleVec2 *p2) {
    fbb_.AddStruct(CmdQuad::VT_P2, p2);
  }
  void add_p3(const VectorCmdFB::SingleVec2 *p3) {
    fbb_.AddStruct(CmdQuad::VT_P3, p3);
  }
  void add_p4(const VectorCmdFB::SingleVec2 *p4) {
    fbb_.AddStruct(CmdQuad::VT_P4, p4);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdQuad::VT_COL, col, 0);
  }
  void add_thickness(float thickness) {
    fbb_.AddElement<float>(CmdQuad::VT_THICKNESS, thickness, 0.0f);
  }
  explicit CmdQuadBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdQuad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdQuad>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdQuad> CreateCmdQuad(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const VectorCmdFB::SingleVec2 *p1 = nullptr,
    const VectorCmdFB::SingleVec2 *p2 = nullptr,
    const VectorCmdFB::SingleVec2 *p3 = nullptr,
    const VectorCmdFB::SingleVec2 *p4 = nullptr,
    uint32_t col = 0,
    float thickness = 0.0f) {
  CmdQuadBuilder builder_(_fbb);
  builder_.add_thickness(thickness);
  builder_.add_col(col);
  builder_.add_p4(p4);
  builder_.add_p3(p3);
  builder_.add_p2(p2);
  builder_.add_p1(p1);
  return builder_.Finish();
}

struct CmdQuadFilled FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdQuadFilledBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_P1 = 4,
    VT_P2 = 6,
    VT_P3 = 8,
    VT_P4 = 10,
    VT_COL = 12
  };
  const VectorCmdFB::SingleVec2 *p1() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_P1);
  }
  const VectorCmdFB::SingleVec2 *p2() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_P2);
  }
  const VectorCmdFB::SingleVec2 *p3() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_P3);
  }
  const VectorCmdFB::SingleVec2 *p4() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_P4);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_P1, 4) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_P2, 4) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_P3, 4) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_P4, 4) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           verifier.EndTable();
  }
};

struct CmdQuadFilledBuilder {
  typedef CmdQuadFilled Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_p1(const VectorCmdFB::SingleVec2 *p1) {
    fbb_.AddStruct(CmdQuadFilled::VT_P1, p1);
  }
  void add_p2(const VectorCmdFB::SingleVec2 *p2) {
    fbb_.AddStruct(CmdQuadFilled::VT_P2, p2);
  }
  void add_p3(const VectorCmdFB::SingleVec2 *p3) {
    fbb_.AddStruct(CmdQuadFilled::VT_P3, p3);
  }
  void add_p4(const VectorCmdFB::SingleVec2 *p4) {
    fbb_.AddStruct(CmdQuadFilled::VT_P4, p4);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdQuadFilled::VT_COL, col, 0);
  }
  explicit CmdQuadFilledBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdQuadFilled> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdQuadFilled>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdQuadFilled> CreateCmdQuadFilled(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const VectorCmdFB::SingleVec2 *p1 = nullptr,
    const VectorCmdFB::SingleVec2 *p2 = nullptr,
    const VectorCmdFB::SingleVec2 *p3 = nullptr,
    const VectorCmdFB::SingleVec2 *p4 = nullptr,
    uint32_t col = 0) {
  CmdQuadFilledBuilder builder_(_fbb);
  builder_.add_col(col);
  builder_.add_p4(p4);
  builder_.add_p3(p3);
  builder_.add_p2(p2);
  builder_.add_p1(p1);
  return builder_.Finish();
}

struct CmdTriangle FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdTriangleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_P1 = 4,
    VT_P2 = 6,
    VT_P3 = 8,
    VT_COL = 10,
    VT_THICKNESS = 12
  };
  const VectorCmdFB::SingleVec2 *p1() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_P1);
  }
  const VectorCmdFB::SingleVec2 *p2() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_P2);
  }
  const VectorCmdFB::SingleVec2 *p3() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_P3);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  float thickness() const {
    return GetField<float>(VT_THICKNESS, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_P1, 4) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_P2, 4) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_P3, 4) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           VerifyField<float>(verifier, VT_THICKNESS, 4) &&
           verifier.EndTable();
  }
};

struct CmdTriangleBuilder {
  typedef CmdTriangle Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_p1(const VectorCmdFB::SingleVec2 *p1) {
    fbb_.AddStruct(CmdTriangle::VT_P1, p1);
  }
  void add_p2(const VectorCmdFB::SingleVec2 *p2) {
    fbb_.AddStruct(CmdTriangle::VT_P2, p2);
  }
  void add_p3(const VectorCmdFB::SingleVec2 *p3) {
    fbb_.AddStruct(CmdTriangle::VT_P3, p3);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdTriangle::VT_COL, col, 0);
  }
  void add_thickness(float thickness) {
    fbb_.AddElement<float>(CmdTriangle::VT_THICKNESS, thickness, 0.0f);
  }
  explicit CmdTriangleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdTriangle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdTriangle>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdTriangle> CreateCmdTriangle(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const VectorCmdFB::SingleVec2 *p1 = nullptr,
    const VectorCmdFB::SingleVec2 *p2 = nullptr,
    const VectorCmdFB::SingleVec2 *p3 = nullptr,
    uint32_t col = 0,
    float thickness = 0.0f) {
  CmdTriangleBuilder builder_(_fbb);
  builder_.add_thickness(thickness);
  builder_.add_col(col);
  builder_.add_p3(p3);
  builder_.add_p2(p2);
  builder_.add_p1(p1);
  return builder_.Finish();
}

struct CmdTriangleFilled FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdTriangleFilledBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_P1 = 4,
    VT_P2 = 6,
    VT_P3 = 8,
    VT_COL = 10
  };
  const VectorCmdFB::SingleVec2 *p1() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_P1);
  }
  const VectorCmdFB::SingleVec2 *p2() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_P2);
  }
  const VectorCmdFB::SingleVec2 *p3() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_P3);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_P1, 4) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_P2, 4) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_P3, 4) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           verifier.EndTable();
  }
};

struct CmdTriangleFilledBuilder {
  typedef CmdTriangleFilled Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_p1(const VectorCmdFB::SingleVec2 *p1) {
    fbb_.AddStruct(CmdTriangleFilled::VT_P1, p1);
  }
  void add_p2(const VectorCmdFB::SingleVec2 *p2) {
    fbb_.AddStruct(CmdTriangleFilled::VT_P2, p2);
  }
  void add_p3(const VectorCmdFB::SingleVec2 *p3) {
    fbb_.AddStruct(CmdTriangleFilled::VT_P3, p3);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdTriangleFilled::VT_COL, col, 0);
  }
  explicit CmdTriangleFilledBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdTriangleFilled> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdTriangleFilled>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdTriangleFilled> CreateCmdTriangleFilled(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const VectorCmdFB::SingleVec2 *p1 = nullptr,
    const VectorCmdFB::SingleVec2 *p2 = nullptr,
    const VectorCmdFB::SingleVec2 *p3 = nullptr,
    uint32_t col = 0) {
  CmdTriangleFilledBuilder builder_(_fbb);
  builder_.add_col(col);
  builder_.add_p3(p3);
  builder_.add_p2(p2);
  builder_.add_p1(p1);
  return builder_.Finish();
}

struct CmdCircle FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdCircleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CENTER = 4,
    VT_RADIUS = 6,
    VT_COL = 8,
    VT_NUM_SEGMENTS = 10,
    VT_THICKNESS = 12
  };
  const VectorCmdFB::SingleVec2 *center() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_CENTER);
  }
  float radius() const {
    return GetField<float>(VT_RADIUS, 0.0f);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  int32_t num_segments() const {
    return GetField<int32_t>(VT_NUM_SEGMENTS, 0);
  }
  float thickness() const {
    return GetField<float>(VT_THICKNESS, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_CENTER, 4) &&
           VerifyField<float>(verifier, VT_RADIUS, 4) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           VerifyField<int32_t>(verifier, VT_NUM_SEGMENTS, 4) &&
           VerifyField<float>(verifier, VT_THICKNESS, 4) &&
           verifier.EndTable();
  }
};

struct CmdCircleBuilder {
  typedef CmdCircle Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_center(const VectorCmdFB::SingleVec2 *center) {
    fbb_.AddStruct(CmdCircle::VT_CENTER, center);
  }
  void add_radius(float radius) {
    fbb_.AddElement<float>(CmdCircle::VT_RADIUS, radius, 0.0f);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdCircle::VT_COL, col, 0);
  }
  void add_num_segments(int32_t num_segments) {
    fbb_.AddElement<int32_t>(CmdCircle::VT_NUM_SEGMENTS, num_segments, 0);
  }
  void add_thickness(float thickness) {
    fbb_.AddElement<float>(CmdCircle::VT_THICKNESS, thickness, 0.0f);
  }
  explicit CmdCircleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdCircle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdCircle>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdCircle> CreateCmdCircle(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const VectorCmdFB::SingleVec2 *center = nullptr,
    float radius = 0.0f,
    uint32_t col = 0,
    int32_t num_segments = 0,
    float thickness = 0.0f) {
  CmdCircleBuilder builder_(_fbb);
  builder_.add_thickness(thickness);
  builder_.add_num_segments(num_segments);
  builder_.add_col(col);
  builder_.add_radius(radius);
  builder_.add_center(center);
  return builder_.Finish();
}

struct CmdCircleFilled FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdCircleFilledBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CENTER = 4,
    VT_RADIUS = 6,
    VT_COL = 8,
    VT_NUM_SEGMENTS = 10
  };
  const VectorCmdFB::SingleVec2 *center() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_CENTER);
  }
  float radius() const {
    return GetField<float>(VT_RADIUS, 0.0f);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  int32_t num_segments() const {
    return GetField<int32_t>(VT_NUM_SEGMENTS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_CENTER, 4) &&
           VerifyField<float>(verifier, VT_RADIUS, 4) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           VerifyField<int32_t>(verifier, VT_NUM_SEGMENTS, 4) &&
           verifier.EndTable();
  }
};

struct CmdCircleFilledBuilder {
  typedef CmdCircleFilled Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_center(const VectorCmdFB::SingleVec2 *center) {
    fbb_.AddStruct(CmdCircleFilled::VT_CENTER, center);
  }
  void add_radius(float radius) {
    fbb_.AddElement<float>(CmdCircleFilled::VT_RADIUS, radius, 0.0f);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdCircleFilled::VT_COL, col, 0);
  }
  void add_num_segments(int32_t num_segments) {
    fbb_.AddElement<int32_t>(CmdCircleFilled::VT_NUM_SEGMENTS, num_segments, 0);
  }
  explicit CmdCircleFilledBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdCircleFilled> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdCircleFilled>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdCircleFilled> CreateCmdCircleFilled(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const VectorCmdFB::SingleVec2 *center = nullptr,
    float radius = 0.0f,
    uint32_t col = 0,
    int32_t num_segments = 0) {
  CmdCircleFilledBuilder builder_(_fbb);
  builder_.add_num_segments(num_segments);
  builder_.add_col(col);
  builder_.add_radius(radius);
  builder_.add_center(center);
  return builder_.Finish();
}

struct CmdNgon FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdNgonBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CENTER = 4,
    VT_RADIUS = 6,
    VT_COL = 8,
    VT_NUM_SEGMENTS = 10,
    VT_THICKNESS = 12
  };
  const VectorCmdFB::SingleVec2 *center() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_CENTER);
  }
  float radius() const {
    return GetField<float>(VT_RADIUS, 0.0f);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  int32_t num_segments() const {
    return GetField<int32_t>(VT_NUM_SEGMENTS, 0);
  }
  float thickness() const {
    return GetField<float>(VT_THICKNESS, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_CENTER, 4) &&
           VerifyField<float>(verifier, VT_RADIUS, 4) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           VerifyField<int32_t>(verifier, VT_NUM_SEGMENTS, 4) &&
           VerifyField<float>(verifier, VT_THICKNESS, 4) &&
           verifier.EndTable();
  }
};

struct CmdNgonBuilder {
  typedef CmdNgon Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_center(const VectorCmdFB::SingleVec2 *center) {
    fbb_.AddStruct(CmdNgon::VT_CENTER, center);
  }
  void add_radius(float radius) {
    fbb_.AddElement<float>(CmdNgon::VT_RADIUS, radius, 0.0f);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdNgon::VT_COL, col, 0);
  }
  void add_num_segments(int32_t num_segments) {
    fbb_.AddElement<int32_t>(CmdNgon::VT_NUM_SEGMENTS, num_segments, 0);
  }
  void add_thickness(float thickness) {
    fbb_.AddElement<float>(CmdNgon::VT_THICKNESS, thickness, 0.0f);
  }
  explicit CmdNgonBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdNgon> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdNgon>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdNgon> CreateCmdNgon(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const VectorCmdFB::SingleVec2 *center = nullptr,
    float radius = 0.0f,
    uint32_t col = 0,
    int32_t num_segments = 0,
    float thickness = 0.0f) {
  CmdNgonBuilder builder_(_fbb);
  builder_.add_thickness(thickness);
  builder_.add_num_segments(num_segments);
  builder_.add_col(col);
  builder_.add_radius(radius);
  builder_.add_center(center);
  return builder_.Finish();
}

struct CmdNgonFilled FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdNgonFilledBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CENTER = 4,
    VT_RADIUS = 6,
    VT_COL = 8,
    VT_NUM_SEGMENTS = 10
  };
  const VectorCmdFB::SingleVec2 *center() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_CENTER);
  }
  float radius() const {
    return GetField<float>(VT_RADIUS, 0.0f);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  int32_t num_segments() const {
    return GetField<int32_t>(VT_NUM_SEGMENTS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_CENTER, 4) &&
           VerifyField<float>(verifier, VT_RADIUS, 4) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           VerifyField<int32_t>(verifier, VT_NUM_SEGMENTS, 4) &&
           verifier.EndTable();
  }
};

struct CmdNgonFilledBuilder {
  typedef CmdNgonFilled Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_center(const VectorCmdFB::SingleVec2 *center) {
    fbb_.AddStruct(CmdNgonFilled::VT_CENTER, center);
  }
  void add_radius(float radius) {
    fbb_.AddElement<float>(CmdNgonFilled::VT_RADIUS, radius, 0.0f);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdNgonFilled::VT_COL, col, 0);
  }
  void add_num_segments(int32_t num_segments) {
    fbb_.AddElement<int32_t>(CmdNgonFilled::VT_NUM_SEGMENTS, num_segments, 0);
  }
  explicit CmdNgonFilledBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdNgonFilled> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdNgonFilled>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdNgonFilled> CreateCmdNgonFilled(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const VectorCmdFB::SingleVec2 *center = nullptr,
    float radius = 0.0f,
    uint32_t col = 0,
    int32_t num_segments = 0) {
  CmdNgonFilledBuilder builder_(_fbb);
  builder_.add_num_segments(num_segments);
  builder_.add_col(col);
  builder_.add_radius(radius);
  builder_.add_center(center);
  return builder_.Finish();
}

struct CmdEllipse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdEllipseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CENTER = 4,
    VT_RADIUS_X = 6,
    VT_RADIUS_Y = 8,
    VT_COL = 10,
    VT_ROT = 12,
    VT_NUM_SEGMENTS = 14,
    VT_THICKNESS = 16
  };
  const VectorCmdFB::SingleVec2 *center() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_CENTER);
  }
  float radius_x() const {
    return GetField<float>(VT_RADIUS_X, 0.0f);
  }
  float radius_y() const {
    return GetField<float>(VT_RADIUS_Y, 0.0f);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  float rot() const {
    return GetField<float>(VT_ROT, 0.0f);
  }
  int32_t num_segments() const {
    return GetField<int32_t>(VT_NUM_SEGMENTS, 0);
  }
  float thickness() const {
    return GetField<float>(VT_THICKNESS, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_CENTER, 4) &&
           VerifyField<float>(verifier, VT_RADIUS_X, 4) &&
           VerifyField<float>(verifier, VT_RADIUS_Y, 4) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           VerifyField<float>(verifier, VT_ROT, 4) &&
           VerifyField<int32_t>(verifier, VT_NUM_SEGMENTS, 4) &&
           VerifyField<float>(verifier, VT_THICKNESS, 4) &&
           verifier.EndTable();
  }
};

struct CmdEllipseBuilder {
  typedef CmdEllipse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_center(const VectorCmdFB::SingleVec2 *center) {
    fbb_.AddStruct(CmdEllipse::VT_CENTER, center);
  }
  void add_radius_x(float radius_x) {
    fbb_.AddElement<float>(CmdEllipse::VT_RADIUS_X, radius_x, 0.0f);
  }
  void add_radius_y(float radius_y) {
    fbb_.AddElement<float>(CmdEllipse::VT_RADIUS_Y, radius_y, 0.0f);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdEllipse::VT_COL, col, 0);
  }
  void add_rot(float rot) {
    fbb_.AddElement<float>(CmdEllipse::VT_ROT, rot, 0.0f);
  }
  void add_num_segments(int32_t num_segments) {
    fbb_.AddElement<int32_t>(CmdEllipse::VT_NUM_SEGMENTS, num_segments, 0);
  }
  void add_thickness(float thickness) {
    fbb_.AddElement<float>(CmdEllipse::VT_THICKNESS, thickness, 0.0f);
  }
  explicit CmdEllipseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdEllipse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdEllipse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdEllipse> CreateCmdEllipse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const VectorCmdFB::SingleVec2 *center = nullptr,
    float radius_x = 0.0f,
    float radius_y = 0.0f,
    uint32_t col = 0,
    float rot = 0.0f,
    int32_t num_segments = 0,
    float thickness = 0.0f) {
  CmdEllipseBuilder builder_(_fbb);
  builder_.add_thickness(thickness);
  builder_.add_num_segments(num_segments);
  builder_.add_rot(rot);
  builder_.add_col(col);
  builder_.add_radius_y(radius_y);
  builder_.add_radius_x(radius_x);
  builder_.add_center(center);
  return builder_.Finish();
}

struct CmdEllipseFilled FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdEllipseFilledBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CENTER = 4,
    VT_RADIUS_X = 6,
    VT_RADIUS_Y = 8,
    VT_COL = 10,
    VT_ROT = 12,
    VT_NUM_SEGMENTS = 14
  };
  const VectorCmdFB::SingleVec2 *center() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_CENTER);
  }
  float radius_x() const {
    return GetField<float>(VT_RADIUS_X, 0.0f);
  }
  float radius_y() const {
    return GetField<float>(VT_RADIUS_Y, 0.0f);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  float rot() const {
    return GetField<float>(VT_ROT, 0.0f);
  }
  int32_t num_segments() const {
    return GetField<int32_t>(VT_NUM_SEGMENTS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_CENTER, 4) &&
           VerifyField<float>(verifier, VT_RADIUS_X, 4) &&
           VerifyField<float>(verifier, VT_RADIUS_Y, 4) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           VerifyField<float>(verifier, VT_ROT, 4) &&
           VerifyField<int32_t>(verifier, VT_NUM_SEGMENTS, 4) &&
           verifier.EndTable();
  }
};

struct CmdEllipseFilledBuilder {
  typedef CmdEllipseFilled Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_center(const VectorCmdFB::SingleVec2 *center) {
    fbb_.AddStruct(CmdEllipseFilled::VT_CENTER, center);
  }
  void add_radius_x(float radius_x) {
    fbb_.AddElement<float>(CmdEllipseFilled::VT_RADIUS_X, radius_x, 0.0f);
  }
  void add_radius_y(float radius_y) {
    fbb_.AddElement<float>(CmdEllipseFilled::VT_RADIUS_Y, radius_y, 0.0f);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdEllipseFilled::VT_COL, col, 0);
  }
  void add_rot(float rot) {
    fbb_.AddElement<float>(CmdEllipseFilled::VT_ROT, rot, 0.0f);
  }
  void add_num_segments(int32_t num_segments) {
    fbb_.AddElement<int32_t>(CmdEllipseFilled::VT_NUM_SEGMENTS, num_segments, 0);
  }
  explicit CmdEllipseFilledBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdEllipseFilled> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdEllipseFilled>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdEllipseFilled> CreateCmdEllipseFilled(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const VectorCmdFB::SingleVec2 *center = nullptr,
    float radius_x = 0.0f,
    float radius_y = 0.0f,
    uint32_t col = 0,
    float rot = 0.0f,
    int32_t num_segments = 0) {
  CmdEllipseFilledBuilder builder_(_fbb);
  builder_.add_num_segments(num_segments);
  builder_.add_rot(rot);
  builder_.add_col(col);
  builder_.add_radius_y(radius_y);
  builder_.add_radius_x(radius_x);
  builder_.add_center(center);
  return builder_.Finish();
}

struct CmdBezierCubic FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdBezierCubicBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_P1 = 4,
    VT_P2 = 6,
    VT_P3 = 8,
    VT_P4 = 10,
    VT_COL = 12,
    VT_THICKNESS = 14,
    VT_NUM_SEGMENTS = 16
  };
  const VectorCmdFB::SingleVec2 *p1() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_P1);
  }
  const VectorCmdFB::SingleVec2 *p2() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_P2);
  }
  const VectorCmdFB::SingleVec2 *p3() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_P3);
  }
  const VectorCmdFB::SingleVec2 *p4() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_P4);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  float thickness() const {
    return GetField<float>(VT_THICKNESS, 0.0f);
  }
  int32_t num_segments() const {
    return GetField<int32_t>(VT_NUM_SEGMENTS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_P1, 4) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_P2, 4) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_P3, 4) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_P4, 4) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           VerifyField<float>(verifier, VT_THICKNESS, 4) &&
           VerifyField<int32_t>(verifier, VT_NUM_SEGMENTS, 4) &&
           verifier.EndTable();
  }
};

struct CmdBezierCubicBuilder {
  typedef CmdBezierCubic Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_p1(const VectorCmdFB::SingleVec2 *p1) {
    fbb_.AddStruct(CmdBezierCubic::VT_P1, p1);
  }
  void add_p2(const VectorCmdFB::SingleVec2 *p2) {
    fbb_.AddStruct(CmdBezierCubic::VT_P2, p2);
  }
  void add_p3(const VectorCmdFB::SingleVec2 *p3) {
    fbb_.AddStruct(CmdBezierCubic::VT_P3, p3);
  }
  void add_p4(const VectorCmdFB::SingleVec2 *p4) {
    fbb_.AddStruct(CmdBezierCubic::VT_P4, p4);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdBezierCubic::VT_COL, col, 0);
  }
  void add_thickness(float thickness) {
    fbb_.AddElement<float>(CmdBezierCubic::VT_THICKNESS, thickness, 0.0f);
  }
  void add_num_segments(int32_t num_segments) {
    fbb_.AddElement<int32_t>(CmdBezierCubic::VT_NUM_SEGMENTS, num_segments, 0);
  }
  explicit CmdBezierCubicBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdBezierCubic> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdBezierCubic>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdBezierCubic> CreateCmdBezierCubic(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const VectorCmdFB::SingleVec2 *p1 = nullptr,
    const VectorCmdFB::SingleVec2 *p2 = nullptr,
    const VectorCmdFB::SingleVec2 *p3 = nullptr,
    const VectorCmdFB::SingleVec2 *p4 = nullptr,
    uint32_t col = 0,
    float thickness = 0.0f,
    int32_t num_segments = 0) {
  CmdBezierCubicBuilder builder_(_fbb);
  builder_.add_num_segments(num_segments);
  builder_.add_thickness(thickness);
  builder_.add_col(col);
  builder_.add_p4(p4);
  builder_.add_p3(p3);
  builder_.add_p2(p2);
  builder_.add_p1(p1);
  return builder_.Finish();
}

struct CmdBezierQuadratic FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdBezierQuadraticBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_P1 = 4,
    VT_P2 = 6,
    VT_P3 = 8,
    VT_COL = 10,
    VT_THICKNESS = 12,
    VT_NUM_SEGMENTS = 14
  };
  const VectorCmdFB::SingleVec2 *p1() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_P1);
  }
  const VectorCmdFB::SingleVec2 *p2() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_P2);
  }
  const VectorCmdFB::SingleVec2 *p3() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_P3);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  float thickness() const {
    return GetField<float>(VT_THICKNESS, 0.0f);
  }
  int32_t num_segments() const {
    return GetField<int32_t>(VT_NUM_SEGMENTS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_P1, 4) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_P2, 4) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_P3, 4) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           VerifyField<float>(verifier, VT_THICKNESS, 4) &&
           VerifyField<int32_t>(verifier, VT_NUM_SEGMENTS, 4) &&
           verifier.EndTable();
  }
};

struct CmdBezierQuadraticBuilder {
  typedef CmdBezierQuadratic Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_p1(const VectorCmdFB::SingleVec2 *p1) {
    fbb_.AddStruct(CmdBezierQuadratic::VT_P1, p1);
  }
  void add_p2(const VectorCmdFB::SingleVec2 *p2) {
    fbb_.AddStruct(CmdBezierQuadratic::VT_P2, p2);
  }
  void add_p3(const VectorCmdFB::SingleVec2 *p3) {
    fbb_.AddStruct(CmdBezierQuadratic::VT_P3, p3);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdBezierQuadratic::VT_COL, col, 0);
  }
  void add_thickness(float thickness) {
    fbb_.AddElement<float>(CmdBezierQuadratic::VT_THICKNESS, thickness, 0.0f);
  }
  void add_num_segments(int32_t num_segments) {
    fbb_.AddElement<int32_t>(CmdBezierQuadratic::VT_NUM_SEGMENTS, num_segments, 0);
  }
  explicit CmdBezierQuadraticBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdBezierQuadratic> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdBezierQuadratic>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdBezierQuadratic> CreateCmdBezierQuadratic(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const VectorCmdFB::SingleVec2 *p1 = nullptr,
    const VectorCmdFB::SingleVec2 *p2 = nullptr,
    const VectorCmdFB::SingleVec2 *p3 = nullptr,
    uint32_t col = 0,
    float thickness = 0.0f,
    int32_t num_segments = 0) {
  CmdBezierQuadraticBuilder builder_(_fbb);
  builder_.add_num_segments(num_segments);
  builder_.add_thickness(thickness);
  builder_.add_col(col);
  builder_.add_p3(p3);
  builder_.add_p2(p2);
  builder_.add_p1(p1);
  return builder_.Finish();
}

struct CmdImage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdImageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USER_TEXTURE_ID = 4,
    VT_P_MIN = 6,
    VT_P_MAX = 8,
    VT_UV_MIN = 10,
    VT_UV_MAX = 12,
    VT_COL = 14
  };
  uint64_t user_texture_id() const {
    return GetField<uint64_t>(VT_USER_TEXTURE_ID, 0);
  }
  const VectorCmdFB::SingleVec2 *p_min() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_P_MIN);
  }
  const VectorCmdFB::SingleVec2 *p_max() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_P_MAX);
  }
  const VectorCmdFB::SingleVec2 *uv_min() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_UV_MIN);
  }
  const VectorCmdFB::SingleVec2 *uv_max() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_UV_MAX);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_USER_TEXTURE_ID, 8) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_P_MIN, 4) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_P_MAX, 4) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_UV_MIN, 4) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_UV_MAX, 4) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           verifier.EndTable();
  }
};

struct CmdImageBuilder {
  typedef CmdImage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_user_texture_id(uint64_t user_texture_id) {
    fbb_.AddElement<uint64_t>(CmdImage::VT_USER_TEXTURE_ID, user_texture_id, 0);
  }
  void add_p_min(const VectorCmdFB::SingleVec2 *p_min) {
    fbb_.AddStruct(CmdImage::VT_P_MIN, p_min);
  }
  void add_p_max(const VectorCmdFB::SingleVec2 *p_max) {
    fbb_.AddStruct(CmdImage::VT_P_MAX, p_max);
  }
  void add_uv_min(const VectorCmdFB::SingleVec2 *uv_min) {
    fbb_.AddStruct(CmdImage::VT_UV_MIN, uv_min);
  }
  void add_uv_max(const VectorCmdFB::SingleVec2 *uv_max) {
    fbb_.AddStruct(CmdImage::VT_UV_MAX, uv_max);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdImage::VT_COL, col, 0);
  }
  explicit CmdImageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdImage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdImage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdImage> CreateCmdImage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t user_texture_id = 0,
    const VectorCmdFB::SingleVec2 *p_min = nullptr,
    const VectorCmdFB::SingleVec2 *p_max = nullptr,
    const VectorCmdFB::SingleVec2 *uv_min = nullptr,
    const VectorCmdFB::SingleVec2 *uv_max = nullptr,
    uint32_t col = 0) {
  CmdImageBuilder builder_(_fbb);
  builder_.add_user_texture_id(user_texture_id);
  builder_.add_col(col);
  builder_.add_uv_max(uv_max);
  builder_.add_uv_min(uv_min);
  builder_.add_p_max(p_max);
  builder_.add_p_min(p_min);
  return builder_.Finish();
}

struct CmdImageQuad FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdImageQuadBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USER_TEXTURE_ID = 4,
    VT_P1 = 6,
    VT_P2 = 8,
    VT_P3 = 10,
    VT_P4 = 12,
    VT_UV1 = 14,
    VT_UV2 = 16,
    VT_UV3 = 18,
    VT_UV4 = 20,
    VT_COL = 22
  };
  uint64_t user_texture_id() const {
    return GetField<uint64_t>(VT_USER_TEXTURE_ID, 0);
  }
  const VectorCmdFB::SingleVec2 *p1() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_P1);
  }
  const VectorCmdFB::SingleVec2 *p2() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_P2);
  }
  const VectorCmdFB::SingleVec2 *p3() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_P3);
  }
  const VectorCmdFB::SingleVec2 *p4() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_P4);
  }
  const VectorCmdFB::SingleVec2 *uv1() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_UV1);
  }
  const VectorCmdFB::SingleVec2 *uv2() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_UV2);
  }
  const VectorCmdFB::SingleVec2 *uv3() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_UV3);
  }
  const VectorCmdFB::SingleVec2 *uv4() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_UV4);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_USER_TEXTURE_ID, 8) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_P1, 4) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_P2, 4) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_P3, 4) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_P4, 4) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_UV1, 4) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_UV2, 4) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_UV3, 4) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_UV4, 4) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           verifier.EndTable();
  }
};

struct CmdImageQuadBuilder {
  typedef CmdImageQuad Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_user_texture_id(uint64_t user_texture_id) {
    fbb_.AddElement<uint64_t>(CmdImageQuad::VT_USER_TEXTURE_ID, user_texture_id, 0);
  }
  void add_p1(const VectorCmdFB::SingleVec2 *p1) {
    fbb_.AddStruct(CmdImageQuad::VT_P1, p1);
  }
  void add_p2(const VectorCmdFB::SingleVec2 *p2) {
    fbb_.AddStruct(CmdImageQuad::VT_P2, p2);
  }
  void add_p3(const VectorCmdFB::SingleVec2 *p3) {
    fbb_.AddStruct(CmdImageQuad::VT_P3, p3);
  }
  void add_p4(const VectorCmdFB::SingleVec2 *p4) {
    fbb_.AddStruct(CmdImageQuad::VT_P4, p4);
  }
  void add_uv1(const VectorCmdFB::SingleVec2 *uv1) {
    fbb_.AddStruct(CmdImageQuad::VT_UV1, uv1);
  }
  void add_uv2(const VectorCmdFB::SingleVec2 *uv2) {
    fbb_.AddStruct(CmdImageQuad::VT_UV2, uv2);
  }
  void add_uv3(const VectorCmdFB::SingleVec2 *uv3) {
    fbb_.AddStruct(CmdImageQuad::VT_UV3, uv3);
  }
  void add_uv4(const VectorCmdFB::SingleVec2 *uv4) {
    fbb_.AddStruct(CmdImageQuad::VT_UV4, uv4);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdImageQuad::VT_COL, col, 0);
  }
  explicit CmdImageQuadBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdImageQuad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdImageQuad>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdImageQuad> CreateCmdImageQuad(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t user_texture_id = 0,
    const VectorCmdFB::SingleVec2 *p1 = nullptr,
    const VectorCmdFB::SingleVec2 *p2 = nullptr,
    const VectorCmdFB::SingleVec2 *p3 = nullptr,
    const VectorCmdFB::SingleVec2 *p4 = nullptr,
    const VectorCmdFB::SingleVec2 *uv1 = nullptr,
    const VectorCmdFB::SingleVec2 *uv2 = nullptr,
    const VectorCmdFB::SingleVec2 *uv3 = nullptr,
    const VectorCmdFB::SingleVec2 *uv4 = nullptr,
    uint32_t col = 0) {
  CmdImageQuadBuilder builder_(_fbb);
  builder_.add_user_texture_id(user_texture_id);
  builder_.add_col(col);
  builder_.add_uv4(uv4);
  builder_.add_uv3(uv3);
  builder_.add_uv2(uv2);
  builder_.add_uv1(uv1);
  builder_.add_p4(p4);
  builder_.add_p3(p3);
  builder_.add_p2(p2);
  builder_.add_p1(p1);
  return builder_.Finish();
}

struct CmdImageRounded FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdImageRoundedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USER_TEXTURE_ID = 4,
    VT_P_MIN = 6,
    VT_P_MAX = 8,
    VT_UV_MIN = 10,
    VT_UV_MAX = 12,
    VT_COL = 14,
    VT_ROUNDING = 16,
    VT_FLAGS = 18
  };
  uint64_t user_texture_id() const {
    return GetField<uint64_t>(VT_USER_TEXTURE_ID, 0);
  }
  const VectorCmdFB::SingleVec2 *p_min() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_P_MIN);
  }
  const VectorCmdFB::SingleVec2 *p_max() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_P_MAX);
  }
  const VectorCmdFB::SingleVec2 *uv_min() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_UV_MIN);
  }
  const VectorCmdFB::SingleVec2 *uv_max() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_UV_MAX);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  float rounding() const {
    return GetField<float>(VT_ROUNDING, 0.0f);
  }
  uint32_t flags() const {
    return GetField<uint32_t>(VT_FLAGS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_USER_TEXTURE_ID, 8) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_P_MIN, 4) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_P_MAX, 4) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_UV_MIN, 4) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_UV_MAX, 4) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           VerifyField<float>(verifier, VT_ROUNDING, 4) &&
           VerifyField<uint32_t>(verifier, VT_FLAGS, 4) &&
           verifier.EndTable();
  }
};

struct CmdImageRoundedBuilder {
  typedef CmdImageRounded Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_user_texture_id(uint64_t user_texture_id) {
    fbb_.AddElement<uint64_t>(CmdImageRounded::VT_USER_TEXTURE_ID, user_texture_id, 0);
  }
  void add_p_min(const VectorCmdFB::SingleVec2 *p_min) {
    fbb_.AddStruct(CmdImageRounded::VT_P_MIN, p_min);
  }
  void add_p_max(const VectorCmdFB::SingleVec2 *p_max) {
    fbb_.AddStruct(CmdImageRounded::VT_P_MAX, p_max);
  }
  void add_uv_min(const VectorCmdFB::SingleVec2 *uv_min) {
    fbb_.AddStruct(CmdImageRounded::VT_UV_MIN, uv_min);
  }
  void add_uv_max(const VectorCmdFB::SingleVec2 *uv_max) {
    fbb_.AddStruct(CmdImageRounded::VT_UV_MAX, uv_max);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdImageRounded::VT_COL, col, 0);
  }
  void add_rounding(float rounding) {
    fbb_.AddElement<float>(CmdImageRounded::VT_ROUNDING, rounding, 0.0f);
  }
  void add_flags(uint32_t flags) {
    fbb_.AddElement<uint32_t>(CmdImageRounded::VT_FLAGS, flags, 0);
  }
  explicit CmdImageRoundedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdImageRounded> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdImageRounded>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdImageRounded> CreateCmdImageRounded(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t user_texture_id = 0,
    const VectorCmdFB::SingleVec2 *p_min = nullptr,
    const VectorCmdFB::SingleVec2 *p_max = nullptr,
    const VectorCmdFB::SingleVec2 *uv_min = nullptr,
    const VectorCmdFB::SingleVec2 *uv_max = nullptr,
    uint32_t col = 0,
    float rounding = 0.0f,
    uint32_t flags = 0) {
  CmdImageRoundedBuilder builder_(_fbb);
  builder_.add_user_texture_id(user_texture_id);
  builder_.add_flags(flags);
  builder_.add_rounding(rounding);
  builder_.add_col(col);
  builder_.add_uv_max(uv_max);
  builder_.add_uv_min(uv_min);
  builder_.add_p_max(p_max);
  builder_.add_p_min(p_min);
  return builder_.Finish();
}

struct CmdPushClipRect FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdPushClipRectBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RECT = 4,
    VT_INTERSECTED_WITH_CURRENT_CLIP_RECT = 6
  };
  const VectorCmdFB::SingleVec4 *rect() const {
    return GetStruct<const VectorCmdFB::SingleVec4 *>(VT_RECT);
  }
  bool intersected_with_current_clip_rect() const {
    return GetField<uint8_t>(VT_INTERSECTED_WITH_CURRENT_CLIP_RECT, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<VectorCmdFB::SingleVec4>(verifier, VT_RECT, 4) &&
           VerifyField<uint8_t>(verifier, VT_INTERSECTED_WITH_CURRENT_CLIP_RECT, 1) &&
           verifier.EndTable();
  }
};

struct CmdPushClipRectBuilder {
  typedef CmdPushClipRect Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_rect(const VectorCmdFB::SingleVec4 *rect) {
    fbb_.AddStruct(CmdPushClipRect::VT_RECT, rect);
  }
  void add_intersected_with_current_clip_rect(bool intersected_with_current_clip_rect) {
    fbb_.AddElement<uint8_t>(CmdPushClipRect::VT_INTERSECTED_WITH_CURRENT_CLIP_RECT, static_cast<uint8_t>(intersected_with_current_clip_rect), 0);
  }
  explicit CmdPushClipRectBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdPushClipRect> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdPushClipRect>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdPushClipRect> CreateCmdPushClipRect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const VectorCmdFB::SingleVec4 *rect = nullptr,
    bool intersected_with_current_clip_rect = false) {
  CmdPushClipRectBuilder builder_(_fbb);
  builder_.add_rect(rect);
  builder_.add_intersected_with_current_clip_rect(intersected_with_current_clip_rect);
  return builder_.Finish();
}

struct CmdPopClipRect FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdPopClipRectBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct CmdPopClipRectBuilder {
  typedef CmdPopClipRect Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit CmdPopClipRectBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdPopClipRect> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdPopClipRect>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdPopClipRect> CreateCmdPopClipRect(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  CmdPopClipRectBuilder builder_(_fbb);
  return builder_.Finish();
}

struct CmdRenderText FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdRenderTextBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IMFONT = 4,
    VT_SIZE = 6,
    VT_POS = 8,
    VT_COL = 10,
    VT_CLIP_RECT = 12,
    VT_TEXT = 14
  };
  uint64_t imfont() const {
    return GetField<uint64_t>(VT_IMFONT, 0);
  }
  float size() const {
    return GetField<float>(VT_SIZE, 0.0f);
  }
  const VectorCmdFB::SingleVec2 *pos() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_POS);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  const VectorCmdFB::SingleVec4 *clip_rect() const {
    return GetStruct<const VectorCmdFB::SingleVec4 *>(VT_CLIP_RECT);
  }
  const ::flatbuffers::String *text() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TEXT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_IMFONT, 8) &&
           VerifyField<float>(verifier, VT_SIZE, 4) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_POS, 4) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           VerifyField<VectorCmdFB::SingleVec4>(verifier, VT_CLIP_RECT, 4) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           verifier.EndTable();
  }
};

struct CmdRenderTextBuilder {
  typedef CmdRenderText Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_imfont(uint64_t imfont) {
    fbb_.AddElement<uint64_t>(CmdRenderText::VT_IMFONT, imfont, 0);
  }
  void add_size(float size) {
    fbb_.AddElement<float>(CmdRenderText::VT_SIZE, size, 0.0f);
  }
  void add_pos(const VectorCmdFB::SingleVec2 *pos) {
    fbb_.AddStruct(CmdRenderText::VT_POS, pos);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdRenderText::VT_COL, col, 0);
  }
  void add_clip_rect(const VectorCmdFB::SingleVec4 *clip_rect) {
    fbb_.AddStruct(CmdRenderText::VT_CLIP_RECT, clip_rect);
  }
  void add_text(::flatbuffers::Offset<::flatbuffers::String> text) {
    fbb_.AddOffset(CmdRenderText::VT_TEXT, text);
  }
  explicit CmdRenderTextBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdRenderText> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdRenderText>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdRenderText> CreateCmdRenderText(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t imfont = 0,
    float size = 0.0f,
    const VectorCmdFB::SingleVec2 *pos = nullptr,
    uint32_t col = 0,
    const VectorCmdFB::SingleVec4 *clip_rect = nullptr,
    ::flatbuffers::Offset<::flatbuffers::String> text = 0) {
  CmdRenderTextBuilder builder_(_fbb);
  builder_.add_imfont(imfont);
  builder_.add_text(text);
  builder_.add_clip_rect(clip_rect);
  builder_.add_col(col);
  builder_.add_pos(pos);
  builder_.add_size(size);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CmdRenderText> CreateCmdRenderTextDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t imfont = 0,
    float size = 0.0f,
    const VectorCmdFB::SingleVec2 *pos = nullptr,
    uint32_t col = 0,
    const VectorCmdFB::SingleVec4 *clip_rect = nullptr,
    const char *text = nullptr) {
  auto text__ = text ? _fbb.CreateString(text) : 0;
  return VectorCmdFB::CreateCmdRenderText(
      _fbb,
      imfont,
      size,
      pos,
      col,
      clip_rect,
      text__);
}

struct CmdRenderParagraph FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdRenderParagraphBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IMFONT = 4,
    VT_SIZE = 6,
    VT_POS = 8,
    VT_COL = 10,
    VT_CLIP_RECT = 12,
    VT_TEXT = 14,
    VT_WRAP_WIDTH = 16,
    VT_LETTER_SPACING = 18,
    VT_TEXT_ALIGN = 20
  };
  uint64_t imfont() const {
    return GetField<uint64_t>(VT_IMFONT, 0);
  }
  float size() const {
    return GetField<float>(VT_SIZE, 0.0f);
  }
  const VectorCmdFB::SingleVec2 *pos() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_POS);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  const VectorCmdFB::SingleVec4 *clip_rect() const {
    return GetStruct<const VectorCmdFB::SingleVec4 *>(VT_CLIP_RECT);
  }
  const ::flatbuffers::String *text() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TEXT);
  }
  float wrap_width() const {
    return GetField<float>(VT_WRAP_WIDTH, 0.0f);
  }
  float letter_spacing() const {
    return GetField<float>(VT_LETTER_SPACING, 0.0f);
  }
  VectorCmdFB::TextAlignFlags text_align() const {
    return static_cast<VectorCmdFB::TextAlignFlags>(GetField<uint8_t>(VT_TEXT_ALIGN, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_IMFONT, 8) &&
           VerifyField<float>(verifier, VT_SIZE, 4) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_POS, 4) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           VerifyField<VectorCmdFB::SingleVec4>(verifier, VT_CLIP_RECT, 4) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           VerifyField<float>(verifier, VT_WRAP_WIDTH, 4) &&
           VerifyField<float>(verifier, VT_LETTER_SPACING, 4) &&
           VerifyField<uint8_t>(verifier, VT_TEXT_ALIGN, 1) &&
           verifier.EndTable();
  }
};

struct CmdRenderParagraphBuilder {
  typedef CmdRenderParagraph Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_imfont(uint64_t imfont) {
    fbb_.AddElement<uint64_t>(CmdRenderParagraph::VT_IMFONT, imfont, 0);
  }
  void add_size(float size) {
    fbb_.AddElement<float>(CmdRenderParagraph::VT_SIZE, size, 0.0f);
  }
  void add_pos(const VectorCmdFB::SingleVec2 *pos) {
    fbb_.AddStruct(CmdRenderParagraph::VT_POS, pos);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdRenderParagraph::VT_COL, col, 0);
  }
  void add_clip_rect(const VectorCmdFB::SingleVec4 *clip_rect) {
    fbb_.AddStruct(CmdRenderParagraph::VT_CLIP_RECT, clip_rect);
  }
  void add_text(::flatbuffers::Offset<::flatbuffers::String> text) {
    fbb_.AddOffset(CmdRenderParagraph::VT_TEXT, text);
  }
  void add_wrap_width(float wrap_width) {
    fbb_.AddElement<float>(CmdRenderParagraph::VT_WRAP_WIDTH, wrap_width, 0.0f);
  }
  void add_letter_spacing(float letter_spacing) {
    fbb_.AddElement<float>(CmdRenderParagraph::VT_LETTER_SPACING, letter_spacing, 0.0f);
  }
  void add_text_align(VectorCmdFB::TextAlignFlags text_align) {
    fbb_.AddElement<uint8_t>(CmdRenderParagraph::VT_TEXT_ALIGN, static_cast<uint8_t>(text_align), 0);
  }
  explicit CmdRenderParagraphBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdRenderParagraph> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdRenderParagraph>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdRenderParagraph> CreateCmdRenderParagraph(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t imfont = 0,
    float size = 0.0f,
    const VectorCmdFB::SingleVec2 *pos = nullptr,
    uint32_t col = 0,
    const VectorCmdFB::SingleVec4 *clip_rect = nullptr,
    ::flatbuffers::Offset<::flatbuffers::String> text = 0,
    float wrap_width = 0.0f,
    float letter_spacing = 0.0f,
    VectorCmdFB::TextAlignFlags text_align = VectorCmdFB::TextAlignFlags_left) {
  CmdRenderParagraphBuilder builder_(_fbb);
  builder_.add_imfont(imfont);
  builder_.add_letter_spacing(letter_spacing);
  builder_.add_wrap_width(wrap_width);
  builder_.add_text(text);
  builder_.add_clip_rect(clip_rect);
  builder_.add_col(col);
  builder_.add_pos(pos);
  builder_.add_size(size);
  builder_.add_text_align(text_align);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CmdRenderParagraph> CreateCmdRenderParagraphDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t imfont = 0,
    float size = 0.0f,
    const VectorCmdFB::SingleVec2 *pos = nullptr,
    uint32_t col = 0,
    const VectorCmdFB::SingleVec4 *clip_rect = nullptr,
    const char *text = nullptr,
    float wrap_width = 0.0f,
    float letter_spacing = 0.0f,
    VectorCmdFB::TextAlignFlags text_align = VectorCmdFB::TextAlignFlags_left) {
  auto text__ = text ? _fbb.CreateString(text) : 0;
  return VectorCmdFB::CreateCmdRenderParagraph(
      _fbb,
      imfont,
      size,
      pos,
      col,
      clip_rect,
      text__,
      wrap_width,
      letter_spacing,
      text_align);
}

struct CmdRenderUnicodeCodepoint FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdRenderUnicodeCodepointBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IMFONT = 4,
    VT_SIZE = 6,
    VT_POS = 8,
    VT_COL = 10,
    VT_CLIP_RECT = 12,
    VT_CODEPOINT = 14
  };
  uint64_t imfont() const {
    return GetField<uint64_t>(VT_IMFONT, 0);
  }
  float size() const {
    return GetField<float>(VT_SIZE, 0.0f);
  }
  const VectorCmdFB::SingleVec2 *pos() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_POS);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  const VectorCmdFB::SingleVec4 *clip_rect() const {
    return GetStruct<const VectorCmdFB::SingleVec4 *>(VT_CLIP_RECT);
  }
  uint32_t codepoint() const {
    return GetField<uint32_t>(VT_CODEPOINT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_IMFONT, 8) &&
           VerifyField<float>(verifier, VT_SIZE, 4) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_POS, 4) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           VerifyField<VectorCmdFB::SingleVec4>(verifier, VT_CLIP_RECT, 4) &&
           VerifyField<uint32_t>(verifier, VT_CODEPOINT, 4) &&
           verifier.EndTable();
  }
};

struct CmdRenderUnicodeCodepointBuilder {
  typedef CmdRenderUnicodeCodepoint Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_imfont(uint64_t imfont) {
    fbb_.AddElement<uint64_t>(CmdRenderUnicodeCodepoint::VT_IMFONT, imfont, 0);
  }
  void add_size(float size) {
    fbb_.AddElement<float>(CmdRenderUnicodeCodepoint::VT_SIZE, size, 0.0f);
  }
  void add_pos(const VectorCmdFB::SingleVec2 *pos) {
    fbb_.AddStruct(CmdRenderUnicodeCodepoint::VT_POS, pos);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdRenderUnicodeCodepoint::VT_COL, col, 0);
  }
  void add_clip_rect(const VectorCmdFB::SingleVec4 *clip_rect) {
    fbb_.AddStruct(CmdRenderUnicodeCodepoint::VT_CLIP_RECT, clip_rect);
  }
  void add_codepoint(uint32_t codepoint) {
    fbb_.AddElement<uint32_t>(CmdRenderUnicodeCodepoint::VT_CODEPOINT, codepoint, 0);
  }
  explicit CmdRenderUnicodeCodepointBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdRenderUnicodeCodepoint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdRenderUnicodeCodepoint>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdRenderUnicodeCodepoint> CreateCmdRenderUnicodeCodepoint(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t imfont = 0,
    float size = 0.0f,
    const VectorCmdFB::SingleVec2 *pos = nullptr,
    uint32_t col = 0,
    const VectorCmdFB::SingleVec4 *clip_rect = nullptr,
    uint32_t codepoint = 0) {
  CmdRenderUnicodeCodepointBuilder builder_(_fbb);
  builder_.add_imfont(imfont);
  builder_.add_codepoint(codepoint);
  builder_.add_clip_rect(clip_rect);
  builder_.add_col(col);
  builder_.add_pos(pos);
  builder_.add_size(size);
  return builder_.Finish();
}

struct CmdTranslation FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdTranslationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TRANSLATION = 4
  };
  const VectorCmdFB::SingleVec2 *translation() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_TRANSLATION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_TRANSLATION, 4) &&
           verifier.EndTable();
  }
};

struct CmdTranslationBuilder {
  typedef CmdTranslation Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_translation(const VectorCmdFB::SingleVec2 *translation) {
    fbb_.AddStruct(CmdTranslation::VT_TRANSLATION, translation);
  }
  explicit CmdTranslationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdTranslation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdTranslation>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdTranslation> CreateCmdTranslation(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const VectorCmdFB::SingleVec2 *translation = nullptr) {
  CmdTranslationBuilder builder_(_fbb);
  builder_.add_translation(translation);
  return builder_.Finish();
}

struct PopTranslation FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PopTranslationBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct PopTranslationBuilder {
  typedef PopTranslation Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit PopTranslationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PopTranslation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PopTranslation>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PopTranslation> CreatePopTranslation(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  PopTranslationBuilder builder_(_fbb);
  return builder_.Finish();
}

struct CmdPushRotation FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdPushRotationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COS_ALPHA = 4,
    VT_SIN_ALPHA = 6
  };
  float cos_alpha() const {
    return GetField<float>(VT_COS_ALPHA, 0.0f);
  }
  float sin_alpha() const {
    return GetField<float>(VT_SIN_ALPHA, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_COS_ALPHA, 4) &&
           VerifyField<float>(verifier, VT_SIN_ALPHA, 4) &&
           verifier.EndTable();
  }
};

struct CmdPushRotationBuilder {
  typedef CmdPushRotation Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_cos_alpha(float cos_alpha) {
    fbb_.AddElement<float>(CmdPushRotation::VT_COS_ALPHA, cos_alpha, 0.0f);
  }
  void add_sin_alpha(float sin_alpha) {
    fbb_.AddElement<float>(CmdPushRotation::VT_SIN_ALPHA, sin_alpha, 0.0f);
  }
  explicit CmdPushRotationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdPushRotation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdPushRotation>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdPushRotation> CreateCmdPushRotation(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float cos_alpha = 0.0f,
    float sin_alpha = 0.0f) {
  CmdPushRotationBuilder builder_(_fbb);
  builder_.add_sin_alpha(sin_alpha);
  builder_.add_cos_alpha(cos_alpha);
  return builder_.Finish();
}

struct CmdPopRotation FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdPopRotationBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct CmdPopRotationBuilder {
  typedef CmdPopRotation Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit CmdPopRotationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdPopRotation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdPopRotation>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdPopRotation> CreateCmdPopRotation(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  CmdPopRotationBuilder builder_(_fbb);
  return builder_.Finish();
}

struct CmdRectFilledMultiColor FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdRectFilledMultiColorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_P_MIN = 4,
    VT_P_MAX = 6,
    VT_COL_UPR_LEFT = 8,
    VT_COL_UPR_RIGHT = 10,
    VT_COL_BOT_RIGHT = 12,
    VT_COL_BOT_LEFT = 14
  };
  const VectorCmdFB::SingleVec2 *p_min() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_P_MIN);
  }
  const VectorCmdFB::SingleVec2 *p_max() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_P_MAX);
  }
  uint32_t col_upr_left() const {
    return GetField<uint32_t>(VT_COL_UPR_LEFT, 0);
  }
  uint32_t col_upr_right() const {
    return GetField<uint32_t>(VT_COL_UPR_RIGHT, 0);
  }
  uint32_t col_bot_right() const {
    return GetField<uint32_t>(VT_COL_BOT_RIGHT, 0);
  }
  uint32_t col_bot_left() const {
    return GetField<uint32_t>(VT_COL_BOT_LEFT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_P_MIN, 4) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_P_MAX, 4) &&
           VerifyField<uint32_t>(verifier, VT_COL_UPR_LEFT, 4) &&
           VerifyField<uint32_t>(verifier, VT_COL_UPR_RIGHT, 4) &&
           VerifyField<uint32_t>(verifier, VT_COL_BOT_RIGHT, 4) &&
           VerifyField<uint32_t>(verifier, VT_COL_BOT_LEFT, 4) &&
           verifier.EndTable();
  }
};

struct CmdRectFilledMultiColorBuilder {
  typedef CmdRectFilledMultiColor Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_p_min(const VectorCmdFB::SingleVec2 *p_min) {
    fbb_.AddStruct(CmdRectFilledMultiColor::VT_P_MIN, p_min);
  }
  void add_p_max(const VectorCmdFB::SingleVec2 *p_max) {
    fbb_.AddStruct(CmdRectFilledMultiColor::VT_P_MAX, p_max);
  }
  void add_col_upr_left(uint32_t col_upr_left) {
    fbb_.AddElement<uint32_t>(CmdRectFilledMultiColor::VT_COL_UPR_LEFT, col_upr_left, 0);
  }
  void add_col_upr_right(uint32_t col_upr_right) {
    fbb_.AddElement<uint32_t>(CmdRectFilledMultiColor::VT_COL_UPR_RIGHT, col_upr_right, 0);
  }
  void add_col_bot_right(uint32_t col_bot_right) {
    fbb_.AddElement<uint32_t>(CmdRectFilledMultiColor::VT_COL_BOT_RIGHT, col_bot_right, 0);
  }
  void add_col_bot_left(uint32_t col_bot_left) {
    fbb_.AddElement<uint32_t>(CmdRectFilledMultiColor::VT_COL_BOT_LEFT, col_bot_left, 0);
  }
  explicit CmdRectFilledMultiColorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdRectFilledMultiColor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdRectFilledMultiColor>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdRectFilledMultiColor> CreateCmdRectFilledMultiColor(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const VectorCmdFB::SingleVec2 *p_min = nullptr,
    const VectorCmdFB::SingleVec2 *p_max = nullptr,
    uint32_t col_upr_left = 0,
    uint32_t col_upr_right = 0,
    uint32_t col_bot_right = 0,
    uint32_t col_bot_left = 0) {
  CmdRectFilledMultiColorBuilder builder_(_fbb);
  builder_.add_col_bot_left(col_bot_left);
  builder_.add_col_bot_right(col_bot_right);
  builder_.add_col_upr_right(col_upr_right);
  builder_.add_col_upr_left(col_upr_left);
  builder_.add_p_max(p_max);
  builder_.add_p_min(p_min);
  return builder_.Finish();
}

struct CmdWrappedDrawList FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdWrappedDrawListBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BUFFER = 4
  };
  const ::flatbuffers::Vector<uint8_t> *buffer() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_BUFFER);
  }
  const VectorCmdFB::DrawList *buffer_nested_root() const {
    const auto _f = buffer();
    return _f ? ::flatbuffers::GetRoot<VectorCmdFB::DrawList>(_f->Data())
              : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BUFFER) &&
           verifier.VerifyVector(buffer()) &&
           verifier.VerifyNestedFlatBuffer<VectorCmdFB::DrawList>(buffer(), nullptr) &&
           verifier.EndTable();
  }
};

struct CmdWrappedDrawListBuilder {
  typedef CmdWrappedDrawList Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_buffer(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> buffer) {
    fbb_.AddOffset(CmdWrappedDrawList::VT_BUFFER, buffer);
  }
  explicit CmdWrappedDrawListBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdWrappedDrawList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdWrappedDrawList>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdWrappedDrawList> CreateCmdWrappedDrawList(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> buffer = 0) {
  CmdWrappedDrawListBuilder builder_(_fbb);
  builder_.add_buffer(buffer);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CmdWrappedDrawList> CreateCmdWrappedDrawListDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *buffer = nullptr) {
  auto buffer__ = buffer ? _fbb.CreateVector<uint8_t>(*buffer) : 0;
  return VectorCmdFB::CreateCmdWrappedDrawList(
      _fbb,
      buffer__);
}

struct CmdVertexDraw FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdVertexDrawBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLIP_RECT = 4,
    VT_ELEMENT_COUNT = 6,
    VT_INDEX_OFFSET = 8,
    VT_VTX_OFFSET = 10
  };
  const VectorCmdFB::SingleVec4 *clip_rect() const {
    return GetStruct<const VectorCmdFB::SingleVec4 *>(VT_CLIP_RECT);
  }
  uint32_t element_count() const {
    return GetField<uint32_t>(VT_ELEMENT_COUNT, 0);
  }
  uint32_t index_offset() const {
    return GetField<uint32_t>(VT_INDEX_OFFSET, 0);
  }
  uint32_t vtx_offset() const {
    return GetField<uint32_t>(VT_VTX_OFFSET, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<VectorCmdFB::SingleVec4>(verifier, VT_CLIP_RECT, 4) &&
           VerifyField<uint32_t>(verifier, VT_ELEMENT_COUNT, 4) &&
           VerifyField<uint32_t>(verifier, VT_INDEX_OFFSET, 4) &&
           VerifyField<uint32_t>(verifier, VT_VTX_OFFSET, 4) &&
           verifier.EndTable();
  }
};

struct CmdVertexDrawBuilder {
  typedef CmdVertexDraw Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_clip_rect(const VectorCmdFB::SingleVec4 *clip_rect) {
    fbb_.AddStruct(CmdVertexDraw::VT_CLIP_RECT, clip_rect);
  }
  void add_element_count(uint32_t element_count) {
    fbb_.AddElement<uint32_t>(CmdVertexDraw::VT_ELEMENT_COUNT, element_count, 0);
  }
  void add_index_offset(uint32_t index_offset) {
    fbb_.AddElement<uint32_t>(CmdVertexDraw::VT_INDEX_OFFSET, index_offset, 0);
  }
  void add_vtx_offset(uint32_t vtx_offset) {
    fbb_.AddElement<uint32_t>(CmdVertexDraw::VT_VTX_OFFSET, vtx_offset, 0);
  }
  explicit CmdVertexDrawBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdVertexDraw> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdVertexDraw>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdVertexDraw> CreateCmdVertexDraw(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const VectorCmdFB::SingleVec4 *clip_rect = nullptr,
    uint32_t element_count = 0,
    uint32_t index_offset = 0,
    uint32_t vtx_offset = 0) {
  CmdVertexDrawBuilder builder_(_fbb);
  builder_.add_vtx_offset(vtx_offset);
  builder_.add_index_offset(index_offset);
  builder_.add_element_count(element_count);
  builder_.add_clip_rect(clip_rect);
  return builder_.Finish();
}

struct CmdSimpleVertexDraw FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdSimpleVertexDrawBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLIP_RECT = 4,
    VT_POS_XY = 6,
    VT_COL = 8
  };
  const VectorCmdFB::SingleVec4 *clip_rect() const {
    return GetStruct<const VectorCmdFB::SingleVec4 *>(VT_CLIP_RECT);
  }
  const ::flatbuffers::Vector<float> *pos_xy() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_POS_XY);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<VectorCmdFB::SingleVec4>(verifier, VT_CLIP_RECT, 4) &&
           VerifyOffset(verifier, VT_POS_XY) &&
           verifier.VerifyVector(pos_xy()) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           verifier.EndTable();
  }
};

struct CmdSimpleVertexDrawBuilder {
  typedef CmdSimpleVertexDraw Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_clip_rect(const VectorCmdFB::SingleVec4 *clip_rect) {
    fbb_.AddStruct(CmdSimpleVertexDraw::VT_CLIP_RECT, clip_rect);
  }
  void add_pos_xy(::flatbuffers::Offset<::flatbuffers::Vector<float>> pos_xy) {
    fbb_.AddOffset(CmdSimpleVertexDraw::VT_POS_XY, pos_xy);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdSimpleVertexDraw::VT_COL, col, 0);
  }
  explicit CmdSimpleVertexDrawBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdSimpleVertexDraw> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdSimpleVertexDraw>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdSimpleVertexDraw> CreateCmdSimpleVertexDraw(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const VectorCmdFB::SingleVec4 *clip_rect = nullptr,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> pos_xy = 0,
    uint32_t col = 0) {
  CmdSimpleVertexDrawBuilder builder_(_fbb);
  builder_.add_col(col);
  builder_.add_pos_xy(pos_xy);
  builder_.add_clip_rect(clip_rect);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CmdSimpleVertexDraw> CreateCmdSimpleVertexDrawDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const VectorCmdFB::SingleVec4 *clip_rect = nullptr,
    const std::vector<float> *pos_xy = nullptr,
    uint32_t col = 0) {
  auto pos_xy__ = pos_xy ? _fbb.CreateVector<float>(*pos_xy) : 0;
  return VectorCmdFB::CreateCmdSimpleVertexDraw(
      _fbb,
      clip_rect,
      pos_xy__,
      col);
}

struct CmdSvgPathSubset FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdSvgPathSubsetBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SVG = 4,
    VT_COL = 6,
    VT_STROKE = 8,
    VT_FILL = 10
  };
  const ::flatbuffers::String *svg() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SVG);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  bool stroke() const {
    return GetField<uint8_t>(VT_STROKE, 0) != 0;
  }
  bool fill() const {
    return GetField<uint8_t>(VT_FILL, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SVG) &&
           verifier.VerifyString(svg()) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           VerifyField<uint8_t>(verifier, VT_STROKE, 1) &&
           VerifyField<uint8_t>(verifier, VT_FILL, 1) &&
           verifier.EndTable();
  }
};

struct CmdSvgPathSubsetBuilder {
  typedef CmdSvgPathSubset Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_svg(::flatbuffers::Offset<::flatbuffers::String> svg) {
    fbb_.AddOffset(CmdSvgPathSubset::VT_SVG, svg);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdSvgPathSubset::VT_COL, col, 0);
  }
  void add_stroke(bool stroke) {
    fbb_.AddElement<uint8_t>(CmdSvgPathSubset::VT_STROKE, static_cast<uint8_t>(stroke), 0);
  }
  void add_fill(bool fill) {
    fbb_.AddElement<uint8_t>(CmdSvgPathSubset::VT_FILL, static_cast<uint8_t>(fill), 0);
  }
  explicit CmdSvgPathSubsetBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdSvgPathSubset> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdSvgPathSubset>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdSvgPathSubset> CreateCmdSvgPathSubset(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> svg = 0,
    uint32_t col = 0,
    bool stroke = false,
    bool fill = false) {
  CmdSvgPathSubsetBuilder builder_(_fbb);
  builder_.add_col(col);
  builder_.add_svg(svg);
  builder_.add_fill(fill);
  builder_.add_stroke(stroke);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CmdSvgPathSubset> CreateCmdSvgPathSubsetDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *svg = nullptr,
    uint32_t col = 0,
    bool stroke = false,
    bool fill = false) {
  auto svg__ = svg ? _fbb.CreateString(svg) : 0;
  return VectorCmdFB::CreateCmdSvgPathSubset(
      _fbb,
      svg__,
      col,
      stroke,
      fill);
}

struct CmdPath FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CmdPathBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OFFSET = 4,
    VT_VERBS = 6,
    VT_POINTS_XY = 8,
    VT_CONIC_WEIGHTS = 10,
    VT_COL = 12,
    VT_STROKE = 14,
    VT_FILL = 16,
    VT_FILL_TYPE = 18
  };
  const VectorCmdFB::SingleVec2 *offset() const {
    return GetStruct<const VectorCmdFB::SingleVec2 *>(VT_OFFSET);
  }
  const ::flatbuffers::Vector<uint8_t> *verbs() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_VERBS);
  }
  const ::flatbuffers::Vector<float> *points_xy() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_POINTS_XY);
  }
  const ::flatbuffers::Vector<float> *conic_weights() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_CONIC_WEIGHTS);
  }
  uint32_t col() const {
    return GetField<uint32_t>(VT_COL, 0);
  }
  bool stroke() const {
    return GetField<uint8_t>(VT_STROKE, 0) != 0;
  }
  bool fill() const {
    return GetField<uint8_t>(VT_FILL, 0) != 0;
  }
  VectorCmdFB::PathFillType fill_type() const {
    return static_cast<VectorCmdFB::PathFillType>(GetField<uint8_t>(VT_FILL_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<VectorCmdFB::SingleVec2>(verifier, VT_OFFSET, 4) &&
           VerifyOffset(verifier, VT_VERBS) &&
           verifier.VerifyVector(verbs()) &&
           VerifyOffset(verifier, VT_POINTS_XY) &&
           verifier.VerifyVector(points_xy()) &&
           VerifyOffset(verifier, VT_CONIC_WEIGHTS) &&
           verifier.VerifyVector(conic_weights()) &&
           VerifyField<uint32_t>(verifier, VT_COL, 4) &&
           VerifyField<uint8_t>(verifier, VT_STROKE, 1) &&
           VerifyField<uint8_t>(verifier, VT_FILL, 1) &&
           VerifyField<uint8_t>(verifier, VT_FILL_TYPE, 1) &&
           verifier.EndTable();
  }
};

struct CmdPathBuilder {
  typedef CmdPath Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_offset(const VectorCmdFB::SingleVec2 *offset) {
    fbb_.AddStruct(CmdPath::VT_OFFSET, offset);
  }
  void add_verbs(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> verbs) {
    fbb_.AddOffset(CmdPath::VT_VERBS, verbs);
  }
  void add_points_xy(::flatbuffers::Offset<::flatbuffers::Vector<float>> points_xy) {
    fbb_.AddOffset(CmdPath::VT_POINTS_XY, points_xy);
  }
  void add_conic_weights(::flatbuffers::Offset<::flatbuffers::Vector<float>> conic_weights) {
    fbb_.AddOffset(CmdPath::VT_CONIC_WEIGHTS, conic_weights);
  }
  void add_col(uint32_t col) {
    fbb_.AddElement<uint32_t>(CmdPath::VT_COL, col, 0);
  }
  void add_stroke(bool stroke) {
    fbb_.AddElement<uint8_t>(CmdPath::VT_STROKE, static_cast<uint8_t>(stroke), 0);
  }
  void add_fill(bool fill) {
    fbb_.AddElement<uint8_t>(CmdPath::VT_FILL, static_cast<uint8_t>(fill), 0);
  }
  void add_fill_type(VectorCmdFB::PathFillType fill_type) {
    fbb_.AddElement<uint8_t>(CmdPath::VT_FILL_TYPE, static_cast<uint8_t>(fill_type), 0);
  }
  explicit CmdPathBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CmdPath> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CmdPath>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CmdPath> CreateCmdPath(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const VectorCmdFB::SingleVec2 *offset = nullptr,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> verbs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> points_xy = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> conic_weights = 0,
    uint32_t col = 0,
    bool stroke = false,
    bool fill = false,
    VectorCmdFB::PathFillType fill_type = VectorCmdFB::PathFillType_winding) {
  CmdPathBuilder builder_(_fbb);
  builder_.add_col(col);
  builder_.add_conic_weights(conic_weights);
  builder_.add_points_xy(points_xy);
  builder_.add_verbs(verbs);
  builder_.add_offset(offset);
  builder_.add_fill_type(fill_type);
  builder_.add_fill(fill);
  builder_.add_stroke(stroke);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CmdPath> CreateCmdPathDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const VectorCmdFB::SingleVec2 *offset = nullptr,
    const std::vector<uint8_t> *verbs = nullptr,
    const std::vector<float> *points_xy = nullptr,
    const std::vector<float> *conic_weights = nullptr,
    uint32_t col = 0,
    bool stroke = false,
    bool fill = false,
    VectorCmdFB::PathFillType fill_type = VectorCmdFB::PathFillType_winding) {
  auto verbs__ = verbs ? _fbb.CreateVector<uint8_t>(*verbs) : 0;
  auto points_xy__ = points_xy ? _fbb.CreateVector<float>(*points_xy) : 0;
  auto conic_weights__ = conic_weights ? _fbb.CreateVector<float>(*conic_weights) : 0;
  return VectorCmdFB::CreateCmdPath(
      _fbb,
      offset,
      verbs__,
      points_xy__,
      conic_weights__,
      col,
      stroke,
      fill,
      fill_type);
}

struct SingleVectorCmdDto FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SingleVectorCmdDtoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ARG_TYPE = 4,
    VT_ARG = 6
  };
  VectorCmdFB::VectorCmdArg arg_type() const {
    return static_cast<VectorCmdFB::VectorCmdArg>(GetField<uint8_t>(VT_ARG_TYPE, 0));
  }
  const void *arg() const {
    return GetPointer<const void *>(VT_ARG);
  }
  template<typename T> const T *arg_as() const;
  const VectorCmdFB::CmdRegisterFont *arg_as_CmdRegisterFont() const {
    return arg_type() == VectorCmdFB::VectorCmdArg_CmdRegisterFont ? static_cast<const VectorCmdFB::CmdRegisterFont *>(arg()) : nullptr;
  }
  const VectorCmdFB::CmdPolyline *arg_as_CmdPolyline() const {
    return arg_type() == VectorCmdFB::VectorCmdArg_CmdPolyline ? static_cast<const VectorCmdFB::CmdPolyline *>(arg()) : nullptr;
  }
  const VectorCmdFB::CmdConvexPolyFilled *arg_as_CmdConvexPolyFilled() const {
    return arg_type() == VectorCmdFB::VectorCmdArg_CmdConvexPolyFilled ? static_cast<const VectorCmdFB::CmdConvexPolyFilled *>(arg()) : nullptr;
  }
  const VectorCmdFB::CmdLine *arg_as_CmdLine() const {
    return arg_type() == VectorCmdFB::VectorCmdArg_CmdLine ? static_cast<const VectorCmdFB::CmdLine *>(arg()) : nullptr;
  }
  const VectorCmdFB::CmdRectRounded *arg_as_CmdRectRounded() const {
    return arg_type() == VectorCmdFB::VectorCmdArg_CmdRectRounded ? static_cast<const VectorCmdFB::CmdRectRounded *>(arg()) : nullptr;
  }
  const VectorCmdFB::CmdRectRoundedCorners *arg_as_CmdRectRoundedCorners() const {
    return arg_type() == VectorCmdFB::VectorCmdArg_CmdRectRoundedCorners ? static_cast<const VectorCmdFB::CmdRectRoundedCorners *>(arg()) : nullptr;
  }
  const VectorCmdFB::CmdRectRoundedFilled *arg_as_CmdRectRoundedFilled() const {
    return arg_type() == VectorCmdFB::VectorCmdArg_CmdRectRoundedFilled ? static_cast<const VectorCmdFB::CmdRectRoundedFilled *>(arg()) : nullptr;
  }
  const VectorCmdFB::CmdRectRoundedCornersFilled *arg_as_CmdRectRoundedCornersFilled() const {
    return arg_type() == VectorCmdFB::VectorCmdArg_CmdRectRoundedCornersFilled ? static_cast<const VectorCmdFB::CmdRectRoundedCornersFilled *>(arg()) : nullptr;
  }
  const VectorCmdFB::CmdQuad *arg_as_CmdQuad() const {
    return arg_type() == VectorCmdFB::VectorCmdArg_CmdQuad ? static_cast<const VectorCmdFB::CmdQuad *>(arg()) : nullptr;
  }
  const VectorCmdFB::CmdQuadFilled *arg_as_CmdQuadFilled() const {
    return arg_type() == VectorCmdFB::VectorCmdArg_CmdQuadFilled ? static_cast<const VectorCmdFB::CmdQuadFilled *>(arg()) : nullptr;
  }
  const VectorCmdFB::CmdTriangle *arg_as_CmdTriangle() const {
    return arg_type() == VectorCmdFB::VectorCmdArg_CmdTriangle ? static_cast<const VectorCmdFB::CmdTriangle *>(arg()) : nullptr;
  }
  const VectorCmdFB::CmdTriangleFilled *arg_as_CmdTriangleFilled() const {
    return arg_type() == VectorCmdFB::VectorCmdArg_CmdTriangleFilled ? static_cast<const VectorCmdFB::CmdTriangleFilled *>(arg()) : nullptr;
  }
  const VectorCmdFB::CmdCircle *arg_as_CmdCircle() const {
    return arg_type() == VectorCmdFB::VectorCmdArg_CmdCircle ? static_cast<const VectorCmdFB::CmdCircle *>(arg()) : nullptr;
  }
  const VectorCmdFB::CmdCircleFilled *arg_as_CmdCircleFilled() const {
    return arg_type() == VectorCmdFB::VectorCmdArg_CmdCircleFilled ? static_cast<const VectorCmdFB::CmdCircleFilled *>(arg()) : nullptr;
  }
  const VectorCmdFB::CmdNgon *arg_as_CmdNgon() const {
    return arg_type() == VectorCmdFB::VectorCmdArg_CmdNgon ? static_cast<const VectorCmdFB::CmdNgon *>(arg()) : nullptr;
  }
  const VectorCmdFB::CmdNgonFilled *arg_as_CmdNgonFilled() const {
    return arg_type() == VectorCmdFB::VectorCmdArg_CmdNgonFilled ? static_cast<const VectorCmdFB::CmdNgonFilled *>(arg()) : nullptr;
  }
  const VectorCmdFB::CmdEllipse *arg_as_CmdEllipse() const {
    return arg_type() == VectorCmdFB::VectorCmdArg_CmdEllipse ? static_cast<const VectorCmdFB::CmdEllipse *>(arg()) : nullptr;
  }
  const VectorCmdFB::CmdEllipseFilled *arg_as_CmdEllipseFilled() const {
    return arg_type() == VectorCmdFB::VectorCmdArg_CmdEllipseFilled ? static_cast<const VectorCmdFB::CmdEllipseFilled *>(arg()) : nullptr;
  }
  const VectorCmdFB::CmdBezierCubic *arg_as_CmdBezierCubic() const {
    return arg_type() == VectorCmdFB::VectorCmdArg_CmdBezierCubic ? static_cast<const VectorCmdFB::CmdBezierCubic *>(arg()) : nullptr;
  }
  const VectorCmdFB::CmdBezierQuadratic *arg_as_CmdBezierQuadratic() const {
    return arg_type() == VectorCmdFB::VectorCmdArg_CmdBezierQuadratic ? static_cast<const VectorCmdFB::CmdBezierQuadratic *>(arg()) : nullptr;
  }
  const VectorCmdFB::CmdImage *arg_as_CmdImage() const {
    return arg_type() == VectorCmdFB::VectorCmdArg_CmdImage ? static_cast<const VectorCmdFB::CmdImage *>(arg()) : nullptr;
  }
  const VectorCmdFB::CmdImageQuad *arg_as_CmdImageQuad() const {
    return arg_type() == VectorCmdFB::VectorCmdArg_CmdImageQuad ? static_cast<const VectorCmdFB::CmdImageQuad *>(arg()) : nullptr;
  }
  const VectorCmdFB::CmdImageRounded *arg_as_CmdImageRounded() const {
    return arg_type() == VectorCmdFB::VectorCmdArg_CmdImageRounded ? static_cast<const VectorCmdFB::CmdImageRounded *>(arg()) : nullptr;
  }
  const VectorCmdFB::CmdPushClipRect *arg_as_CmdPushClipRect() const {
    return arg_type() == VectorCmdFB::VectorCmdArg_CmdPushClipRect ? static_cast<const VectorCmdFB::CmdPushClipRect *>(arg()) : nullptr;
  }
  const VectorCmdFB::CmdPopClipRect *arg_as_CmdPopClipRect() const {
    return arg_type() == VectorCmdFB::VectorCmdArg_CmdPopClipRect ? static_cast<const VectorCmdFB::CmdPopClipRect *>(arg()) : nullptr;
  }
  const VectorCmdFB::CmdRenderText *arg_as_CmdRenderText() const {
    return arg_type() == VectorCmdFB::VectorCmdArg_CmdRenderText ? static_cast<const VectorCmdFB::CmdRenderText *>(arg()) : nullptr;
  }
  const VectorCmdFB::CmdRenderParagraph *arg_as_CmdRenderParagraph() const {
    return arg_type() == VectorCmdFB::VectorCmdArg_CmdRenderParagraph ? static_cast<const VectorCmdFB::CmdRenderParagraph *>(arg()) : nullptr;
  }
  const VectorCmdFB::CmdRenderUnicodeCodepoint *arg_as_CmdRenderUnicodeCodepoint() const {
    return arg_type() == VectorCmdFB::VectorCmdArg_CmdRenderUnicodeCodepoint ? static_cast<const VectorCmdFB::CmdRenderUnicodeCodepoint *>(arg()) : nullptr;
  }
  const VectorCmdFB::CmdRectFilledMultiColor *arg_as_CmdRectFilledMultiColor() const {
    return arg_type() == VectorCmdFB::VectorCmdArg_CmdRectFilledMultiColor ? static_cast<const VectorCmdFB::CmdRectFilledMultiColor *>(arg()) : nullptr;
  }
  const VectorCmdFB::CmdWrappedDrawList *arg_as_CmdWrappedDrawList() const {
    return arg_type() == VectorCmdFB::VectorCmdArg_CmdWrappedDrawList ? static_cast<const VectorCmdFB::CmdWrappedDrawList *>(arg()) : nullptr;
  }
  const VectorCmdFB::CmdVertexDraw *arg_as_CmdVertexDraw() const {
    return arg_type() == VectorCmdFB::VectorCmdArg_CmdVertexDraw ? static_cast<const VectorCmdFB::CmdVertexDraw *>(arg()) : nullptr;
  }
  const VectorCmdFB::CmdPushRotation *arg_as_CmdPushRotation() const {
    return arg_type() == VectorCmdFB::VectorCmdArg_CmdPushRotation ? static_cast<const VectorCmdFB::CmdPushRotation *>(arg()) : nullptr;
  }
  const VectorCmdFB::CmdPopRotation *arg_as_CmdPopRotation() const {
    return arg_type() == VectorCmdFB::VectorCmdArg_CmdPopRotation ? static_cast<const VectorCmdFB::CmdPopRotation *>(arg()) : nullptr;
  }
  const VectorCmdFB::CmdSimpleVertexDraw *arg_as_CmdSimpleVertexDraw() const {
    return arg_type() == VectorCmdFB::VectorCmdArg_CmdSimpleVertexDraw ? static_cast<const VectorCmdFB::CmdSimpleVertexDraw *>(arg()) : nullptr;
  }
  const VectorCmdFB::CmdSvgPathSubset *arg_as_CmdSvgPathSubset() const {
    return arg_type() == VectorCmdFB::VectorCmdArg_CmdSvgPathSubset ? static_cast<const VectorCmdFB::CmdSvgPathSubset *>(arg()) : nullptr;
  }
  const VectorCmdFB::CmdPath *arg_as_CmdPath() const {
    return arg_type() == VectorCmdFB::VectorCmdArg_CmdPath ? static_cast<const VectorCmdFB::CmdPath *>(arg()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ARG_TYPE, 1) &&
           VerifyOffset(verifier, VT_ARG) &&
           VerifyVectorCmdArg(verifier, arg(), arg_type()) &&
           verifier.EndTable();
  }
};

template<> inline const VectorCmdFB::CmdRegisterFont *SingleVectorCmdDto::arg_as<VectorCmdFB::CmdRegisterFont>() const {
  return arg_as_CmdRegisterFont();
}

template<> inline const VectorCmdFB::CmdPolyline *SingleVectorCmdDto::arg_as<VectorCmdFB::CmdPolyline>() const {
  return arg_as_CmdPolyline();
}

template<> inline const VectorCmdFB::CmdConvexPolyFilled *SingleVectorCmdDto::arg_as<VectorCmdFB::CmdConvexPolyFilled>() const {
  return arg_as_CmdConvexPolyFilled();
}

template<> inline const VectorCmdFB::CmdLine *SingleVectorCmdDto::arg_as<VectorCmdFB::CmdLine>() const {
  return arg_as_CmdLine();
}

template<> inline const VectorCmdFB::CmdRectRounded *SingleVectorCmdDto::arg_as<VectorCmdFB::CmdRectRounded>() const {
  return arg_as_CmdRectRounded();
}

template<> inline const VectorCmdFB::CmdRectRoundedCorners *SingleVectorCmdDto::arg_as<VectorCmdFB::CmdRectRoundedCorners>() const {
  return arg_as_CmdRectRoundedCorners();
}

template<> inline const VectorCmdFB::CmdRectRoundedFilled *SingleVectorCmdDto::arg_as<VectorCmdFB::CmdRectRoundedFilled>() const {
  return arg_as_CmdRectRoundedFilled();
}

template<> inline const VectorCmdFB::CmdRectRoundedCornersFilled *SingleVectorCmdDto::arg_as<VectorCmdFB::CmdRectRoundedCornersFilled>() const {
  return arg_as_CmdRectRoundedCornersFilled();
}

template<> inline const VectorCmdFB::CmdQuad *SingleVectorCmdDto::arg_as<VectorCmdFB::CmdQuad>() const {
  return arg_as_CmdQuad();
}

template<> inline const VectorCmdFB::CmdQuadFilled *SingleVectorCmdDto::arg_as<VectorCmdFB::CmdQuadFilled>() const {
  return arg_as_CmdQuadFilled();
}

template<> inline const VectorCmdFB::CmdTriangle *SingleVectorCmdDto::arg_as<VectorCmdFB::CmdTriangle>() const {
  return arg_as_CmdTriangle();
}

template<> inline const VectorCmdFB::CmdTriangleFilled *SingleVectorCmdDto::arg_as<VectorCmdFB::CmdTriangleFilled>() const {
  return arg_as_CmdTriangleFilled();
}

template<> inline const VectorCmdFB::CmdCircle *SingleVectorCmdDto::arg_as<VectorCmdFB::CmdCircle>() const {
  return arg_as_CmdCircle();
}

template<> inline const VectorCmdFB::CmdCircleFilled *SingleVectorCmdDto::arg_as<VectorCmdFB::CmdCircleFilled>() const {
  return arg_as_CmdCircleFilled();
}

template<> inline const VectorCmdFB::CmdNgon *SingleVectorCmdDto::arg_as<VectorCmdFB::CmdNgon>() const {
  return arg_as_CmdNgon();
}

template<> inline const VectorCmdFB::CmdNgonFilled *SingleVectorCmdDto::arg_as<VectorCmdFB::CmdNgonFilled>() const {
  return arg_as_CmdNgonFilled();
}

template<> inline const VectorCmdFB::CmdEllipse *SingleVectorCmdDto::arg_as<VectorCmdFB::CmdEllipse>() const {
  return arg_as_CmdEllipse();
}

template<> inline const VectorCmdFB::CmdEllipseFilled *SingleVectorCmdDto::arg_as<VectorCmdFB::CmdEllipseFilled>() const {
  return arg_as_CmdEllipseFilled();
}

template<> inline const VectorCmdFB::CmdBezierCubic *SingleVectorCmdDto::arg_as<VectorCmdFB::CmdBezierCubic>() const {
  return arg_as_CmdBezierCubic();
}

template<> inline const VectorCmdFB::CmdBezierQuadratic *SingleVectorCmdDto::arg_as<VectorCmdFB::CmdBezierQuadratic>() const {
  return arg_as_CmdBezierQuadratic();
}

template<> inline const VectorCmdFB::CmdImage *SingleVectorCmdDto::arg_as<VectorCmdFB::CmdImage>() const {
  return arg_as_CmdImage();
}

template<> inline const VectorCmdFB::CmdImageQuad *SingleVectorCmdDto::arg_as<VectorCmdFB::CmdImageQuad>() const {
  return arg_as_CmdImageQuad();
}

template<> inline const VectorCmdFB::CmdImageRounded *SingleVectorCmdDto::arg_as<VectorCmdFB::CmdImageRounded>() const {
  return arg_as_CmdImageRounded();
}

template<> inline const VectorCmdFB::CmdPushClipRect *SingleVectorCmdDto::arg_as<VectorCmdFB::CmdPushClipRect>() const {
  return arg_as_CmdPushClipRect();
}

template<> inline const VectorCmdFB::CmdPopClipRect *SingleVectorCmdDto::arg_as<VectorCmdFB::CmdPopClipRect>() const {
  return arg_as_CmdPopClipRect();
}

template<> inline const VectorCmdFB::CmdRenderText *SingleVectorCmdDto::arg_as<VectorCmdFB::CmdRenderText>() const {
  return arg_as_CmdRenderText();
}

template<> inline const VectorCmdFB::CmdRenderParagraph *SingleVectorCmdDto::arg_as<VectorCmdFB::CmdRenderParagraph>() const {
  return arg_as_CmdRenderParagraph();
}

template<> inline const VectorCmdFB::CmdRenderUnicodeCodepoint *SingleVectorCmdDto::arg_as<VectorCmdFB::CmdRenderUnicodeCodepoint>() const {
  return arg_as_CmdRenderUnicodeCodepoint();
}

template<> inline const VectorCmdFB::CmdRectFilledMultiColor *SingleVectorCmdDto::arg_as<VectorCmdFB::CmdRectFilledMultiColor>() const {
  return arg_as_CmdRectFilledMultiColor();
}

template<> inline const VectorCmdFB::CmdWrappedDrawList *SingleVectorCmdDto::arg_as<VectorCmdFB::CmdWrappedDrawList>() const {
  return arg_as_CmdWrappedDrawList();
}

template<> inline const VectorCmdFB::CmdVertexDraw *SingleVectorCmdDto::arg_as<VectorCmdFB::CmdVertexDraw>() const {
  return arg_as_CmdVertexDraw();
}

template<> inline const VectorCmdFB::CmdPushRotation *SingleVectorCmdDto::arg_as<VectorCmdFB::CmdPushRotation>() const {
  return arg_as_CmdPushRotation();
}

template<> inline const VectorCmdFB::CmdPopRotation *SingleVectorCmdDto::arg_as<VectorCmdFB::CmdPopRotation>() const {
  return arg_as_CmdPopRotation();
}

template<> inline const VectorCmdFB::CmdSimpleVertexDraw *SingleVectorCmdDto::arg_as<VectorCmdFB::CmdSimpleVertexDraw>() const {
  return arg_as_CmdSimpleVertexDraw();
}

template<> inline const VectorCmdFB::CmdSvgPathSubset *SingleVectorCmdDto::arg_as<VectorCmdFB::CmdSvgPathSubset>() const {
  return arg_as_CmdSvgPathSubset();
}

template<> inline const VectorCmdFB::CmdPath *SingleVectorCmdDto::arg_as<VectorCmdFB::CmdPath>() const {
  return arg_as_CmdPath();
}

struct SingleVectorCmdDtoBuilder {
  typedef SingleVectorCmdDto Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_arg_type(VectorCmdFB::VectorCmdArg arg_type) {
    fbb_.AddElement<uint8_t>(SingleVectorCmdDto::VT_ARG_TYPE, static_cast<uint8_t>(arg_type), 0);
  }
  void add_arg(::flatbuffers::Offset<void> arg) {
    fbb_.AddOffset(SingleVectorCmdDto::VT_ARG, arg);
  }
  explicit SingleVectorCmdDtoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SingleVectorCmdDto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SingleVectorCmdDto>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SingleVectorCmdDto> CreateSingleVectorCmdDto(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    VectorCmdFB::VectorCmdArg arg_type = VectorCmdFB::VectorCmdArg_NONE,
    ::flatbuffers::Offset<void> arg = 0) {
  SingleVectorCmdDtoBuilder builder_(_fbb);
  builder_.add_arg(arg);
  builder_.add_arg_type(arg_type);
  return builder_.Finish();
}

struct VertexData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VertexDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POS_XY = 4,
    VT_TEXTURE_UV = 6,
    VT_COL = 8,
    VT_INDICES = 10
  };
  const ::flatbuffers::Vector<float> *pos_xy() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_POS_XY);
  }
  const ::flatbuffers::Vector<float> *texture_uv() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_TEXTURE_UV);
  }
  const ::flatbuffers::Vector<uint32_t> *col() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_COL);
  }
  const ::flatbuffers::Vector<uint16_t> *indices() const {
    return GetPointer<const ::flatbuffers::Vector<uint16_t> *>(VT_INDICES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_POS_XY) &&
           verifier.VerifyVector(pos_xy()) &&
           VerifyOffset(verifier, VT_TEXTURE_UV) &&
           verifier.VerifyVector(texture_uv()) &&
           VerifyOffset(verifier, VT_COL) &&
           verifier.VerifyVector(col()) &&
           VerifyOffset(verifier, VT_INDICES) &&
           verifier.VerifyVector(indices()) &&
           verifier.EndTable();
  }
};

struct VertexDataBuilder {
  typedef VertexData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pos_xy(::flatbuffers::Offset<::flatbuffers::Vector<float>> pos_xy) {
    fbb_.AddOffset(VertexData::VT_POS_XY, pos_xy);
  }
  void add_texture_uv(::flatbuffers::Offset<::flatbuffers::Vector<float>> texture_uv) {
    fbb_.AddOffset(VertexData::VT_TEXTURE_UV, texture_uv);
  }
  void add_col(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> col) {
    fbb_.AddOffset(VertexData::VT_COL, col);
  }
  void add_indices(::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> indices) {
    fbb_.AddOffset(VertexData::VT_INDICES, indices);
  }
  explicit VertexDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VertexData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VertexData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VertexData> CreateVertexData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> pos_xy = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> texture_uv = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> col = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> indices = 0) {
  VertexDataBuilder builder_(_fbb);
  builder_.add_indices(indices);
  builder_.add_col(col);
  builder_.add_texture_uv(texture_uv);
  builder_.add_pos_xy(pos_xy);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<VertexData> CreateVertexDataDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *pos_xy = nullptr,
    const std::vector<float> *texture_uv = nullptr,
    const std::vector<uint32_t> *col = nullptr,
    const std::vector<uint16_t> *indices = nullptr) {
  auto pos_xy__ = pos_xy ? _fbb.CreateVector<float>(*pos_xy) : 0;
  auto texture_uv__ = texture_uv ? _fbb.CreateVector<float>(*texture_uv) : 0;
  auto col__ = col ? _fbb.CreateVector<uint32_t>(*col) : 0;
  auto indices__ = indices ? _fbb.CreateVector<uint16_t>(*indices) : 0;
  return VectorCmdFB::CreateVertexData(
      _fbb,
      pos_xy__,
      texture_uv__,
      col__,
      indices__);
}

struct DrawList FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DrawListBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FLAGS = 4,
    VT_NAME = 6,
    VT_VERTICES = 8,
    VT_CMDS = 10
  };
  VectorCmdFB::DrawListFlags flags() const {
    return static_cast<VectorCmdFB::DrawListFlags>(GetField<uint8_t>(VT_FLAGS, 0));
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const VectorCmdFB::VertexData *vertices() const {
    return GetPointer<const VectorCmdFB::VertexData *>(VT_VERTICES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<VectorCmdFB::SingleVectorCmdDto>> *cmds() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<VectorCmdFB::SingleVectorCmdDto>> *>(VT_CMDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_FLAGS, 1) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_VERTICES) &&
           verifier.VerifyTable(vertices()) &&
           VerifyOffset(verifier, VT_CMDS) &&
           verifier.VerifyVector(cmds()) &&
           verifier.VerifyVectorOfTables(cmds()) &&
           verifier.EndTable();
  }
};

struct DrawListBuilder {
  typedef DrawList Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_flags(VectorCmdFB::DrawListFlags flags) {
    fbb_.AddElement<uint8_t>(DrawList::VT_FLAGS, static_cast<uint8_t>(flags), 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(DrawList::VT_NAME, name);
  }
  void add_vertices(::flatbuffers::Offset<VectorCmdFB::VertexData> vertices) {
    fbb_.AddOffset(DrawList::VT_VERTICES, vertices);
  }
  void add_cmds(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<VectorCmdFB::SingleVectorCmdDto>>> cmds) {
    fbb_.AddOffset(DrawList::VT_CMDS, cmds);
  }
  explicit DrawListBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DrawList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DrawList>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DrawList> CreateDrawList(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    VectorCmdFB::DrawListFlags flags = VectorCmdFB::DrawListFlags_None,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<VectorCmdFB::VertexData> vertices = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<VectorCmdFB::SingleVectorCmdDto>>> cmds = 0) {
  DrawListBuilder builder_(_fbb);
  builder_.add_cmds(cmds);
  builder_.add_vertices(vertices);
  builder_.add_name(name);
  builder_.add_flags(flags);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DrawList> CreateDrawListDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    VectorCmdFB::DrawListFlags flags = VectorCmdFB::DrawListFlags_None,
    const char *name = nullptr,
    ::flatbuffers::Offset<VectorCmdFB::VertexData> vertices = 0,
    const std::vector<::flatbuffers::Offset<VectorCmdFB::SingleVectorCmdDto>> *cmds = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto cmds__ = cmds ? _fbb.CreateVector<::flatbuffers::Offset<VectorCmdFB::SingleVectorCmdDto>>(*cmds) : 0;
  return VectorCmdFB::CreateDrawList(
      _fbb,
      flags,
      name__,
      vertices,
      cmds__);
}

struct IoRecord FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IoRecordBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FLAGS = 4
  };
  VectorCmdFB::IoFlags flags() const {
    return static_cast<VectorCmdFB::IoFlags>(GetField<uint16_t>(VT_FLAGS, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_FLAGS, 2) &&
           verifier.EndTable();
  }
};

struct IoRecordBuilder {
  typedef IoRecord Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_flags(VectorCmdFB::IoFlags flags) {
    fbb_.AddElement<uint16_t>(IoRecord::VT_FLAGS, static_cast<uint16_t>(flags), 0);
  }
  explicit IoRecordBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<IoRecord> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<IoRecord>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<IoRecord> CreateIoRecord(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    VectorCmdFB::IoFlags flags = VectorCmdFB::IoFlags_None) {
  IoRecordBuilder builder_(_fbb);
  builder_.add_flags(flags);
  return builder_.Finish();
}

inline bool VerifyVectorCmdArg(::flatbuffers::Verifier &verifier, const void *obj, VectorCmdArg type) {
  switch (type) {
    case VectorCmdArg_NONE: {
      return true;
    }
    case VectorCmdArg_CmdRegisterFont: {
      auto ptr = reinterpret_cast<const VectorCmdFB::CmdRegisterFont *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdPolyline: {
      auto ptr = reinterpret_cast<const VectorCmdFB::CmdPolyline *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdConvexPolyFilled: {
      auto ptr = reinterpret_cast<const VectorCmdFB::CmdConvexPolyFilled *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdLine: {
      auto ptr = reinterpret_cast<const VectorCmdFB::CmdLine *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdRectRounded: {
      auto ptr = reinterpret_cast<const VectorCmdFB::CmdRectRounded *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdRectRoundedCorners: {
      auto ptr = reinterpret_cast<const VectorCmdFB::CmdRectRoundedCorners *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdRectRoundedFilled: {
      auto ptr = reinterpret_cast<const VectorCmdFB::CmdRectRoundedFilled *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdRectRoundedCornersFilled: {
      auto ptr = reinterpret_cast<const VectorCmdFB::CmdRectRoundedCornersFilled *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdQuad: {
      auto ptr = reinterpret_cast<const VectorCmdFB::CmdQuad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdQuadFilled: {
      auto ptr = reinterpret_cast<const VectorCmdFB::CmdQuadFilled *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdTriangle: {
      auto ptr = reinterpret_cast<const VectorCmdFB::CmdTriangle *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdTriangleFilled: {
      auto ptr = reinterpret_cast<const VectorCmdFB::CmdTriangleFilled *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdCircle: {
      auto ptr = reinterpret_cast<const VectorCmdFB::CmdCircle *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdCircleFilled: {
      auto ptr = reinterpret_cast<const VectorCmdFB::CmdCircleFilled *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdNgon: {
      auto ptr = reinterpret_cast<const VectorCmdFB::CmdNgon *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdNgonFilled: {
      auto ptr = reinterpret_cast<const VectorCmdFB::CmdNgonFilled *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdEllipse: {
      auto ptr = reinterpret_cast<const VectorCmdFB::CmdEllipse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdEllipseFilled: {
      auto ptr = reinterpret_cast<const VectorCmdFB::CmdEllipseFilled *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdBezierCubic: {
      auto ptr = reinterpret_cast<const VectorCmdFB::CmdBezierCubic *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdBezierQuadratic: {
      auto ptr = reinterpret_cast<const VectorCmdFB::CmdBezierQuadratic *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdImage: {
      auto ptr = reinterpret_cast<const VectorCmdFB::CmdImage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdImageQuad: {
      auto ptr = reinterpret_cast<const VectorCmdFB::CmdImageQuad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdImageRounded: {
      auto ptr = reinterpret_cast<const VectorCmdFB::CmdImageRounded *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdPushClipRect: {
      auto ptr = reinterpret_cast<const VectorCmdFB::CmdPushClipRect *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdPopClipRect: {
      auto ptr = reinterpret_cast<const VectorCmdFB::CmdPopClipRect *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdRenderText: {
      auto ptr = reinterpret_cast<const VectorCmdFB::CmdRenderText *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdRenderParagraph: {
      auto ptr = reinterpret_cast<const VectorCmdFB::CmdRenderParagraph *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdRenderUnicodeCodepoint: {
      auto ptr = reinterpret_cast<const VectorCmdFB::CmdRenderUnicodeCodepoint *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdRectFilledMultiColor: {
      auto ptr = reinterpret_cast<const VectorCmdFB::CmdRectFilledMultiColor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdWrappedDrawList: {
      auto ptr = reinterpret_cast<const VectorCmdFB::CmdWrappedDrawList *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdVertexDraw: {
      auto ptr = reinterpret_cast<const VectorCmdFB::CmdVertexDraw *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdPushRotation: {
      auto ptr = reinterpret_cast<const VectorCmdFB::CmdPushRotation *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdPopRotation: {
      auto ptr = reinterpret_cast<const VectorCmdFB::CmdPopRotation *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdSimpleVertexDraw: {
      auto ptr = reinterpret_cast<const VectorCmdFB::CmdSimpleVertexDraw *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdSvgPathSubset: {
      auto ptr = reinterpret_cast<const VectorCmdFB::CmdSvgPathSubset *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCmdArg_CmdPath: {
      auto ptr = reinterpret_cast<const VectorCmdFB::CmdPath *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyVectorCmdArgVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyVectorCmdArg(
        verifier,  values->Get(i), types->GetEnum<VectorCmdArg>(i))) {
      return false;
    }
  }
  return true;
}

inline const VectorCmdFB::DrawList *GetDrawList(const void *buf) {
  return ::flatbuffers::GetRoot<VectorCmdFB::DrawList>(buf);
}

inline const VectorCmdFB::DrawList *GetSizePrefixedDrawList(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<VectorCmdFB::DrawList>(buf);
}

inline bool VerifyDrawListBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<VectorCmdFB::DrawList>(nullptr);
}

inline bool VerifySizePrefixedDrawListBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<VectorCmdFB::DrawList>(nullptr);
}

inline void FinishDrawListBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<VectorCmdFB::DrawList> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedDrawListBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<VectorCmdFB::DrawList> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace VectorCmdFB

#endif  // FLATBUFFERS_GENERATED_VECTORCMD_VECTORCMDFB_H_
