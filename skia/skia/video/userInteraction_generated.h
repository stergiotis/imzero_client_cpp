// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_USERINTERACTION_USERINTERACTIONFB_H_
#define FLATBUFFERS_GENERATED_USERINTERACTION_USERINTERACTIONFB_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

namespace UserInteractionFB {

struct SingleVec2;

struct SingleVec4;

struct ArrayOfVec2;
struct ArrayOfVec2Builder;

struct ArrayOfVec4;
struct ArrayOfVec4Builder;

struct EventMouseMotion;
struct EventMouseMotionBuilder;

struct EventMouseWheel;
struct EventMouseWheelBuilder;

struct EventMouseButton;
struct EventMouseButtonBuilder;

struct EventTextInput;
struct EventTextInputBuilder;

struct Event;
struct EventBuilder;

inline const ::flatbuffers::TypeTable *SingleVec2TypeTable();

inline const ::flatbuffers::TypeTable *SingleVec4TypeTable();

inline const ::flatbuffers::TypeTable *ArrayOfVec2TypeTable();

inline const ::flatbuffers::TypeTable *ArrayOfVec4TypeTable();

inline const ::flatbuffers::TypeTable *EventMouseMotionTypeTable();

inline const ::flatbuffers::TypeTable *EventMouseWheelTypeTable();

inline const ::flatbuffers::TypeTable *EventMouseButtonTypeTable();

inline const ::flatbuffers::TypeTable *EventTextInputTypeTable();

inline const ::flatbuffers::TypeTable *EventTypeTable();

enum MouseButton : uint8_t {
  MouseButton_None = 0,
  MouseButton_Left = 1,
  MouseButton_Right = 2,
  MouseButton_Middle = 3,
  MouseButton_X1 = 4,
  MouseButton_X2 = 5,
  MouseButton_MIN = MouseButton_None,
  MouseButton_MAX = MouseButton_X2
};

inline const MouseButton (&EnumValuesMouseButton())[6] {
  static const MouseButton values[] = {
    MouseButton_None,
    MouseButton_Left,
    MouseButton_Right,
    MouseButton_Middle,
    MouseButton_X1,
    MouseButton_X2
  };
  return values;
}

inline const char * const *EnumNamesMouseButton() {
  static const char * const names[7] = {
    "None",
    "Left",
    "Right",
    "Middle",
    "X1",
    "X2",
    nullptr
  };
  return names;
}

inline const char *EnumNameMouseButton(MouseButton e) {
  if (::flatbuffers::IsOutRange(e, MouseButton_None, MouseButton_X2)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMouseButton()[index];
}

enum MouseButtonEventType : uint8_t {
  MouseButtonEventType_Up = 0,
  MouseButtonEventType_Down = 1,
  MouseButtonEventType_MIN = MouseButtonEventType_Up,
  MouseButtonEventType_MAX = MouseButtonEventType_Down
};

inline const MouseButtonEventType (&EnumValuesMouseButtonEventType())[2] {
  static const MouseButtonEventType values[] = {
    MouseButtonEventType_Up,
    MouseButtonEventType_Down
  };
  return values;
}

inline const char * const *EnumNamesMouseButtonEventType() {
  static const char * const names[3] = {
    "Up",
    "Down",
    nullptr
  };
  return names;
}

inline const char *EnumNameMouseButtonEventType(MouseButtonEventType e) {
  if (::flatbuffers::IsOutRange(e, MouseButtonEventType_Up, MouseButtonEventType_Down)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMouseButtonEventType()[index];
}

enum UserInteraction : uint8_t {
  UserInteraction_NONE = 0,
  UserInteraction_EventMouseMotion = 1,
  UserInteraction_EventMouseWheel = 2,
  UserInteraction_EventMouseButton = 3,
  UserInteraction_EventTextInput = 4,
  UserInteraction_MIN = UserInteraction_NONE,
  UserInteraction_MAX = UserInteraction_EventTextInput
};

inline const UserInteraction (&EnumValuesUserInteraction())[5] {
  static const UserInteraction values[] = {
    UserInteraction_NONE,
    UserInteraction_EventMouseMotion,
    UserInteraction_EventMouseWheel,
    UserInteraction_EventMouseButton,
    UserInteraction_EventTextInput
  };
  return values;
}

inline const char * const *EnumNamesUserInteraction() {
  static const char * const names[6] = {
    "NONE",
    "EventMouseMotion",
    "EventMouseWheel",
    "EventMouseButton",
    "EventTextInput",
    nullptr
  };
  return names;
}

inline const char *EnumNameUserInteraction(UserInteraction e) {
  if (::flatbuffers::IsOutRange(e, UserInteraction_NONE, UserInteraction_EventTextInput)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesUserInteraction()[index];
}

template<typename T> struct UserInteractionTraits {
  static const UserInteraction enum_value = UserInteraction_NONE;
};

template<> struct UserInteractionTraits<UserInteractionFB::EventMouseMotion> {
  static const UserInteraction enum_value = UserInteraction_EventMouseMotion;
};

template<> struct UserInteractionTraits<UserInteractionFB::EventMouseWheel> {
  static const UserInteraction enum_value = UserInteraction_EventMouseWheel;
};

template<> struct UserInteractionTraits<UserInteractionFB::EventMouseButton> {
  static const UserInteraction enum_value = UserInteraction_EventMouseButton;
};

template<> struct UserInteractionTraits<UserInteractionFB::EventTextInput> {
  static const UserInteraction enum_value = UserInteraction_EventTextInput;
};

bool VerifyUserInteraction(::flatbuffers::Verifier &verifier, const void *obj, UserInteraction type);
bool VerifyUserInteractionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) SingleVec2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SingleVec2TypeTable();
  }
  SingleVec2()
      : x_(0),
        y_(0) {
  }
  SingleVec2(float _x, float _y)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(SingleVec2, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) SingleVec4 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SingleVec4TypeTable();
  }
  SingleVec4()
      : x_(0),
        y_(0),
        z_(0),
        w_(0) {
  }
  SingleVec4(float _x, float _y, float _z, float _w)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)),
        z_(::flatbuffers::EndianScalar(_z)),
        w_(::flatbuffers::EndianScalar(_w)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return ::flatbuffers::EndianScalar(z_);
  }
  float w() const {
    return ::flatbuffers::EndianScalar(w_);
  }
};
FLATBUFFERS_STRUCT_END(SingleVec4, 16);

struct ArrayOfVec2 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ArrayOfVec2Builder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ArrayOfVec2TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_XS = 4,
    VT_YS = 6
  };
  const ::flatbuffers::Vector<float> *xs() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_XS);
  }
  const ::flatbuffers::Vector<float> *ys() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_YS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_XS) &&
           verifier.VerifyVector(xs()) &&
           VerifyOffset(verifier, VT_YS) &&
           verifier.VerifyVector(ys()) &&
           verifier.EndTable();
  }
};

struct ArrayOfVec2Builder {
  typedef ArrayOfVec2 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_xs(::flatbuffers::Offset<::flatbuffers::Vector<float>> xs) {
    fbb_.AddOffset(ArrayOfVec2::VT_XS, xs);
  }
  void add_ys(::flatbuffers::Offset<::flatbuffers::Vector<float>> ys) {
    fbb_.AddOffset(ArrayOfVec2::VT_YS, ys);
  }
  explicit ArrayOfVec2Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ArrayOfVec2> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ArrayOfVec2>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ArrayOfVec2> CreateArrayOfVec2(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> xs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> ys = 0) {
  ArrayOfVec2Builder builder_(_fbb);
  builder_.add_ys(ys);
  builder_.add_xs(xs);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ArrayOfVec2> CreateArrayOfVec2Direct(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *xs = nullptr,
    const std::vector<float> *ys = nullptr) {
  auto xs__ = xs ? _fbb.CreateVector<float>(*xs) : 0;
  auto ys__ = ys ? _fbb.CreateVector<float>(*ys) : 0;
  return UserInteractionFB::CreateArrayOfVec2(
      _fbb,
      xs__,
      ys__);
}

struct ArrayOfVec4 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ArrayOfVec4Builder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ArrayOfVec4TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_XS = 4,
    VT_YS = 6,
    VT_ZS = 8,
    VT_WS = 10
  };
  const ::flatbuffers::Vector<float> *xs() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_XS);
  }
  const ::flatbuffers::Vector<float> *ys() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_YS);
  }
  const ::flatbuffers::Vector<float> *zs() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_ZS);
  }
  const ::flatbuffers::Vector<float> *ws() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_WS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_XS) &&
           verifier.VerifyVector(xs()) &&
           VerifyOffset(verifier, VT_YS) &&
           verifier.VerifyVector(ys()) &&
           VerifyOffset(verifier, VT_ZS) &&
           verifier.VerifyVector(zs()) &&
           VerifyOffset(verifier, VT_WS) &&
           verifier.VerifyVector(ws()) &&
           verifier.EndTable();
  }
};

struct ArrayOfVec4Builder {
  typedef ArrayOfVec4 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_xs(::flatbuffers::Offset<::flatbuffers::Vector<float>> xs) {
    fbb_.AddOffset(ArrayOfVec4::VT_XS, xs);
  }
  void add_ys(::flatbuffers::Offset<::flatbuffers::Vector<float>> ys) {
    fbb_.AddOffset(ArrayOfVec4::VT_YS, ys);
  }
  void add_zs(::flatbuffers::Offset<::flatbuffers::Vector<float>> zs) {
    fbb_.AddOffset(ArrayOfVec4::VT_ZS, zs);
  }
  void add_ws(::flatbuffers::Offset<::flatbuffers::Vector<float>> ws) {
    fbb_.AddOffset(ArrayOfVec4::VT_WS, ws);
  }
  explicit ArrayOfVec4Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ArrayOfVec4> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ArrayOfVec4>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ArrayOfVec4> CreateArrayOfVec4(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> xs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> ys = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> zs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> ws = 0) {
  ArrayOfVec4Builder builder_(_fbb);
  builder_.add_ws(ws);
  builder_.add_zs(zs);
  builder_.add_ys(ys);
  builder_.add_xs(xs);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ArrayOfVec4> CreateArrayOfVec4Direct(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *xs = nullptr,
    const std::vector<float> *ys = nullptr,
    const std::vector<float> *zs = nullptr,
    const std::vector<float> *ws = nullptr) {
  auto xs__ = xs ? _fbb.CreateVector<float>(*xs) : 0;
  auto ys__ = ys ? _fbb.CreateVector<float>(*ys) : 0;
  auto zs__ = zs ? _fbb.CreateVector<float>(*zs) : 0;
  auto ws__ = ws ? _fbb.CreateVector<float>(*ws) : 0;
  return UserInteractionFB::CreateArrayOfVec4(
      _fbb,
      xs__,
      ys__,
      zs__,
      ws__);
}

struct EventMouseMotion FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EventMouseMotionBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return EventMouseMotionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POS = 4,
    VT_MOUSE_ID = 6,
    VT_IS_TOUCH = 8
  };
  const UserInteractionFB::SingleVec2 *pos() const {
    return GetStruct<const UserInteractionFB::SingleVec2 *>(VT_POS);
  }
  uint32_t mouse_id() const {
    return GetField<uint32_t>(VT_MOUSE_ID, 0);
  }
  bool is_touch() const {
    return GetField<uint8_t>(VT_IS_TOUCH, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<UserInteractionFB::SingleVec2>(verifier, VT_POS, 4) &&
           VerifyField<uint32_t>(verifier, VT_MOUSE_ID, 4) &&
           VerifyField<uint8_t>(verifier, VT_IS_TOUCH, 1) &&
           verifier.EndTable();
  }
};

struct EventMouseMotionBuilder {
  typedef EventMouseMotion Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pos(const UserInteractionFB::SingleVec2 *pos) {
    fbb_.AddStruct(EventMouseMotion::VT_POS, pos);
  }
  void add_mouse_id(uint32_t mouse_id) {
    fbb_.AddElement<uint32_t>(EventMouseMotion::VT_MOUSE_ID, mouse_id, 0);
  }
  void add_is_touch(bool is_touch) {
    fbb_.AddElement<uint8_t>(EventMouseMotion::VT_IS_TOUCH, static_cast<uint8_t>(is_touch), 0);
  }
  explicit EventMouseMotionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EventMouseMotion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EventMouseMotion>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EventMouseMotion> CreateEventMouseMotion(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const UserInteractionFB::SingleVec2 *pos = nullptr,
    uint32_t mouse_id = 0,
    bool is_touch = false) {
  EventMouseMotionBuilder builder_(_fbb);
  builder_.add_mouse_id(mouse_id);
  builder_.add_pos(pos);
  builder_.add_is_touch(is_touch);
  return builder_.Finish();
}

struct EventMouseWheel FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EventMouseWheelBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return EventMouseWheelTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POS = 4,
    VT_MOUSE_ID = 6,
    VT_IS_TOUCH = 8
  };
  const UserInteractionFB::SingleVec2 *pos() const {
    return GetStruct<const UserInteractionFB::SingleVec2 *>(VT_POS);
  }
  uint32_t mouse_id() const {
    return GetField<uint32_t>(VT_MOUSE_ID, 0);
  }
  bool is_touch() const {
    return GetField<uint8_t>(VT_IS_TOUCH, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<UserInteractionFB::SingleVec2>(verifier, VT_POS, 4) &&
           VerifyField<uint32_t>(verifier, VT_MOUSE_ID, 4) &&
           VerifyField<uint8_t>(verifier, VT_IS_TOUCH, 1) &&
           verifier.EndTable();
  }
};

struct EventMouseWheelBuilder {
  typedef EventMouseWheel Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pos(const UserInteractionFB::SingleVec2 *pos) {
    fbb_.AddStruct(EventMouseWheel::VT_POS, pos);
  }
  void add_mouse_id(uint32_t mouse_id) {
    fbb_.AddElement<uint32_t>(EventMouseWheel::VT_MOUSE_ID, mouse_id, 0);
  }
  void add_is_touch(bool is_touch) {
    fbb_.AddElement<uint8_t>(EventMouseWheel::VT_IS_TOUCH, static_cast<uint8_t>(is_touch), 0);
  }
  explicit EventMouseWheelBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EventMouseWheel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EventMouseWheel>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EventMouseWheel> CreateEventMouseWheel(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const UserInteractionFB::SingleVec2 *pos = nullptr,
    uint32_t mouse_id = 0,
    bool is_touch = false) {
  EventMouseWheelBuilder builder_(_fbb);
  builder_.add_mouse_id(mouse_id);
  builder_.add_pos(pos);
  builder_.add_is_touch(is_touch);
  return builder_.Finish();
}

struct EventMouseButton FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EventMouseButtonBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return EventMouseButtonTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POS = 4,
    VT_MOUSE_ID = 6,
    VT_IS_TOUCH = 8,
    VT_BUTTON = 10,
    VT_TYPE = 12
  };
  const UserInteractionFB::SingleVec2 *pos() const {
    return GetStruct<const UserInteractionFB::SingleVec2 *>(VT_POS);
  }
  uint32_t mouse_id() const {
    return GetField<uint32_t>(VT_MOUSE_ID, 0);
  }
  bool is_touch() const {
    return GetField<uint8_t>(VT_IS_TOUCH, 0) != 0;
  }
  UserInteractionFB::MouseButton button() const {
    return static_cast<UserInteractionFB::MouseButton>(GetField<uint8_t>(VT_BUTTON, 0));
  }
  UserInteractionFB::MouseButtonEventType type() const {
    return static_cast<UserInteractionFB::MouseButtonEventType>(GetField<uint8_t>(VT_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<UserInteractionFB::SingleVec2>(verifier, VT_POS, 4) &&
           VerifyField<uint32_t>(verifier, VT_MOUSE_ID, 4) &&
           VerifyField<uint8_t>(verifier, VT_IS_TOUCH, 1) &&
           VerifyField<uint8_t>(verifier, VT_BUTTON, 1) &&
           VerifyField<uint8_t>(verifier, VT_TYPE, 1) &&
           verifier.EndTable();
  }
};

struct EventMouseButtonBuilder {
  typedef EventMouseButton Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pos(const UserInteractionFB::SingleVec2 *pos) {
    fbb_.AddStruct(EventMouseButton::VT_POS, pos);
  }
  void add_mouse_id(uint32_t mouse_id) {
    fbb_.AddElement<uint32_t>(EventMouseButton::VT_MOUSE_ID, mouse_id, 0);
  }
  void add_is_touch(bool is_touch) {
    fbb_.AddElement<uint8_t>(EventMouseButton::VT_IS_TOUCH, static_cast<uint8_t>(is_touch), 0);
  }
  void add_button(UserInteractionFB::MouseButton button) {
    fbb_.AddElement<uint8_t>(EventMouseButton::VT_BUTTON, static_cast<uint8_t>(button), 0);
  }
  void add_type(UserInteractionFB::MouseButtonEventType type) {
    fbb_.AddElement<uint8_t>(EventMouseButton::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  explicit EventMouseButtonBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EventMouseButton> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EventMouseButton>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EventMouseButton> CreateEventMouseButton(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const UserInteractionFB::SingleVec2 *pos = nullptr,
    uint32_t mouse_id = 0,
    bool is_touch = false,
    UserInteractionFB::MouseButton button = UserInteractionFB::MouseButton_None,
    UserInteractionFB::MouseButtonEventType type = UserInteractionFB::MouseButtonEventType_Up) {
  EventMouseButtonBuilder builder_(_fbb);
  builder_.add_mouse_id(mouse_id);
  builder_.add_pos(pos);
  builder_.add_type(type);
  builder_.add_button(button);
  builder_.add_is_touch(is_touch);
  return builder_.Finish();
}

struct EventTextInput FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EventTextInputBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return EventTextInputTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEXT = 4
  };
  const ::flatbuffers::String *text() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TEXT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           verifier.EndTable();
  }
};

struct EventTextInputBuilder {
  typedef EventTextInput Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_text(::flatbuffers::Offset<::flatbuffers::String> text) {
    fbb_.AddOffset(EventTextInput::VT_TEXT, text);
  }
  explicit EventTextInputBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EventTextInput> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EventTextInput>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EventTextInput> CreateEventTextInput(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> text = 0) {
  EventTextInputBuilder builder_(_fbb);
  builder_.add_text(text);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<EventTextInput> CreateEventTextInputDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *text = nullptr) {
  auto text__ = text ? _fbb.CreateString(text) : 0;
  return UserInteractionFB::CreateEventTextInput(
      _fbb,
      text__);
}

struct Event FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EventBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return EventTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EVENT_TYPE = 4,
    VT_EVENT = 6
  };
  UserInteractionFB::UserInteraction event_type() const {
    return static_cast<UserInteractionFB::UserInteraction>(GetField<uint8_t>(VT_EVENT_TYPE, 0));
  }
  const void *event() const {
    return GetPointer<const void *>(VT_EVENT);
  }
  template<typename T> const T *event_as() const;
  const UserInteractionFB::EventMouseMotion *event_as_EventMouseMotion() const {
    return event_type() == UserInteractionFB::UserInteraction_EventMouseMotion ? static_cast<const UserInteractionFB::EventMouseMotion *>(event()) : nullptr;
  }
  const UserInteractionFB::EventMouseWheel *event_as_EventMouseWheel() const {
    return event_type() == UserInteractionFB::UserInteraction_EventMouseWheel ? static_cast<const UserInteractionFB::EventMouseWheel *>(event()) : nullptr;
  }
  const UserInteractionFB::EventMouseButton *event_as_EventMouseButton() const {
    return event_type() == UserInteractionFB::UserInteraction_EventMouseButton ? static_cast<const UserInteractionFB::EventMouseButton *>(event()) : nullptr;
  }
  const UserInteractionFB::EventTextInput *event_as_EventTextInput() const {
    return event_type() == UserInteractionFB::UserInteraction_EventTextInput ? static_cast<const UserInteractionFB::EventTextInput *>(event()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_EVENT_TYPE, 1) &&
           VerifyOffset(verifier, VT_EVENT) &&
           VerifyUserInteraction(verifier, event(), event_type()) &&
           verifier.EndTable();
  }
};

template<> inline const UserInteractionFB::EventMouseMotion *Event::event_as<UserInteractionFB::EventMouseMotion>() const {
  return event_as_EventMouseMotion();
}

template<> inline const UserInteractionFB::EventMouseWheel *Event::event_as<UserInteractionFB::EventMouseWheel>() const {
  return event_as_EventMouseWheel();
}

template<> inline const UserInteractionFB::EventMouseButton *Event::event_as<UserInteractionFB::EventMouseButton>() const {
  return event_as_EventMouseButton();
}

template<> inline const UserInteractionFB::EventTextInput *Event::event_as<UserInteractionFB::EventTextInput>() const {
  return event_as_EventTextInput();
}

struct EventBuilder {
  typedef Event Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_event_type(UserInteractionFB::UserInteraction event_type) {
    fbb_.AddElement<uint8_t>(Event::VT_EVENT_TYPE, static_cast<uint8_t>(event_type), 0);
  }
  void add_event(::flatbuffers::Offset<void> event) {
    fbb_.AddOffset(Event::VT_EVENT, event);
  }
  explicit EventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Event> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Event>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Event> CreateEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    UserInteractionFB::UserInteraction event_type = UserInteractionFB::UserInteraction_NONE,
    ::flatbuffers::Offset<void> event = 0) {
  EventBuilder builder_(_fbb);
  builder_.add_event(event);
  builder_.add_event_type(event_type);
  return builder_.Finish();
}

inline bool VerifyUserInteraction(::flatbuffers::Verifier &verifier, const void *obj, UserInteraction type) {
  switch (type) {
    case UserInteraction_NONE: {
      return true;
    }
    case UserInteraction_EventMouseMotion: {
      auto ptr = reinterpret_cast<const UserInteractionFB::EventMouseMotion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case UserInteraction_EventMouseWheel: {
      auto ptr = reinterpret_cast<const UserInteractionFB::EventMouseWheel *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case UserInteraction_EventMouseButton: {
      auto ptr = reinterpret_cast<const UserInteractionFB::EventMouseButton *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case UserInteraction_EventTextInput: {
      auto ptr = reinterpret_cast<const UserInteractionFB::EventTextInput *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyUserInteractionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyUserInteraction(
        verifier,  values->Get(i), types->GetEnum<UserInteraction>(i))) {
      return false;
    }
  }
  return true;
}

inline const ::flatbuffers::TypeTable *MouseButtonTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    UserInteractionFB::MouseButtonTypeTable
  };
  static const char * const names[] = {
    "None",
    "Left",
    "Right",
    "Middle",
    "X1",
    "X2"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 6, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *MouseButtonEventTypeTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    UserInteractionFB::MouseButtonEventTypeTypeTable
  };
  static const char * const names[] = {
    "Up",
    "Down"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *UserInteractionTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 2 },
    { ::flatbuffers::ET_SEQUENCE, 0, 3 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    UserInteractionFB::EventMouseMotionTypeTable,
    UserInteractionFB::EventMouseWheelTypeTable,
    UserInteractionFB::EventMouseButtonTypeTable,
    UserInteractionFB::EventTextInputTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "EventMouseMotion",
    "EventMouseWheel",
    "EventMouseButton",
    "EventTextInput"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_UNION, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *SingleVec2TypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const int64_t values[] = { 0, 4, 8 };
  static const char * const names[] = {
    "x",
    "y"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_STRUCT, 2, type_codes, nullptr, nullptr, values, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *SingleVec4TypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const int64_t values[] = { 0, 4, 8, 12, 16 };
  static const char * const names[] = {
    "x",
    "y",
    "z",
    "w"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_STRUCT, 4, type_codes, nullptr, nullptr, values, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ArrayOfVec2TypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_FLOAT, 1, -1 },
    { ::flatbuffers::ET_FLOAT, 1, -1 }
  };
  static const char * const names[] = {
    "xs",
    "ys"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ArrayOfVec4TypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_FLOAT, 1, -1 },
    { ::flatbuffers::ET_FLOAT, 1, -1 },
    { ::flatbuffers::ET_FLOAT, 1, -1 },
    { ::flatbuffers::ET_FLOAT, 1, -1 }
  };
  static const char * const names[] = {
    "xs",
    "ys",
    "zs",
    "ws"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *EventMouseMotionTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    UserInteractionFB::SingleVec2TypeTable
  };
  static const char * const names[] = {
    "pos",
    "mouse_id",
    "is_touch"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *EventMouseWheelTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    UserInteractionFB::SingleVec2TypeTable
  };
  static const char * const names[] = {
    "pos",
    "mouse_id",
    "is_touch"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *EventMouseButtonTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_UCHAR, 0, 1 },
    { ::flatbuffers::ET_UCHAR, 0, 2 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    UserInteractionFB::SingleVec2TypeTable,
    UserInteractionFB::MouseButtonTypeTable,
    UserInteractionFB::MouseButtonEventTypeTypeTable
  };
  static const char * const names[] = {
    "pos",
    "mouse_id",
    "is_touch",
    "button",
    "type"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *EventTextInputTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "text"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *EventTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UTYPE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    UserInteractionFB::UserInteractionTypeTable
  };
  static const char * const names[] = {
    "event_type",
    "event"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const UserInteractionFB::Event *GetEvent(const void *buf) {
  return ::flatbuffers::GetRoot<UserInteractionFB::Event>(buf);
}

inline const UserInteractionFB::Event *GetSizePrefixedEvent(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<UserInteractionFB::Event>(buf);
}

inline bool VerifyEventBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<UserInteractionFB::Event>(nullptr);
}

inline bool VerifySizePrefixedEventBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<UserInteractionFB::Event>(nullptr);
}

inline void FinishEventBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<UserInteractionFB::Event> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedEventBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<UserInteractionFB::Event> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace UserInteractionFB

#endif  // FLATBUFFERS_GENERATED_USERINTERACTION_USERINTERACTIONFB_H_
