// Code generated by fffi generator; DO NOT EDIT.
/* {"features": {"noThrowTrue": true, "noThrowFalse": false}, "minId": 0, "maxId": 1035, "hash": 23(h'26fbee22f7e5cb61bc0b27d4ef64d773')} */
#define FFFI_COMPATIBILITY_RECORD "pGhmZWF0dXJlc6Jrbm9UaHJvd1RydWX1bG5vVGhyb3dGYWxzZfRlbWluSWQAZW1heElkGQQLZGhhc2jXUCb77iL35cthvAsn1O9k13M";
case 0x00000000:
  {
    FFFI_FUNCTION_INVOCATION("Checkbox")
    auto label = receiveString();
    auto state = receiveValueSignMagnitude<int8_t>();
    int8_t checked;
    bool clicked;
    {
    
         bool v = state > 0;
         if(state == 0) {
              checked = state;
              ImGui::PushItemFlag(ImGuiItemFlags_MixedValue, true);
              clicked = ImGui::Checkbox(label, &v);
              ImGui::PopItemFlag();
              if(clicked) {
                 checked = 1;
              }
         } else {
              clicked = ImGui::Checkbox(label, &v);
              checked = v ? 1 : -1;
         }
;
    sendValueSignMagnitude<int8_t>(checked);
    sendValue<bool>(clicked);
    flushSend();
  }
  }
  break;
case 0x00000001:
  {
    FFFI_FUNCTION_INVOCATION("ColorEdit3")
    auto label = receiveString();
    auto colP = receiveArray<float,3>();
    auto flags = receiveValueSignMagnitude<int>();
    float* col;
    bool changed;
    {
    changed = ImGui::ColorEdit3(label,colP,flags);
col = colP;;
    sendArray<float,3>(col);
    sendValue<bool>(changed);
    flushSend();
  }
  }
  break;
case 0x00000002:
  {
    FFFI_FUNCTION_INVOCATION("ColorEdit4")
    auto label = receiveString();
    auto colP = receiveArray<float,4>();
    auto flags = receiveValueSignMagnitude<int>();
    float* col;
    bool changed;
    {
    changed = ImGui::ColorEdit4(label,colP,flags);
col = colP;;
    sendArray<float,4>(col);
    sendValue<bool>(changed);
    flushSend();
  }
  }
  break;
case 0x00000003:
  {
    FFFI_FUNCTION_INVOCATION("GetItemStatus")
    uint16_t status;
    {
    status = GetItemStatus();
    sendValue<uint16_t>(status);
    flushSend();
  }
  }
  break;
case 0x00000004:
  {
    FFFI_FUNCTION_INVOCATION("GetItemStatusV")
    auto primary = receiveValueSignMagnitude<int>();
    auto secondary = receiveValueSignMagnitude<int>();
    uint16_t status;
    {
    status = GetItemStatus(primary, secondary);
    sendValue<uint16_t>(status);
    flushSend();
  }
  }
  break;
case 0x00000005:
  {
    FFFI_FUNCTION_INVOCATION("CurrentCursorPos")
    float* r;
    {
    auto r = ImGui::GetCurrentWindow()->DC.CursorPos;
    sendArray<float,2>(r);
    flushSend();
  }
  }
  break;
case 0x00000006:
  {
    FFFI_FUNCTION_INVOCATION("BeginCustomWidget")
    bool visible;
    uintptr_t currentWindowDrawList;
    float* pos;
    float* availableRegion;
    bool keyboardNavActive;
    uint32_t seed;
    {
    ImVec2 pos;
         ImVec2 availableRegion;
         visible = BeginCustomWidget((ImDrawList**)&currentWindowDrawList,&pos,&availableRegion,&keyboardNavActive,&seed);
         ;
    sendValue<bool>(visible);
    sendValue(currentWindowDrawList);
    sendArray<float,2>(pos);
    sendArray<float,2>(availableRegion);
    sendValue<bool>(keyboardNavActive);
    sendValue<uint32_t>(seed);
    flushSend();
  }
  }
  break;
case 0x00000007:
  {
    FFFI_FUNCTION_INVOCATION("SetTooltip")
    auto str = receiveString();
    {
    ImGui::SetTooltip("%.*s",(int)getStringLength(str),str);
  }
  }
  break;
case 0x00000008:
  {
    FFFI_FUNCTION_INVOCATION("MakeImCoolBarConfig")
    uintptr_t r;
    {
    r = (uintptr_t)(new ImGui::ImCoolBarConfig());
    sendValue(r);
    flushSend();
  }
  }
  break;
case 0x00000009:
  {
    FFFI_FUNCTION_INVOCATION("MakeImCoolBarConfigV")
    auto anchor = receiveArray<float,2>();
    auto normalSize = receiveValue<float>();
    auto hoveredSize = receiveValue<float>();
    auto animStep = receiveValue<float>();
    auto effectStrength = receiveValue<float>();
    uintptr_t r;
    {
    r = (uintptr_t)(new ImGui::ImCoolBarConfig(anchor,normalSize,hoveredSize,animStep,effectStrength));
    sendValue(r);
    flushSend();
  }
  }
  break;
case 0x0000000a:
  {
    FFFI_FUNCTION_INVOCATION("DestroyImCoolBarConfig")
    auto cfg = receiveValue<uintptr_t>();
    {
    delete ((ImGui::ImCoolBarConfig*)cfg);
  }
  }
  break;
case 0x0000000b:
  {
    FFFI_FUNCTION_INVOCATION("Get")
    auto foreignptr = receiveValue<uintptr_t>();
    float* anchor;
    float normalSize;
    float hoveredSize;
    float animStep;
    float effectStrength;
    {
    
auto t = (ImGui::ImCoolBarConfig*)foreignptr;
auto anchor = t->anchor;
normalSize = t->normal_size;
hoveredSize = t->hovered_size;
animStep = t->anim_step;
effectStrength = t->effect_strength;
;
    sendArray<float,2>(anchor);
    sendValue<float>(normalSize);
    sendValue<float>(hoveredSize);
    sendValue<float>(animStep);
    sendValue<float>(effectStrength);
    flushSend();
  }
  }
  break;
case 0x0000000c:
  {
    FFFI_FUNCTION_INVOCATION("Set")
    auto foreignptr = receiveValue<uintptr_t>();
    auto anchor = receiveArray<float,2>();
    auto normalSize = receiveValue<float>();
    auto hoveredSize = receiveValue<float>();
    auto animStep = receiveValue<float>();
    auto effectStrength = receiveValue<float>();
    {
    
auto t = (ImGui::ImCoolBarConfig*)foreignptr;
t->anchor = anchor;
t->normal_size = normalSize;
t->hovered_size = hoveredSize;
t->anim_step = animStep;
t->effect_strength = effectStrength;
;
  }
  }
  break;
case 0x0000000d:
  {
    FFFI_FUNCTION_INVOCATION("BeginCoolBar")
    auto label = receiveString();
    bool r;
    {
    r = ImGui::BeginCoolBar(label);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x0000000e:
  {
    FFFI_FUNCTION_INVOCATION("BeginCoolBarV")
    auto label = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    auto cfg = receiveValue<uintptr_t>();
    auto windowFlags = receiveValueSignMagnitude<int>();
    bool r;
    {
    r = ImGui::BeginCoolBar(label, flags, *((ImGui::ImCoolBarConfig*)cfg), windowFlags);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x0000000f:
  {
    FFFI_FUNCTION_INVOCATION("EndCoolBar")
    {
    ImGui::EndCoolBar();
  }
  }
  break;
case 0x00000010:
  {
    FFFI_FUNCTION_INVOCATION("CoolBarItem")
    bool r;
    {
    r = ImGui::CoolBarItem();
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000011:
  {
    FFFI_FUNCTION_INVOCATION("CoolBarItemProperties")
    float width;
    float scale;
    {
    
width = ImGui::GetCoolBarItemWidth();
scale = ImGui::GetCoolBarItemScale();
;
    sendValue<float>(width);
    sendValue<float>(scale);
    flushSend();
  }
  }
  break;
case 0x00000012:
  {
    FFFI_FUNCTION_INVOCATION("CoolBarButtons")
    auto fontPtr = receiveValue<uintptr_t>();
    auto labels = receiveStrings();
    auto tooltips = receiveStrings();
    int clickedIndex;
    int hoveredIndex;
    {
    
auto l = (int)std::min(getSliceLength(labels),getSliceLength(tooltips));
clickedIndex = -1;
hoveredIndex = -1;
ImGuiWindow* window = ImGui::GetCurrentWindow();
if (window->SkipItems) { return; } // GetCoolBarItemScale() will return 0.0f if window is non-visible
if(l > 0) {
   auto font_ptr = (ImFont*)fontPtr;
   if(font_ptr == nullptr) {
      if(ImGui::GetIO().Fonts == nullptr) {
          return;
      }
      font_ptr = ImGui::GetIO().Fonts->Fonts[0];
      if(font_ptr == nullptr) {
          return;
      }
   }
   auto saved_scale = font_ptr->Scale;
   for(int i=0;i<l;i++) {
       if(ImGui::CoolBarItem()) {
   	      float w = ImGui::GetCoolBarItemWidth();
          ImGui::PushFont(font_ptr);
   	      auto s = ImGui::GetCoolBarItemScale();
          if(s > 0.0f) {
			  font_ptr->Scale = s;
          }
          auto label = labels[i];
   	      if(ImGui::Button(label, ImVec2(w, w))) {
   	      	  clickedIndex = i;
   	      }
          ImGui::PopFont();

          if(ImGui::IsItemHovered(ImGuiHoveredFlags_ForTooltip) && ImGui::BeginTooltip()) {
              ImGui::TextUnformatted(tooltips[i],tooltips[i]+getStringLength(tooltips[i]));
              ImGui::EndTooltip();
          }
      }
   }
   font_ptr->Scale = saved_scale;
}
;
    sendValueSignMagnitude<int>(clickedIndex);
    sendValueSignMagnitude<int>(hoveredIndex);
    flushSend();
  }
  }
  break;
case 0x00000013:
  {
    FFFI_FUNCTION_INVOCATION("DragFloat32")
    auto label = receiveString();
    auto vP = receiveValue<float>();
    float v;
    bool r;
    {
    
r = ImGui::DragScalar(label,ImGuiDataType_Float,(void*)&vP);
v = vP;
;
    sendValue<float>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000014:
  {
    FFFI_FUNCTION_INVOCATION("DragFloat32V")
    auto label = receiveString();
    auto vP = receiveValue<float>();
    auto v_speed = receiveValue<float>();
    auto p_min = receiveValue<float>();
    auto p_max = receiveValue<float>();
    auto format = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    float v;
    bool r;
    {
    
r = ImGui::DragScalar(label,ImGuiDataType_Float,(void*)&vP,v_speed,(const void*)&p_min,(const void*)&p_max,format,flags);
v = vP;
;
    sendValue<float>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000015:
  {
    FFFI_FUNCTION_INVOCATION("DragFloat32NV")
    auto label = receiveString();
    auto vP = receiveSlice<float>();
    auto v_speed = receiveValue<float>();
    auto v_min = receiveValue<float>();
    auto v_max = receiveValue<float>();
    auto format = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    float* v;
    bool r;
    {
    
size_t v_len = getSliceLength(vP);
r = ImGui::DragScalarN(label,ImGuiDataType_Float,(void*)vP,(int)v_len,v_speed,(const void*)&v_min,(const void*)&v_max,format,flags);
v = vP;
;
    sendSlice<float>(v,v_len);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000016:
  {
    FFFI_FUNCTION_INVOCATION("DragFloat32N")
    auto label = receiveString();
    auto vP = receiveSlice<float>();
    float* v;
    bool r;
    {
    
size_t v_len = getSliceLength(vP);
r = ImGui::DragScalarN(label,ImGuiDataType_Float,(void*)vP,(int)v_len);
v = vP;
;
    sendSlice<float>(v,v_len);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000017:
  {
    FFFI_FUNCTION_INVOCATION("DragFloat64")
    auto label = receiveString();
    auto vP = receiveValue<double>();
    double v;
    bool r;
    {
    
r = ImGui::DragScalar(label,ImGuiDataType_Double,(void*)&vP);
v = vP;
;
    sendValue<double>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000018:
  {
    FFFI_FUNCTION_INVOCATION("DragFloat64V")
    auto label = receiveString();
    auto vP = receiveValue<double>();
    auto v_speed = receiveValue<float>();
    auto p_min = receiveValue<double>();
    auto p_max = receiveValue<double>();
    auto format = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    double v;
    bool r;
    {
    
r = ImGui::DragScalar(label,ImGuiDataType_Double,(void*)&vP,v_speed,(const void*)&p_min,(const void*)&p_max,format,flags);
v = vP;
;
    sendValue<double>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000019:
  {
    FFFI_FUNCTION_INVOCATION("DragFloat64NV")
    auto label = receiveString();
    auto vP = receiveSlice<double>();
    auto v_speed = receiveValue<float>();
    auto v_min = receiveValue<double>();
    auto v_max = receiveValue<double>();
    auto format = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    double* v;
    bool r;
    {
    
size_t v_len = getSliceLength(vP);
r = ImGui::DragScalarN(label,ImGuiDataType_Double,(void*)vP,(int)v_len,v_speed,(const void*)&v_min,(const void*)&v_max,format,flags);
v = vP;
;
    sendSlice<double>(v,v_len);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x0000001a:
  {
    FFFI_FUNCTION_INVOCATION("DragFloat64N")
    auto label = receiveString();
    auto vP = receiveSlice<double>();
    double* v;
    bool r;
    {
    
size_t v_len = getSliceLength(vP);
r = ImGui::DragScalarN(label,ImGuiDataType_Double,(void*)vP,(int)v_len);
v = vP;
;
    sendSlice<double>(v,v_len);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x0000001b:
  {
    FFFI_FUNCTION_INVOCATION("DragInt")
    auto label = receiveString();
    auto vP = receiveValueSignMagnitude<int>();
    int v;
    bool r;
    {
    
r = ImGui::DragScalar(label,ImGuiDataType_S32,(void*)&vP);
v = vP;
;
    sendValueSignMagnitude<int>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x0000001c:
  {
    FFFI_FUNCTION_INVOCATION("DragIntV")
    auto label = receiveString();
    auto vP = receiveValueSignMagnitude<int>();
    auto v_speed = receiveValue<float>();
    auto p_min = receiveValueSignMagnitude<int>();
    auto p_max = receiveValueSignMagnitude<int>();
    auto format = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    int v;
    bool r;
    {
    
r = ImGui::DragScalar(label,ImGuiDataType_S32,(void*)&vP,v_speed,(const void*)&p_min,(const void*)&p_max,format,flags);
v = vP;
;
    sendValueSignMagnitude<int>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x0000001d:
  {
    FFFI_FUNCTION_INVOCATION("DragIntNV")
    auto label = receiveString();
    auto vP = receiveSlice<int>();
    auto v_speed = receiveValue<float>();
    auto v_min = receiveValueSignMagnitude<int>();
    auto v_max = receiveValueSignMagnitude<int>();
    auto format = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    int* v;
    bool r;
    {
    
size_t v_len = getSliceLength(vP);
r = ImGui::DragScalarN(label,ImGuiDataType_S32,(void*)vP,(int)v_len,v_speed,(const void*)&v_min,(const void*)&v_max,format,flags);
v = vP;
;
    sendSlice<int>(v,v_len);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x0000001e:
  {
    FFFI_FUNCTION_INVOCATION("DragIntN")
    auto label = receiveString();
    auto vP = receiveSlice<int>();
    int* v;
    bool r;
    {
    
size_t v_len = getSliceLength(vP);
r = ImGui::DragScalarN(label,ImGuiDataType_S32,(void*)vP,(int)v_len);
v = vP;
;
    sendSlice<int>(v,v_len);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x0000001f:
  {
    FFFI_FUNCTION_INVOCATION("DragInt16")
    auto label = receiveString();
    auto vP = receiveValueSignMagnitude<int16_t>();
    int16_t v;
    bool r;
    {
    
r = ImGui::DragScalar(label,ImGuiDataType_S16,(void*)&vP);
v = vP;
;
    sendValueSignMagnitude<int16_t>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000020:
  {
    FFFI_FUNCTION_INVOCATION("DragInt16V")
    auto label = receiveString();
    auto vP = receiveValueSignMagnitude<int16_t>();
    auto v_speed = receiveValue<float>();
    auto p_min = receiveValueSignMagnitude<int16_t>();
    auto p_max = receiveValueSignMagnitude<int16_t>();
    auto format = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    int16_t v;
    bool r;
    {
    
r = ImGui::DragScalar(label,ImGuiDataType_S16,(void*)&vP,v_speed,(const void*)&p_min,(const void*)&p_max,format,flags);
v = vP;
;
    sendValueSignMagnitude<int16_t>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000021:
  {
    FFFI_FUNCTION_INVOCATION("DragInt16NV")
    auto label = receiveString();
    auto vP = receiveSlice<int16_t>();
    auto v_speed = receiveValue<float>();
    auto v_min = receiveValueSignMagnitude<int16_t>();
    auto v_max = receiveValueSignMagnitude<int16_t>();
    auto format = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    int16_t* v;
    bool r;
    {
    
size_t v_len = getSliceLength(vP);
r = ImGui::DragScalarN(label,ImGuiDataType_S16,(void*)vP,(int)v_len,v_speed,(const void*)&v_min,(const void*)&v_max,format,flags);
v = vP;
;
    sendSlice<int16_t>(v,v_len);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000022:
  {
    FFFI_FUNCTION_INVOCATION("DragInt16N")
    auto label = receiveString();
    auto vP = receiveSlice<int16_t>();
    int16_t* v;
    bool r;
    {
    
size_t v_len = getSliceLength(vP);
r = ImGui::DragScalarN(label,ImGuiDataType_S16,(void*)vP,(int)v_len);
v = vP;
;
    sendSlice<int16_t>(v,v_len);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000023:
  {
    FFFI_FUNCTION_INVOCATION("DragInt32")
    auto label = receiveString();
    auto vP = receiveValueSignMagnitude<int32_t>();
    int32_t v;
    bool r;
    {
    
r = ImGui::DragScalar(label,ImGuiDataType_S32,(void*)&vP);
v = vP;
;
    sendValueSignMagnitude<int32_t>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000024:
  {
    FFFI_FUNCTION_INVOCATION("DragInt32V")
    auto label = receiveString();
    auto vP = receiveValueSignMagnitude<int32_t>();
    auto v_speed = receiveValue<float>();
    auto p_min = receiveValueSignMagnitude<int32_t>();
    auto p_max = receiveValueSignMagnitude<int32_t>();
    auto format = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    int32_t v;
    bool r;
    {
    
r = ImGui::DragScalar(label,ImGuiDataType_S32,(void*)&vP,v_speed,(const void*)&p_min,(const void*)&p_max,format,flags);
v = vP;
;
    sendValueSignMagnitude<int32_t>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000025:
  {
    FFFI_FUNCTION_INVOCATION("DragInt32NV")
    auto label = receiveString();
    auto vP = receiveSlice<int32_t>();
    auto v_speed = receiveValue<float>();
    auto v_min = receiveValueSignMagnitude<int32_t>();
    auto v_max = receiveValueSignMagnitude<int32_t>();
    auto format = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    int32_t* v;
    bool r;
    {
    
size_t v_len = getSliceLength(vP);
r = ImGui::DragScalarN(label,ImGuiDataType_S32,(void*)vP,(int)v_len,v_speed,(const void*)&v_min,(const void*)&v_max,format,flags);
v = vP;
;
    sendSlice<int32_t>(v,v_len);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000026:
  {
    FFFI_FUNCTION_INVOCATION("DragInt32N")
    auto label = receiveString();
    auto vP = receiveSlice<int32_t>();
    int32_t* v;
    bool r;
    {
    
size_t v_len = getSliceLength(vP);
r = ImGui::DragScalarN(label,ImGuiDataType_S32,(void*)vP,(int)v_len);
v = vP;
;
    sendSlice<int32_t>(v,v_len);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000027:
  {
    FFFI_FUNCTION_INVOCATION("DragInt8")
    auto label = receiveString();
    auto vP = receiveValueSignMagnitude<int8_t>();
    int8_t v;
    bool r;
    {
    
r = ImGui::DragScalar(label,ImGuiDataType_S8,(void*)&vP);
v = vP;
;
    sendValueSignMagnitude<int8_t>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000028:
  {
    FFFI_FUNCTION_INVOCATION("DragInt8V")
    auto label = receiveString();
    auto vP = receiveValueSignMagnitude<int8_t>();
    auto v_speed = receiveValue<float>();
    auto p_min = receiveValueSignMagnitude<int8_t>();
    auto p_max = receiveValueSignMagnitude<int8_t>();
    auto format = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    int8_t v;
    bool r;
    {
    
r = ImGui::DragScalar(label,ImGuiDataType_S8,(void*)&vP,v_speed,(const void*)&p_min,(const void*)&p_max,format,flags);
v = vP;
;
    sendValueSignMagnitude<int8_t>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000029:
  {
    FFFI_FUNCTION_INVOCATION("DragInt8NV")
    auto label = receiveString();
    auto vP = receiveSlice<int8_t>();
    auto v_speed = receiveValue<float>();
    auto v_min = receiveValueSignMagnitude<int8_t>();
    auto v_max = receiveValueSignMagnitude<int8_t>();
    auto format = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    int8_t* v;
    bool r;
    {
    
size_t v_len = getSliceLength(vP);
r = ImGui::DragScalarN(label,ImGuiDataType_S8,(void*)vP,(int)v_len,v_speed,(const void*)&v_min,(const void*)&v_max,format,flags);
v = vP;
;
    sendSlice<int8_t>(v,v_len);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x0000002a:
  {
    FFFI_FUNCTION_INVOCATION("DragInt8N")
    auto label = receiveString();
    auto vP = receiveSlice<int8_t>();
    int8_t* v;
    bool r;
    {
    
size_t v_len = getSliceLength(vP);
r = ImGui::DragScalarN(label,ImGuiDataType_S8,(void*)vP,(int)v_len);
v = vP;
;
    sendSlice<int8_t>(v,v_len);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x0000002b:
  {
    FFFI_FUNCTION_INVOCATION("DragUInt")
    auto label = receiveString();
    auto vP = receiveValue<unsigned>();
    unsigned v;
    bool r;
    {
    
r = ImGui::DragScalar(label,ImGuiDataType_U32,(void*)&vP);
v = vP;
;
    sendValue<unsigned>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x0000002c:
  {
    FFFI_FUNCTION_INVOCATION("DragUIntV")
    auto label = receiveString();
    auto vP = receiveValue<unsigned>();
    auto v_speed = receiveValue<float>();
    auto p_min = receiveValue<unsigned>();
    auto p_max = receiveValue<unsigned>();
    auto format = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    unsigned v;
    bool r;
    {
    
r = ImGui::DragScalar(label,ImGuiDataType_U32,(void*)&vP,v_speed,(const void*)&p_min,(const void*)&p_max,format,flags);
v = vP;
;
    sendValue<unsigned>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x0000002d:
  {
    FFFI_FUNCTION_INVOCATION("DragUIntNV")
    auto label = receiveString();
    auto vP = receiveSlice<unsigned>();
    auto v_speed = receiveValue<float>();
    auto v_min = receiveValue<unsigned>();
    auto v_max = receiveValue<unsigned>();
    auto format = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    unsigned* v;
    bool r;
    {
    
size_t v_len = getSliceLength(vP);
r = ImGui::DragScalarN(label,ImGuiDataType_U32,(void*)vP,(int)v_len,v_speed,(const void*)&v_min,(const void*)&v_max,format,flags);
v = vP;
;
    sendSlice<unsigned>(v,v_len);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x0000002e:
  {
    FFFI_FUNCTION_INVOCATION("DragUIntN")
    auto label = receiveString();
    auto vP = receiveSlice<unsigned>();
    unsigned* v;
    bool r;
    {
    
size_t v_len = getSliceLength(vP);
r = ImGui::DragScalarN(label,ImGuiDataType_U32,(void*)vP,(int)v_len);
v = vP;
;
    sendSlice<unsigned>(v,v_len);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x0000002f:
  {
    FFFI_FUNCTION_INVOCATION("DragUInt16")
    auto label = receiveString();
    auto vP = receiveValue<uint16_t>();
    uint16_t v;
    bool r;
    {
    
r = ImGui::DragScalar(label,ImGuiDataType_U16,(void*)&vP);
v = vP;
;
    sendValue<uint16_t>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000030:
  {
    FFFI_FUNCTION_INVOCATION("DragUInt16V")
    auto label = receiveString();
    auto vP = receiveValue<uint16_t>();
    auto v_speed = receiveValue<float>();
    auto p_min = receiveValue<uint16_t>();
    auto p_max = receiveValue<uint16_t>();
    auto format = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    uint16_t v;
    bool r;
    {
    
r = ImGui::DragScalar(label,ImGuiDataType_U16,(void*)&vP,v_speed,(const void*)&p_min,(const void*)&p_max,format,flags);
v = vP;
;
    sendValue<uint16_t>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000031:
  {
    FFFI_FUNCTION_INVOCATION("DragUInt16NV")
    auto label = receiveString();
    auto vP = receiveSlice<uint16_t>();
    auto v_speed = receiveValue<float>();
    auto v_min = receiveValue<uint16_t>();
    auto v_max = receiveValue<uint16_t>();
    auto format = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    uint16_t* v;
    bool r;
    {
    
size_t v_len = getSliceLength(vP);
r = ImGui::DragScalarN(label,ImGuiDataType_U16,(void*)vP,(int)v_len,v_speed,(const void*)&v_min,(const void*)&v_max,format,flags);
v = vP;
;
    sendSlice<uint16_t>(v,v_len);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000032:
  {
    FFFI_FUNCTION_INVOCATION("DragUInt16N")
    auto label = receiveString();
    auto vP = receiveSlice<uint16_t>();
    uint16_t* v;
    bool r;
    {
    
size_t v_len = getSliceLength(vP);
r = ImGui::DragScalarN(label,ImGuiDataType_U16,(void*)vP,(int)v_len);
v = vP;
;
    sendSlice<uint16_t>(v,v_len);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000033:
  {
    FFFI_FUNCTION_INVOCATION("DragUInt32")
    auto label = receiveString();
    auto vP = receiveValue<uint32_t>();
    uint32_t v;
    bool r;
    {
    
r = ImGui::DragScalar(label,ImGuiDataType_U32,(void*)&vP);
v = vP;
;
    sendValue<uint32_t>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000034:
  {
    FFFI_FUNCTION_INVOCATION("DragUInt32V")
    auto label = receiveString();
    auto vP = receiveValue<uint32_t>();
    auto v_speed = receiveValue<float>();
    auto p_min = receiveValue<uint32_t>();
    auto p_max = receiveValue<uint32_t>();
    auto format = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    uint32_t v;
    bool r;
    {
    
r = ImGui::DragScalar(label,ImGuiDataType_U32,(void*)&vP,v_speed,(const void*)&p_min,(const void*)&p_max,format,flags);
v = vP;
;
    sendValue<uint32_t>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000035:
  {
    FFFI_FUNCTION_INVOCATION("DragUInt32NV")
    auto label = receiveString();
    auto vP = receiveSlice<uint32_t>();
    auto v_speed = receiveValue<float>();
    auto v_min = receiveValue<uint32_t>();
    auto v_max = receiveValue<uint32_t>();
    auto format = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    uint32_t* v;
    bool r;
    {
    
size_t v_len = getSliceLength(vP);
r = ImGui::DragScalarN(label,ImGuiDataType_U32,(void*)vP,(int)v_len,v_speed,(const void*)&v_min,(const void*)&v_max,format,flags);
v = vP;
;
    sendSlice<uint32_t>(v,v_len);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000036:
  {
    FFFI_FUNCTION_INVOCATION("DragUInt32N")
    auto label = receiveString();
    auto vP = receiveSlice<uint32_t>();
    uint32_t* v;
    bool r;
    {
    
size_t v_len = getSliceLength(vP);
r = ImGui::DragScalarN(label,ImGuiDataType_U32,(void*)vP,(int)v_len);
v = vP;
;
    sendSlice<uint32_t>(v,v_len);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000037:
  {
    FFFI_FUNCTION_INVOCATION("DragUInt8")
    auto label = receiveString();
    auto vP = receiveValue<uint8_t>();
    uint8_t v;
    bool r;
    {
    
r = ImGui::DragScalar(label,ImGuiDataType_U8,(void*)&vP);
v = vP;
;
    sendValue<uint8_t>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000038:
  {
    FFFI_FUNCTION_INVOCATION("DragUInt8V")
    auto label = receiveString();
    auto vP = receiveValue<uint8_t>();
    auto v_speed = receiveValue<float>();
    auto p_min = receiveValue<uint8_t>();
    auto p_max = receiveValue<uint8_t>();
    auto format = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    uint8_t v;
    bool r;
    {
    
r = ImGui::DragScalar(label,ImGuiDataType_U8,(void*)&vP,v_speed,(const void*)&p_min,(const void*)&p_max,format,flags);
v = vP;
;
    sendValue<uint8_t>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000039:
  {
    FFFI_FUNCTION_INVOCATION("DragUInt8NV")
    auto label = receiveString();
    auto vP = receiveSlice<uint8_t>();
    auto v_speed = receiveValue<float>();
    auto v_min = receiveValue<uint8_t>();
    auto v_max = receiveValue<uint8_t>();
    auto format = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    uint8_t* v;
    bool r;
    {
    
size_t v_len = getSliceLength(vP);
r = ImGui::DragScalarN(label,ImGuiDataType_U8,(void*)vP,(int)v_len,v_speed,(const void*)&v_min,(const void*)&v_max,format,flags);
v = vP;
;
    sendSlice<uint8_t>(v,v_len);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x0000003a:
  {
    FFFI_FUNCTION_INVOCATION("DragUInt8N")
    auto label = receiveString();
    auto vP = receiveSlice<uint8_t>();
    uint8_t* v;
    bool r;
    {
    
size_t v_len = getSliceLength(vP);
r = ImGui::DragScalarN(label,ImGuiDataType_U8,(void*)vP,(int)v_len);
v = vP;
;
    sendSlice<uint8_t>(v,v_len);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x0000003b:
  {
    FFFI_FUNCTION_INVOCATION("DragFloat")
    auto label = receiveString();
    auto vP = receiveValue<float>();
    float v;
    bool r;
    {
    r = ImGui::DragFloat(label, &vP);
v = vP;;
    sendValue<float>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x0000003c:
  {
    FFFI_FUNCTION_INVOCATION("DragFloatV")
    auto label = receiveString();
    auto vP = receiveValue<float>();
    auto v_speed = receiveValue<float>();
    auto v_min = receiveValue<float>();
    auto v_max = receiveValue<float>();
    auto format = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    float v;
    bool r;
    {
    r = ImGui::DragFloat(label, &vP, v_speed, v_min, v_max, format, flags);
v = vP;;
    sendValue<float>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x0000003d:
  {
    FFFI_FUNCTION_INVOCATION("DragFloat2")
    auto label = receiveString();
    auto vP = receiveArray<float,2>();
    float* v;
    bool r;
    {
    r = ImGui::DragFloat2(label, vP);
v = vP;;
    sendArray<float,2>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x0000003e:
  {
    FFFI_FUNCTION_INVOCATION("DragFloat2V")
    auto label = receiveString();
    auto vP = receiveArray<float,2>();
    auto v_speed = receiveValue<float>();
    auto v_min = receiveValue<float>();
    auto v_max = receiveValue<float>();
    auto format = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    float* v;
    bool r;
    {
    r = ImGui::DragFloat2(label, vP, v_speed, v_min, v_max, format, flags);
v = vP;;
    sendArray<float,2>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x0000003f:
  {
    FFFI_FUNCTION_INVOCATION("DragFloat3")
    auto label = receiveString();
    auto vP = receiveArray<float,3>();
    float* v;
    bool r;
    {
    r = ImGui::DragFloat3(label, vP);
v = vP;;
    sendArray<float,2>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000040:
  {
    FFFI_FUNCTION_INVOCATION("DragFloat3V")
    auto label = receiveString();
    auto vP = receiveArray<float,3>();
    auto v_speed = receiveValue<float>();
    auto v_min = receiveValue<float>();
    auto v_max = receiveValue<float>();
    auto format = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    float* v;
    bool r;
    {
    r = ImGui::DragFloat3(label, vP, v_speed, v_min, v_max, format, flags);
v = vP;;
    sendArray<float,4>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000041:
  {
    FFFI_FUNCTION_INVOCATION("DragFloat4")
    auto label = receiveString();
    auto vP = receiveArray<float,4>();
    float* v;
    bool r;
    {
    r = ImGui::DragFloat4(label, vP);
v = vP;;
    sendArray<float,4>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000042:
  {
    FFFI_FUNCTION_INVOCATION("DragFloat4V")
    auto label = receiveString();
    auto vP = receiveArray<float,4>();
    auto v_speed = receiveValue<float>();
    auto v_min = receiveValue<float>();
    auto v_max = receiveValue<float>();
    auto format = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    float* v;
    bool r;
    {
    r = ImGui::DragFloat4(label, vP, v_speed, v_min, v_max, format, flags);
v = vP;;
    sendArray<float,4>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000043:
  {
    FFFI_FUNCTION_INVOCATION("DragInt2")
    auto label = receiveString();
    auto vP = receiveArray<int,2>();
    int* v;
    bool r;
    {
    r = ImGui::DragInt2(label, vP);
v = vP;;
    sendArray<int,2>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000044:
  {
    FFFI_FUNCTION_INVOCATION("DragInt2V")
    auto label = receiveString();
    auto vP = receiveArray<int,2>();
    auto v_speed = receiveValue<float>();
    auto v_min = receiveValueSignMagnitude<int>();
    auto v_max = receiveValueSignMagnitude<int>();
    auto format = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    int* v;
    bool r;
    {
    r = ImGui::DragInt2(label, vP, v_speed, v_min, v_max, format, flags);
v = vP;;
    sendArray<int,2>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000045:
  {
    FFFI_FUNCTION_INVOCATION("DragInt3")
    auto label = receiveString();
    auto vP = receiveArray<int,3>();
    int* v;
    bool r;
    {
    r = ImGui::DragInt3(label, vP);
v = vP;;
    sendArray<int,2>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000046:
  {
    FFFI_FUNCTION_INVOCATION("DragInt3V")
    auto label = receiveString();
    auto vP = receiveArray<int,3>();
    auto v_speed = receiveValue<float>();
    auto v_min = receiveValueSignMagnitude<int>();
    auto v_max = receiveValueSignMagnitude<int>();
    auto format = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    int* v;
    bool r;
    {
    r = ImGui::DragInt3(label, vP, v_speed, v_min, v_max, format, flags);
v = vP;;
    sendArray<int,4>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000047:
  {
    FFFI_FUNCTION_INVOCATION("DragInt4")
    auto label = receiveString();
    auto vP = receiveArray<int,4>();
    int* v;
    bool r;
    {
    r = ImGui::DragInt4(label, vP);
v = vP;;
    sendArray<int,4>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000048:
  {
    FFFI_FUNCTION_INVOCATION("DragInt4V")
    auto label = receiveString();
    auto vP = receiveArray<int,4>();
    auto v_speed = receiveValue<float>();
    auto v_min = receiveValueSignMagnitude<int>();
    auto v_max = receiveValueSignMagnitude<int>();
    auto format = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    int* v;
    bool r;
    {
    r = ImGui::DragInt4(label, vP, v_speed, v_min, v_max, format, flags);
v = vP;;
    sendArray<int,4>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000049:
  {
    FFFI_FUNCTION_INVOCATION("SliderFloat")
    auto label = receiveString();
    auto vP = receiveValue<float>();
    auto v_min = receiveValue<float>();
    auto v_max = receiveValue<float>();
    float v;
    bool r;
    {
    r = ImGui::SliderFloat(label, &vP, v_min, v_max);
v = vP;;
    sendValue<float>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x0000004a:
  {
    FFFI_FUNCTION_INVOCATION("SliderFloatV")
    auto label = receiveString();
    auto vP = receiveValue<float>();
    auto v_min = receiveValue<float>();
    auto v_max = receiveValue<float>();
    auto format = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    float v;
    bool r;
    {
    r = ImGui::SliderFloat(label, &vP,  v_min, v_max, format, flags);
v = vP;;
    sendValue<float>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x0000004b:
  {
    FFFI_FUNCTION_INVOCATION("SliderFloat2")
    auto label = receiveString();
    auto vP = receiveArray<float,2>();
    auto v_min = receiveValue<float>();
    auto v_max = receiveValue<float>();
    float* v;
    bool r;
    {
    r = ImGui::SliderFloat2(label, vP, v_min, v_max);
v = vP;;
    sendArray<float,2>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x0000004c:
  {
    FFFI_FUNCTION_INVOCATION("SliderFloat2V")
    auto label = receiveString();
    auto vP = receiveArray<float,2>();
    auto v_min = receiveValue<float>();
    auto v_max = receiveValue<float>();
    auto format = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    float* v;
    bool r;
    {
    r = ImGui::SliderFloat2(label, vP,  v_min, v_max, format, flags);
v = vP;;
    sendArray<float,2>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x0000004d:
  {
    FFFI_FUNCTION_INVOCATION("SliderFloat3")
    auto label = receiveString();
    auto vP = receiveArray<float,3>();
    auto v_min = receiveValue<float>();
    auto v_max = receiveValue<float>();
    float* v;
    bool r;
    {
    r = ImGui::SliderFloat3(label, vP, v_min, v_max);
v = vP;;
    sendArray<float,2>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x0000004e:
  {
    FFFI_FUNCTION_INVOCATION("SliderFloat3V")
    auto label = receiveString();
    auto vP = receiveArray<float,3>();
    auto v_min = receiveValue<float>();
    auto v_max = receiveValue<float>();
    auto format = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    float* v;
    bool r;
    {
    r = ImGui::SliderFloat3(label, vP,  v_min, v_max, format, flags);
v = vP;;
    sendArray<float,4>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x0000004f:
  {
    FFFI_FUNCTION_INVOCATION("SliderFloat4")
    auto label = receiveString();
    auto vP = receiveArray<float,4>();
    auto v_min = receiveValue<float>();
    auto v_max = receiveValue<float>();
    float* v;
    bool r;
    {
    r = ImGui::SliderFloat4(label, vP, v_min, v_max);
v = vP;;
    sendArray<float,4>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000050:
  {
    FFFI_FUNCTION_INVOCATION("SliderFloat4V")
    auto label = receiveString();
    auto vP = receiveArray<float,4>();
    auto v_min = receiveValue<float>();
    auto v_max = receiveValue<float>();
    auto format = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    float* v;
    bool r;
    {
    r = ImGui::SliderFloat4(label, vP,  v_min, v_max, format, flags);
v = vP;;
    sendArray<float,4>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000051:
  {
    FFFI_FUNCTION_INVOCATION("SliderInt2")
    auto label = receiveString();
    auto vP = receiveArray<int,2>();
    auto v_min = receiveValueSignMagnitude<int>();
    auto v_max = receiveValueSignMagnitude<int>();
    int* v;
    bool r;
    {
    r = ImGui::SliderInt2(label, vP, v_min, v_max);
v = vP;;
    sendArray<int,2>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000052:
  {
    FFFI_FUNCTION_INVOCATION("SliderInt2V")
    auto label = receiveString();
    auto vP = receiveArray<int,2>();
    auto v_min = receiveValueSignMagnitude<int>();
    auto v_max = receiveValueSignMagnitude<int>();
    auto format = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    int* v;
    bool r;
    {
    r = ImGui::SliderInt2(label, vP,  v_min, v_max, format, flags);
v = vP;;
    sendArray<int,2>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000053:
  {
    FFFI_FUNCTION_INVOCATION("SliderInt3")
    auto label = receiveString();
    auto vP = receiveArray<int,3>();
    auto v_min = receiveValueSignMagnitude<int>();
    auto v_max = receiveValueSignMagnitude<int>();
    int* v;
    bool r;
    {
    r = ImGui::SliderInt3(label, vP, v_min, v_max);
v = vP;;
    sendArray<int,2>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000054:
  {
    FFFI_FUNCTION_INVOCATION("SliderInt3V")
    auto label = receiveString();
    auto vP = receiveArray<int,3>();
    auto v_min = receiveValueSignMagnitude<int>();
    auto v_max = receiveValueSignMagnitude<int>();
    auto format = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    int* v;
    bool r;
    {
    r = ImGui::SliderInt3(label, vP,  v_min, v_max, format, flags);
v = vP;;
    sendArray<int,4>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000055:
  {
    FFFI_FUNCTION_INVOCATION("SliderInt4")
    auto label = receiveString();
    auto vP = receiveArray<int,4>();
    auto v_min = receiveValueSignMagnitude<int>();
    auto v_max = receiveValueSignMagnitude<int>();
    int* v;
    bool r;
    {
    r = ImGui::SliderInt4(label, vP, v_min, v_max);
v = vP;;
    sendArray<int,4>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000056:
  {
    FFFI_FUNCTION_INVOCATION("SliderInt4V")
    auto label = receiveString();
    auto vP = receiveArray<int,4>();
    auto v_min = receiveValueSignMagnitude<int>();
    auto v_max = receiveValueSignMagnitude<int>();
    auto format = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    int* v;
    bool r;
    {
    r = ImGui::SliderInt4(label, vP,  v_min, v_max, format, flags);
v = vP;;
    sendArray<int,4>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000057:
  {
    FFFI_FUNCTION_INVOCATION("PushClipRect")
    auto foreignptr = receiveValue<uintptr_t>();
    auto clip_rect_min = receiveArray<float,2>();
    auto clip_rect_max = receiveArray<float,2>();
    {
    ((ImDrawList*)foreignptr)->PushClipRect(clip_rect_min, clip_rect_max);
  }
  }
  break;
case 0x00000058:
  {
    FFFI_FUNCTION_INVOCATION("PushClipRectV")
    auto foreignptr = receiveValue<uintptr_t>();
    auto clip_rect_min = receiveArray<float,2>();
    auto clip_rect_max = receiveArray<float,2>();
    auto intersect_with_current_clip_rect = receiveValue<bool>();
    {
    ((ImDrawList*)foreignptr)->PushClipRect(clip_rect_min, clip_rect_max, intersect_with_current_clip_rect);
  }
  }
  break;
case 0x00000059:
  {
    FFFI_FUNCTION_INVOCATION("PushClipRectFullScreen")
    auto foreignptr = receiveValue<uintptr_t>();
    {
    ((ImDrawList*)foreignptr)->PushClipRectFullScreen();
  }
  }
  break;
case 0x0000005a:
  {
    FFFI_FUNCTION_INVOCATION("PopClipRect")
    auto foreignptr = receiveValue<uintptr_t>();
    {
    ((ImDrawList*)foreignptr)->PopClipRect();
  }
  }
  break;
case 0x0000005b:
  {
    FFFI_FUNCTION_INVOCATION("PushTextureID")
    auto foreignptr = receiveValue<uintptr_t>();
    auto texture_id = receiveValue<uintptr_t>();
    {
    ((ImDrawList*)foreignptr)->PushTextureID(ImTextureID(texture_id));
  }
  }
  break;
case 0x0000005c:
  {
    FFFI_FUNCTION_INVOCATION("PopTextureID")
    auto foreignptr = receiveValue<uintptr_t>();
    {
    ((ImDrawList*)foreignptr)->PopTextureID();
  }
  }
  break;
case 0x0000005d:
  {
    FFFI_FUNCTION_INVOCATION("AddLine")
    auto foreignptr = receiveValue<uintptr_t>();
    auto p1 = receiveArray<float,2>();
    auto p2 = receiveArray<float,2>();
    auto col = receiveValue<uint32_t>();
    {
    ((ImDrawList*)foreignptr)->AddLine(p1, p2, col);
  }
  }
  break;
case 0x0000005e:
  {
    FFFI_FUNCTION_INVOCATION("AddLineV")
    auto foreignptr = receiveValue<uintptr_t>();
    auto p1 = receiveArray<float,2>();
    auto p2 = receiveArray<float,2>();
    auto col = receiveValue<uint32_t>();
    auto thickness = receiveValue<float>();
    {
    ((ImDrawList*)foreignptr)->AddLine(p1, p2, col, thickness);
  }
  }
  break;
case 0x0000005f:
  {
    FFFI_FUNCTION_INVOCATION("AddRect")
    auto foreignptr = receiveValue<uintptr_t>();
    auto p_min = receiveArray<float,2>();
    auto p_max = receiveArray<float,2>();
    auto col = receiveValue<uint32_t>();
    {
    ((ImDrawList*)foreignptr)->AddRect(p_min, p_max, col);
  }
  }
  break;
case 0x00000060:
  {
    FFFI_FUNCTION_INVOCATION("AddRectV")
    auto foreignptr = receiveValue<uintptr_t>();
    auto p_min = receiveArray<float,2>();
    auto p_max = receiveArray<float,2>();
    auto col = receiveValue<uint32_t>();
    auto rounding = receiveValue<float>();
    auto flags = receiveValueSignMagnitude<int>();
    auto thickness = receiveValue<float>();
    {
    ((ImDrawList*)foreignptr)->AddRect(p_min, p_max, col, rounding, flags, thickness);
  }
  }
  break;
case 0x00000061:
  {
    FFFI_FUNCTION_INVOCATION("AddRectFilled")
    auto foreignptr = receiveValue<uintptr_t>();
    auto p_min = receiveArray<float,2>();
    auto p_max = receiveArray<float,2>();
    auto col = receiveValue<uint32_t>();
    {
    ((ImDrawList*)foreignptr)->AddRectFilled(p_min, p_max, col);
  }
  }
  break;
case 0x00000062:
  {
    FFFI_FUNCTION_INVOCATION("AddRectFilledV")
    auto foreignptr = receiveValue<uintptr_t>();
    auto p_min = receiveArray<float,2>();
    auto p_max = receiveArray<float,2>();
    auto col = receiveValue<uint32_t>();
    auto rounding = receiveValue<float>();
    auto flags = receiveValueSignMagnitude<int>();
    {
    ((ImDrawList*)foreignptr)->AddRectFilled(p_min, p_max, col, rounding, flags);
  }
  }
  break;
case 0x00000063:
  {
    FFFI_FUNCTION_INVOCATION("AddRectFilledMultiColor")
    auto foreignptr = receiveValue<uintptr_t>();
    auto p_min = receiveArray<float,2>();
    auto p_max = receiveArray<float,2>();
    auto col_upr_left = receiveValue<uint32_t>();
    auto col_upr_right = receiveValue<uint32_t>();
    auto col_bot_right = receiveValue<uint32_t>();
    auto col_bot_left = receiveValue<uint32_t>();
    {
    ((ImDrawList*)foreignptr)->AddRectFilledMultiColor(p_min, p_max, col_upr_left, col_upr_right, col_bot_right, col_bot_left);
  }
  }
  break;
case 0x00000064:
  {
    FFFI_FUNCTION_INVOCATION("AddQuad")
    auto foreignptr = receiveValue<uintptr_t>();
    auto p1 = receiveArray<float,2>();
    auto p2 = receiveArray<float,2>();
    auto p3 = receiveArray<float,2>();
    auto p4 = receiveArray<float,2>();
    auto col = receiveValue<uint32_t>();
    {
    ((ImDrawList*)foreignptr)->AddQuad(p1, p2, p3, p4, col);
  }
  }
  break;
case 0x00000065:
  {
    FFFI_FUNCTION_INVOCATION("AddQuadV")
    auto foreignptr = receiveValue<uintptr_t>();
    auto p1 = receiveArray<float,2>();
    auto p2 = receiveArray<float,2>();
    auto p3 = receiveArray<float,2>();
    auto p4 = receiveArray<float,2>();
    auto col = receiveValue<uint32_t>();
    auto thickness = receiveValue<float>();
    {
    ((ImDrawList*)foreignptr)->AddQuad(p1, p2, p3, p4, col, thickness);
  }
  }
  break;
case 0x00000066:
  {
    FFFI_FUNCTION_INVOCATION("AddQuadFilled")
    auto foreignptr = receiveValue<uintptr_t>();
    auto p1 = receiveArray<float,2>();
    auto p2 = receiveArray<float,2>();
    auto p3 = receiveArray<float,2>();
    auto p4 = receiveArray<float,2>();
    auto col = receiveValue<uint32_t>();
    {
    ((ImDrawList*)foreignptr)->AddQuadFilled(p1, p2, p3, p4, col);
  }
  }
  break;
case 0x00000067:
  {
    FFFI_FUNCTION_INVOCATION("AddTriangle")
    auto foreignptr = receiveValue<uintptr_t>();
    auto p1 = receiveArray<float,2>();
    auto p2 = receiveArray<float,2>();
    auto p3 = receiveArray<float,2>();
    auto col = receiveValue<uint32_t>();
    {
    ((ImDrawList*)foreignptr)->AddTriangle(p1, p2, p3, col);
  }
  }
  break;
case 0x00000068:
  {
    FFFI_FUNCTION_INVOCATION("AddTriangleV")
    auto foreignptr = receiveValue<uintptr_t>();
    auto p1 = receiveArray<float,2>();
    auto p2 = receiveArray<float,2>();
    auto p3 = receiveArray<float,2>();
    auto col = receiveValue<uint32_t>();
    auto thickness = receiveValue<float>();
    {
    ((ImDrawList*)foreignptr)->AddTriangle(p1, p2, p3, col, thickness);
  }
  }
  break;
case 0x00000069:
  {
    FFFI_FUNCTION_INVOCATION("AddTriangleFilled")
    auto foreignptr = receiveValue<uintptr_t>();
    auto p1 = receiveArray<float,2>();
    auto p2 = receiveArray<float,2>();
    auto p3 = receiveArray<float,2>();
    auto col = receiveValue<uint32_t>();
    {
    ((ImDrawList*)foreignptr)->AddTriangleFilled(p1, p2, p3, col);
  }
  }
  break;
case 0x0000006a:
  {
    FFFI_FUNCTION_INVOCATION("AddCircle")
    auto foreignptr = receiveValue<uintptr_t>();
    auto center = receiveArray<float,2>();
    auto radius = receiveValue<float>();
    auto col = receiveValue<uint32_t>();
    {
    ((ImDrawList*)foreignptr)->AddCircle(center, radius, col);
  }
  }
  break;
case 0x0000006b:
  {
    FFFI_FUNCTION_INVOCATION("AddCircleV")
    auto foreignptr = receiveValue<uintptr_t>();
    auto center = receiveArray<float,2>();
    auto radius = receiveValue<float>();
    auto col = receiveValue<uint32_t>();
    auto num_segments = receiveValueSignMagnitude<int>();
    auto thickness = receiveValue<float>();
    {
    ((ImDrawList*)foreignptr)->AddCircle(center, radius, col, num_segments, thickness);
  }
  }
  break;
case 0x0000006c:
  {
    FFFI_FUNCTION_INVOCATION("AddCircleFilled")
    auto foreignptr = receiveValue<uintptr_t>();
    auto center = receiveArray<float,2>();
    auto radius = receiveValue<float>();
    auto col = receiveValue<uint32_t>();
    {
    ((ImDrawList*)foreignptr)->AddCircleFilled(center, radius, col);
  }
  }
  break;
case 0x0000006d:
  {
    FFFI_FUNCTION_INVOCATION("AddCircleFilledV")
    auto foreignptr = receiveValue<uintptr_t>();
    auto center = receiveArray<float,2>();
    auto radius = receiveValue<float>();
    auto col = receiveValue<uint32_t>();
    auto num_segments = receiveValueSignMagnitude<int>();
    {
    ((ImDrawList*)foreignptr)->AddCircleFilled(center, radius, col, num_segments);
  }
  }
  break;
case 0x0000006e:
  {
    FFFI_FUNCTION_INVOCATION("AddNgon")
    auto foreignptr = receiveValue<uintptr_t>();
    auto center = receiveArray<float,2>();
    auto radius = receiveValue<float>();
    auto col = receiveValue<uint32_t>();
    auto num_segments = receiveValueSignMagnitude<int>();
    {
    ((ImDrawList*)foreignptr)->AddNgon(center, radius, col, num_segments);
  }
  }
  break;
case 0x0000006f:
  {
    FFFI_FUNCTION_INVOCATION("AddNgonV")
    auto foreignptr = receiveValue<uintptr_t>();
    auto center = receiveArray<float,2>();
    auto radius = receiveValue<float>();
    auto col = receiveValue<uint32_t>();
    auto num_segments = receiveValueSignMagnitude<int>();
    auto thickness = receiveValue<float>();
    {
    ((ImDrawList*)foreignptr)->AddNgon(center, radius, col, num_segments, thickness);
  }
  }
  break;
case 0x00000070:
  {
    FFFI_FUNCTION_INVOCATION("AddNgonFilled")
    auto foreignptr = receiveValue<uintptr_t>();
    auto center = receiveArray<float,2>();
    auto radius = receiveValue<float>();
    auto col = receiveValue<uint32_t>();
    auto num_segments = receiveValueSignMagnitude<int>();
    {
    ((ImDrawList*)foreignptr)->AddNgonFilled(center, radius, col, num_segments);
  }
  }
  break;
case 0x00000071:
  {
    FFFI_FUNCTION_INVOCATION("AddEllipse")
    auto foreignptr = receiveValue<uintptr_t>();
    auto center = receiveArray<float,2>();
    auto radius = receiveArray<float,2>();
    auto col = receiveValue<uint32_t>();
    {
    ((ImDrawList*)foreignptr)->AddEllipse(center, radius, col);
  }
  }
  break;
case 0x00000072:
  {
    FFFI_FUNCTION_INVOCATION("AddEllipseV")
    auto foreignptr = receiveValue<uintptr_t>();
    auto center = receiveArray<float,2>();
    auto radius = receiveArray<float,2>();
    auto col = receiveValue<uint32_t>();
    auto rot = receiveValue<float>();
    auto num_segments = receiveValueSignMagnitude<int>();
    auto thickness = receiveValue<float>();
    {
    ((ImDrawList*)foreignptr)->AddEllipse(center, radius, col, rot, num_segments, thickness);
  }
  }
  break;
case 0x00000073:
  {
    FFFI_FUNCTION_INVOCATION("AddEllipseFilled")
    auto foreignptr = receiveValue<uintptr_t>();
    auto center = receiveArray<float,2>();
    auto radius = receiveArray<float,2>();
    auto col = receiveValue<uint32_t>();
    {
    ((ImDrawList*)foreignptr)->AddEllipseFilled(center, radius, col);
  }
  }
  break;
case 0x00000074:
  {
    FFFI_FUNCTION_INVOCATION("AddEllipseFilledV")
    auto foreignptr = receiveValue<uintptr_t>();
    auto center = receiveArray<float,2>();
    auto radius = receiveArray<float,2>();
    auto col = receiveValue<uint32_t>();
    auto rot = receiveValue<float>();
    auto num_segments = receiveValueSignMagnitude<int>();
    {
    ((ImDrawList*)foreignptr)->AddEllipseFilled(center, radius, col, rot, num_segments);
  }
  }
  break;
case 0x00000075:
  {
    FFFI_FUNCTION_INVOCATION("AddBezierCubic")
    auto foreignptr = receiveValue<uintptr_t>();
    auto p1 = receiveArray<float,2>();
    auto p2 = receiveArray<float,2>();
    auto p3 = receiveArray<float,2>();
    auto p4 = receiveArray<float,2>();
    auto col = receiveValue<uint32_t>();
    auto thickness = receiveValue<float>();
    {
    ((ImDrawList*)foreignptr)->AddBezierCubic(p1, p2, p3, p4, col, thickness);
  }
  }
  break;
case 0x00000076:
  {
    FFFI_FUNCTION_INVOCATION("AddBezierCubicV")
    auto foreignptr = receiveValue<uintptr_t>();
    auto p1 = receiveArray<float,2>();
    auto p2 = receiveArray<float,2>();
    auto p3 = receiveArray<float,2>();
    auto p4 = receiveArray<float,2>();
    auto col = receiveValue<uint32_t>();
    auto thickness = receiveValue<float>();
    auto num_segments = receiveValueSignMagnitude<int>();
    {
    ((ImDrawList*)foreignptr)->AddBezierCubic(p1, p2, p3, p4, col, thickness, num_segments);
  }
  }
  break;
case 0x00000077:
  {
    FFFI_FUNCTION_INVOCATION("AddBezierQuadratic")
    auto foreignptr = receiveValue<uintptr_t>();
    auto p1 = receiveArray<float,2>();
    auto p2 = receiveArray<float,2>();
    auto p3 = receiveArray<float,2>();
    auto col = receiveValue<uint32_t>();
    auto thickness = receiveValue<float>();
    {
    ((ImDrawList*)foreignptr)->AddBezierQuadratic(p1, p2, p3, col, thickness);
  }
  }
  break;
case 0x00000078:
  {
    FFFI_FUNCTION_INVOCATION("AddBezierQuadraticV")
    auto foreignptr = receiveValue<uintptr_t>();
    auto p1 = receiveArray<float,2>();
    auto p2 = receiveArray<float,2>();
    auto p3 = receiveArray<float,2>();
    auto col = receiveValue<uint32_t>();
    auto thickness = receiveValue<float>();
    auto num_segments = receiveValueSignMagnitude<int>();
    {
    ((ImDrawList*)foreignptr)->AddBezierQuadratic(p1, p2, p3, col, thickness, num_segments);
  }
  }
  break;
case 0x00000079:
  {
    FFFI_FUNCTION_INVOCATION("AddImage")
    auto foreignptr = receiveValue<uintptr_t>();
    auto user_texture_id = receiveValue<uintptr_t>();
    auto p_min = receiveArray<float,2>();
    auto p_max = receiveArray<float,2>();
    {
    ((ImDrawList*)foreignptr)->AddImage(ImTextureID(user_texture_id), p_min, p_max);
  }
  }
  break;
case 0x0000007a:
  {
    FFFI_FUNCTION_INVOCATION("AddImageV")
    auto foreignptr = receiveValue<uintptr_t>();
    auto user_texture_id = receiveValue<uintptr_t>();
    auto p_min = receiveArray<float,2>();
    auto p_max = receiveArray<float,2>();
    auto uv_min = receiveArray<float,2>();
    auto uv_max = receiveArray<float,2>();
    auto col = receiveValue<uint32_t>();
    {
    ((ImDrawList*)foreignptr)->AddImage(ImTextureID(user_texture_id), p_min, p_max, uv_min, uv_max, col);
  }
  }
  break;
case 0x0000007b:
  {
    FFFI_FUNCTION_INVOCATION("AddImageQuad")
    auto foreignptr = receiveValue<uintptr_t>();
    auto user_texture_id = receiveValue<uintptr_t>();
    auto p1 = receiveArray<float,2>();
    auto p2 = receiveArray<float,2>();
    auto p3 = receiveArray<float,2>();
    auto p4 = receiveArray<float,2>();
    {
    ((ImDrawList*)foreignptr)->AddImageQuad(ImTextureID(user_texture_id), p1, p2, p3, p4);
  }
  }
  break;
case 0x0000007c:
  {
    FFFI_FUNCTION_INVOCATION("AddImageQuadV")
    auto foreignptr = receiveValue<uintptr_t>();
    auto user_texture_id = receiveValue<uintptr_t>();
    auto p1 = receiveArray<float,2>();
    auto p2 = receiveArray<float,2>();
    auto p3 = receiveArray<float,2>();
    auto p4 = receiveArray<float,2>();
    auto uv1 = receiveArray<float,2>();
    auto uv2 = receiveArray<float,2>();
    auto uv3 = receiveArray<float,2>();
    auto uv4 = receiveArray<float,2>();
    auto col = receiveValue<uint32_t>();
    {
    ((ImDrawList*)foreignptr)->AddImageQuad(ImTextureID(user_texture_id), p1, p2, p3, p4, uv1, uv2, uv3, uv4, col);
  }
  }
  break;
case 0x0000007d:
  {
    FFFI_FUNCTION_INVOCATION("AddImageRounded")
    auto foreignptr = receiveValue<uintptr_t>();
    auto user_texture_id = receiveValue<uintptr_t>();
    auto p_min = receiveArray<float,2>();
    auto p_max = receiveArray<float,2>();
    auto uv_min = receiveArray<float,2>();
    auto uv_max = receiveArray<float,2>();
    auto col = receiveValue<uint32_t>();
    auto rounding = receiveValue<float>();
    {
    ((ImDrawList*)foreignptr)->AddImageRounded(ImTextureID(user_texture_id), p_min, p_max, uv_min, uv_max, col, rounding);
  }
  }
  break;
case 0x0000007e:
  {
    FFFI_FUNCTION_INVOCATION("AddImageRoundedV")
    auto foreignptr = receiveValue<uintptr_t>();
    auto user_texture_id = receiveValue<uintptr_t>();
    auto p_min = receiveArray<float,2>();
    auto p_max = receiveArray<float,2>();
    auto uv_min = receiveArray<float,2>();
    auto uv_max = receiveArray<float,2>();
    auto col = receiveValue<uint32_t>();
    auto rounding = receiveValue<float>();
    auto flags = receiveValueSignMagnitude<int>();
    {
    ((ImDrawList*)foreignptr)->AddImageRounded(ImTextureID(user_texture_id), p_min, p_max, uv_min, uv_max, col, rounding, flags);
  }
  }
  break;
case 0x0000007f:
  {
    FFFI_FUNCTION_INVOCATION("PathArcTo")
    auto foreignptr = receiveValue<uintptr_t>();
    auto center = receiveArray<float,2>();
    auto radius = receiveValue<float>();
    auto a_min = receiveValue<float>();
    auto a_max = receiveValue<float>();
    {
    ((ImDrawList*)foreignptr)->PathArcTo(center, radius, a_min, a_max);
  }
  }
  break;
case 0x00000080:
  {
    FFFI_FUNCTION_INVOCATION("PathArcToV")
    auto foreignptr = receiveValue<uintptr_t>();
    auto center = receiveArray<float,2>();
    auto radius = receiveValue<float>();
    auto a_min = receiveValue<float>();
    auto a_max = receiveValue<float>();
    auto num_segments = receiveValueSignMagnitude<int>();
    {
    ((ImDrawList*)foreignptr)->PathArcTo(center, radius, a_min, a_max, num_segments);
  }
  }
  break;
case 0x00000081:
  {
    FFFI_FUNCTION_INVOCATION("PathArcToFast")
    auto foreignptr = receiveValue<uintptr_t>();
    auto center = receiveArray<float,2>();
    auto radius = receiveValue<float>();
    auto a_min_of_12 = receiveValueSignMagnitude<int>();
    auto a_max_of_12 = receiveValueSignMagnitude<int>();
    {
    ((ImDrawList*)foreignptr)->PathArcToFast(center, radius, a_min_of_12, a_max_of_12);
  }
  }
  break;
case 0x00000082:
  {
    FFFI_FUNCTION_INVOCATION("PathEllipticalArcTo")
    auto foreignptr = receiveValue<uintptr_t>();
    auto center = receiveArray<float,2>();
    auto radius = receiveArray<float,2>();
    auto rot = receiveValue<float>();
    auto a_min = receiveValue<float>();
    auto a_max = receiveValue<float>();
    {
    ((ImDrawList*)foreignptr)->PathEllipticalArcTo(center, radius, rot, a_min, a_max);
  }
  }
  break;
case 0x00000083:
  {
    FFFI_FUNCTION_INVOCATION("PathEllipticalArcToV")
    auto foreignptr = receiveValue<uintptr_t>();
    auto center = receiveArray<float,2>();
    auto radius = receiveArray<float,2>();
    auto rot = receiveValue<float>();
    auto a_min = receiveValue<float>();
    auto a_max = receiveValue<float>();
    auto num_segments = receiveValueSignMagnitude<int>();
    {
    ((ImDrawList*)foreignptr)->PathEllipticalArcTo(center, radius, rot, a_min, a_max, num_segments);
  }
  }
  break;
case 0x00000084:
  {
    FFFI_FUNCTION_INVOCATION("PathBezierCubicCurveTo")
    auto foreignptr = receiveValue<uintptr_t>();
    auto p2 = receiveArray<float,2>();
    auto p3 = receiveArray<float,2>();
    auto p4 = receiveArray<float,2>();
    {
    ((ImDrawList*)foreignptr)->PathBezierCubicCurveTo(p2, p3, p4);
  }
  }
  break;
case 0x00000085:
  {
    FFFI_FUNCTION_INVOCATION("PathBezierCubicCurveToV")
    auto foreignptr = receiveValue<uintptr_t>();
    auto p2 = receiveArray<float,2>();
    auto p3 = receiveArray<float,2>();
    auto p4 = receiveArray<float,2>();
    auto num_segments = receiveValueSignMagnitude<int>();
    {
    ((ImDrawList*)foreignptr)->PathBezierCubicCurveTo(p2, p3, p4, num_segments);
  }
  }
  break;
case 0x00000086:
  {
    FFFI_FUNCTION_INVOCATION("PathBezierQuadraticCurveTo")
    auto foreignptr = receiveValue<uintptr_t>();
    auto p2 = receiveArray<float,2>();
    auto p3 = receiveArray<float,2>();
    {
    ((ImDrawList*)foreignptr)->PathBezierQuadraticCurveTo(p2, p3);
  }
  }
  break;
case 0x00000087:
  {
    FFFI_FUNCTION_INVOCATION("PathBezierQuadraticCurveToV")
    auto foreignptr = receiveValue<uintptr_t>();
    auto p2 = receiveArray<float,2>();
    auto p3 = receiveArray<float,2>();
    auto num_segments = receiveValueSignMagnitude<int>();
    {
    ((ImDrawList*)foreignptr)->PathBezierQuadraticCurveTo(p2, p3, num_segments);
  }
  }
  break;
case 0x00000088:
  {
    FFFI_FUNCTION_INVOCATION("PathRect")
    auto foreignptr = receiveValue<uintptr_t>();
    auto rect_min = receiveArray<float,2>();
    auto rect_max = receiveArray<float,2>();
    {
    ((ImDrawList*)foreignptr)->PathRect(rect_min, rect_max);
  }
  }
  break;
case 0x00000089:
  {
    FFFI_FUNCTION_INVOCATION("PathRectV")
    auto foreignptr = receiveValue<uintptr_t>();
    auto rect_min = receiveArray<float,2>();
    auto rect_max = receiveArray<float,2>();
    auto rounding = receiveValue<float>();
    auto flags = receiveValueSignMagnitude<int>();
    {
    ((ImDrawList*)foreignptr)->PathRect(rect_min, rect_max, rounding, flags);
  }
  }
  break;
case 0x0000008a:
  {
    FFFI_FUNCTION_INVOCATION("AddDrawCmd")
    auto foreignptr = receiveValue<uintptr_t>();
    {
    ((ImDrawList*)foreignptr)->AddDrawCmd();
  }
  }
  break;
case 0x0000008b:
  {
    FFFI_FUNCTION_INVOCATION("CloneOutput")
    auto foreignptr = receiveValue<uintptr_t>();
    uintptr_t r;
    {
    auto r = ((ImDrawList*)foreignptr)->CloneOutput();
    sendValue(r);
    flushSend();
  }
  }
  break;
case 0x0000008c:
  {
    FFFI_FUNCTION_INVOCATION("PrimReserve")
    auto foreignptr = receiveValue<uintptr_t>();
    auto idx_count = receiveValueSignMagnitude<int>();
    auto vtx_count = receiveValueSignMagnitude<int>();
    {
    ((ImDrawList*)foreignptr)->PrimReserve(idx_count, vtx_count);
  }
  }
  break;
case 0x0000008d:
  {
    FFFI_FUNCTION_INVOCATION("PrimUnreserve")
    auto foreignptr = receiveValue<uintptr_t>();
    auto idx_count = receiveValueSignMagnitude<int>();
    auto vtx_count = receiveValueSignMagnitude<int>();
    {
    ((ImDrawList*)foreignptr)->PrimUnreserve(idx_count, vtx_count);
  }
  }
  break;
case 0x0000008e:
  {
    FFFI_FUNCTION_INVOCATION("PrimRect")
    auto foreignptr = receiveValue<uintptr_t>();
    auto a = receiveArray<float,2>();
    auto b = receiveArray<float,2>();
    auto col = receiveValue<uint32_t>();
    {
    ((ImDrawList*)foreignptr)->PrimRect(a, b, col);
  }
  }
  break;
case 0x0000008f:
  {
    FFFI_FUNCTION_INVOCATION("PrimRectUV")
    auto foreignptr = receiveValue<uintptr_t>();
    auto a = receiveArray<float,2>();
    auto b = receiveArray<float,2>();
    auto uv_a = receiveArray<float,2>();
    auto uv_b = receiveArray<float,2>();
    auto col = receiveValue<uint32_t>();
    {
    ((ImDrawList*)foreignptr)->PrimRectUV(a, b, uv_a, uv_b, col);
  }
  }
  break;
case 0x00000090:
  {
    FFFI_FUNCTION_INVOCATION("PrimQuadUV")
    auto foreignptr = receiveValue<uintptr_t>();
    auto a = receiveArray<float,2>();
    auto b = receiveArray<float,2>();
    auto c = receiveArray<float,2>();
    auto d = receiveArray<float,2>();
    auto uv_a = receiveArray<float,2>();
    auto uv_b = receiveArray<float,2>();
    auto uv_c = receiveArray<float,2>();
    auto uv_d = receiveArray<float,2>();
    auto col = receiveValue<uint32_t>();
    {
    ((ImDrawList*)foreignptr)->PrimQuadUV(a, b, c, d, uv_a, uv_b, uv_c, uv_d, col);
  }
  }
  break;
case 0x00000091:
  {
    FFFI_FUNCTION_INVOCATION("_ResetForNewFrame")
    auto foreignptr = receiveValue<uintptr_t>();
    {
    ((ImDrawList*)foreignptr)->_ResetForNewFrame();
  }
  }
  break;
case 0x00000092:
  {
    FFFI_FUNCTION_INVOCATION("_ClearFreeMemory")
    auto foreignptr = receiveValue<uintptr_t>();
    {
    ((ImDrawList*)foreignptr)->_ClearFreeMemory();
  }
  }
  break;
case 0x00000093:
  {
    FFFI_FUNCTION_INVOCATION("_PopUnusedDrawCmd")
    auto foreignptr = receiveValue<uintptr_t>();
    {
    ((ImDrawList*)foreignptr)->_PopUnusedDrawCmd();
  }
  }
  break;
case 0x00000094:
  {
    FFFI_FUNCTION_INVOCATION("_TryMergeDrawCmds")
    auto foreignptr = receiveValue<uintptr_t>();
    {
    ((ImDrawList*)foreignptr)->_TryMergeDrawCmds();
  }
  }
  break;
case 0x00000095:
  {
    FFFI_FUNCTION_INVOCATION("_OnChangedClipRect")
    auto foreignptr = receiveValue<uintptr_t>();
    {
    ((ImDrawList*)foreignptr)->_OnChangedClipRect();
  }
  }
  break;
case 0x00000096:
  {
    FFFI_FUNCTION_INVOCATION("_OnChangedTextureID")
    auto foreignptr = receiveValue<uintptr_t>();
    {
    ((ImDrawList*)foreignptr)->_OnChangedTextureID();
  }
  }
  break;
case 0x00000097:
  {
    FFFI_FUNCTION_INVOCATION("_OnChangedVtxOffset")
    auto foreignptr = receiveValue<uintptr_t>();
    {
    ((ImDrawList*)foreignptr)->_OnChangedVtxOffset();
  }
  }
  break;
case 0x00000098:
  {
    FFFI_FUNCTION_INVOCATION("_SetTextureID")
    auto foreignptr = receiveValue<uintptr_t>();
    auto texture_id = receiveValue<uintptr_t>();
    {
    ((ImDrawList*)foreignptr)->_SetTextureID(ImTextureID(texture_id));
  }
  }
  break;
case 0x00000099:
  {
    FFFI_FUNCTION_INVOCATION("_CalcCircleAutoSegmentCount")
    auto foreignptr = receiveValue<uintptr_t>();
    auto radius = receiveValue<float>();
    int r;
    {
    auto r = ((ImDrawList*)foreignptr)->_CalcCircleAutoSegmentCount(radius);
    sendValueSignMagnitude<int>(r);
    flushSend();
  }
  }
  break;
case 0x0000009a:
  {
    FFFI_FUNCTION_INVOCATION("_PathArcToFastEx")
    auto foreignptr = receiveValue<uintptr_t>();
    auto center = receiveArray<float,2>();
    auto radius = receiveValue<float>();
    auto a_min_sample = receiveValueSignMagnitude<int>();
    auto a_max_sample = receiveValueSignMagnitude<int>();
    auto a_step = receiveValueSignMagnitude<int>();
    {
    ((ImDrawList*)foreignptr)->_PathArcToFastEx(center, radius, a_min_sample, a_max_sample, a_step);
  }
  }
  break;
case 0x0000009b:
  {
    FFFI_FUNCTION_INVOCATION("_PathArcToN")
    auto foreignptr = receiveValue<uintptr_t>();
    auto center = receiveArray<float,2>();
    auto radius = receiveValue<float>();
    auto a_min = receiveValue<float>();
    auto a_max = receiveValue<float>();
    auto num_segments = receiveValueSignMagnitude<int>();
    {
    ((ImDrawList*)foreignptr)->_PathArcToN(center, radius, a_min, a_max, num_segments);
  }
  }
  break;
case 0x0000009c:
  {
    FFFI_FUNCTION_INVOCATION("PushIsParagraphText")
    auto val = receiveValue<uint8_t>();
    {
    ImGui::PushIsParagraphText(static_cast<ImZeroFB::IsParagraphText>(val));
  }
  }
  break;
case 0x0000009d:
  {
    FFFI_FUNCTION_INVOCATION("PopIsParagraphText")
    {
    ImGui::PopIsParagraphText();
  }
  }
  break;
case 0x0000009e:
  {
    FFFI_FUNCTION_INVOCATION("PushParagraphTextLayout")
    auto align = receiveValue<uint8_t>();
    auto dir = receiveValue<uint8_t>();
    {
    ImGui::PushParagraphTextLayout(static_cast<ImZeroFB::TextAlignFlags>(align),static_cast<ImZeroFB::TextDirection>(dir));
  }
  }
  break;
case 0x0000009f:
  {
    FFFI_FUNCTION_INVOCATION("PopParagraphTextLayout")
    {
    ImGui::PopParagraphTextLayout();
  }
  }
  break;
case 0x000000a0:
  {
    FFFI_FUNCTION_INVOCATION("DrawSerializedImZeroFB")
    auto ptr = receiveValue<uintptr_t>();
    auto buf = receiveSlice<uint8_t>();
    {
    ImGui::DrawSerializedImZeroFB(reinterpret_cast<ImDrawList*>(ptr),static_cast<const uint8_t*>(buf),getSliceLength(buf));
  }
  }
  break;
case 0x000000a1:
  {
    FFFI_FUNCTION_INVOCATION("PushTextMeasureMode")
    auto modeX = receiveValue<uint8_t>();
    auto modeY = receiveValue<uint8_t>();
    {
    ImGui::PushTextMeasureMode(static_cast<ImZeroFB::TextMeasureModeX>(modeX),static_cast<ImZeroFB::TextMeasureModeY>(modeY));
  }
  }
  break;
case 0x000000a2:
  {
    FFFI_FUNCTION_INVOCATION("PopTextMeasureMode")
    {
    ImGui::PopTextMeasureMode();
  }
  }
  break;
case 0x000000a3:
  {
    FFFI_FUNCTION_INVOCATION("PlotFlameV")
    auto label = receiveString();
    auto starts = receiveSlice<float>();
    auto stops = receiveSlice<float>();
    auto levels = receiveSlice<uint8_t>();
    auto captions = receiveStrings();
    auto overlayText = receiveString();
    auto scaleMin = receiveValue<float>();
    auto scaleMax = receiveValue<float>();
    auto size = receiveArray<float,2>();
    {
    
    auto n = std::min(std::min(std::min(getSliceLength(starts),getSliceLength(stops)),getSliceLength(levels)),getSliceLength(captions));
    flameGraphData d;
    d.starts = starts;
    d.ends = stops;
    d.levels = levels;
    d.captions = (const char**)captions;
	ImGuiWidgetFlameGraph::PlotFlame(label,flameGraphValueGetter,&d,(int)n,0,overlayText,scaleMin,scaleMax,size);
;
  }
  }
  break;
case 0x000000a4:
  {
    FFFI_FUNCTION_INVOCATION("PushFont")
    auto font = receiveValue<uintptr_t>();
    {
    ImGui::PushFont((ImFont*)font);;
  }
  }
  break;
case 0x000000a5:
  {
    FFFI_FUNCTION_INVOCATION("GetFont")
    uintptr_t font;
    {
    font = (uintptr_t)ImGui::GetFont();;
    sendValue(font);
    flushSend();
  }
  }
  break;
case 0x000000a6:
  {
    FFFI_FUNCTION_INVOCATION("GetFontTexID")
    uintptr_t tex;
    {
    tex = (uintptr_t)ImGui::GetIO().Fonts->TexID;
    sendValue(tex);
    flushSend();
  }
  }
  break;
case 0x000000a7:
  {
    FFFI_FUNCTION_INVOCATION("SetFontGlobalScale")
    auto scale = receiveValue<float>();
    {
    ImGui::SetWindowFontScale(scale);;
  }
  }
  break;
case 0x000000a8:
  {
    FFFI_FUNCTION_INVOCATION("GetFontGlobalScale")
    float scale;
    {
    scale = ImGui::GetIO().FontGlobalScale;;
    sendValue<float>(scale);
    flushSend();
  }
  }
  break;
case 0x000000a9:
  {
    FFFI_FUNCTION_INVOCATION("addFontFromMemoryTrueTypeFontV")
    auto name = receiveString();
    auto fontData = receiveSlice<uint8_t>();
    auto sizeInPixels = receiveValue<float>();
    auto glyphRanges = receiveSlice<ImWchar>();
    auto oversampleH = receiveValueSignMagnitude<int>();
    auto oversampleV = receiveValueSignMagnitude<int>();
    auto pixelSnapH = receiveValue<bool>();
    auto glyphOffset = receiveArray<float,2>();
    auto glyphMinAdvanceX = receiveValue<float>();
    auto glyphMaxAdvanceX = receiveValue<float>();
    auto mergeMode = receiveValue<bool>();
    auto fontBuilderFlags = receiveValue<unsigned>();
    auto rasterizerMultiply = receiveValue<float>();
    auto ellipsisChar = receiveValue<ImWchar>();
    uintptr_t font;
    {
    
  static_assert(sizeof(ImWchar) == 4, "code assumes IMGUI_USE_WCHAR32");
  auto cfg = ImFontConfig();

  // copy ttf font memory
  {
	  auto fontDataSize = getSliceLength(fontData);
	  cfg.FontData = ImGui::MemAlloc(fontDataSize);
	  memcpy(cfg.FontData,fontData,fontDataSize);

	  cfg.FontDataSize = fontDataSize;
	  cfg.FontDataOwnedByAtlas = true;
  }

  cfg.FontNo = 0;
  cfg.SizePixels = sizeInPixels;
  cfg.OversampleH = oversampleH;
  cfg.OversampleV = oversampleV;
  cfg.PixelSnapH = pixelSnapH;
  cfg.GlyphOffset = ImVec2(glyphOffset);
  cfg.GlyphMinAdvanceX = glyphMinAdvanceX;
  cfg.GlyphMaxAdvanceX = glyphMaxAdvanceX;
  cfg.MergeMode = mergeMode;
  cfg.FontBuilderFlags = fontBuilderFlags;
  cfg.RasterizerMultiply = rasterizerMultiply;
  cfg.EllipsisChar = ellipsisChar;

  // copy name (truncate if too long)
  {
    auto l = getStringLength(name);
    if(l >= sizeof(cfg.Name)) {
       l = sizeof(cfg.Name)-1;
    }
    memcpy(cfg.Name,name,l);
    cfg.Name[l] = '\0';
  }

  // copy glyph range
  {
	auto l = getSliceLength(glyphRanges);
	auto tmp = (ImWchar*)ImGui::MemAlloc(l*sizeof(ImWchar));
    memcpy(tmp,glyphRanges,l*sizeof(ImWchar));
	cfg.GlyphRanges = tmp;
  }

  ImGuiIO& io = ImGui::GetIO();
  font = (uintptr_t)io.Fonts->AddFont(&cfg);

  if(font != 0 && !mergeMode){
     io.Fonts->Build();
  }
;
    sendValue(font);
    flushSend();
  }
  }
  break;
case 0x000000aa:
  {
    FFFI_FUNCTION_INVOCATION("RenderChar")
    auto foreignptr = receiveValue<uintptr_t>();
    auto drawList = receiveValue<uintptr_t>();
    auto size = receiveValue<float>();
    auto pos = receiveArray<float,2>();
    auto color = receiveValue<uint32_t>();
    auto charP = receiveValue<ImWchar>();
    {
    
auto dl = (ImDrawList*)drawList;
if(dl == nullptr) {
   dl = ImGui::GetForegroundDrawList();
}
((ImFont*)foreignptr)->RenderChar(dl,size,pos,color,(ImWchar)charP);
  }
  }
  break;
case 0x000000ab:
  {
    FFFI_FUNCTION_INVOCATION("FontRenderText")
    auto foreignptr = receiveValue<uintptr_t>();
    auto drawList = receiveValue<uintptr_t>();
    auto size = receiveValue<float>();
    auto pos = receiveArray<float,2>();
    auto color = receiveValue<uint32_t>();
    auto clipRect = receiveArray<float,4>();
    auto text = receiveString();
    {
    
auto dl = (ImDrawList*)drawList;
if(dl == nullptr) {
   dl = ImGui::GetForegroundDrawList();
}
((ImFont*)foreignptr)->RenderText(dl,size,pos,(ImU32)color,clipRect,text,text+getStringLength(text));
  }
  }
  break;
case 0x000000ac:
  {
    FFFI_FUNCTION_INVOCATION("FontRenderTextV")
    auto foreignptr = receiveValue<uintptr_t>();
    auto drawList = receiveValue<uintptr_t>();
    auto size = receiveValue<float>();
    auto pos = receiveArray<float,2>();
    auto color = receiveValue<uint32_t>();
    auto clipRect = receiveArray<float,4>();
    auto text = receiveString();
    auto wrapWidth = receiveValue<float>();
    auto cpuFineClip = receiveValue<bool>();
    {
    
auto dl = (ImDrawList*)drawList;
if(dl == nullptr) {
   dl = ImGui::GetForegroundDrawList();
}
((ImFont*)foreignptr)->RenderText(dl,size,pos,(ImU32)color,clipRect,text,text+getStringLength(text),wrapWidth,cpuFineClip);
  }
  }
  break;
case 0x000000ad:
  {
    FFFI_FUNCTION_INVOCATION("CalcTextSizeA")
    auto foreignptr = receiveValue<uintptr_t>();
    auto size = receiveValue<float>();
    auto max_width = receiveValue<float>();
    auto wrap_width = receiveValue<float>();
    auto text = receiveString();
    auto pixel_perfect = receiveValue<bool>();
    float* r;
    uint64_t remainingBytes;
    {
    
         ImVec2 r;
         const char **remaining = nullptr;
         auto end = text+getStringLength(text);
         r = ((ImFont*)foreignptr)->CalcTextSizeA(size,max_width,wrap_width,text,end,remaining);
         // see https://github.com/ocornut/imgui/pull/3437 https://github.com/ocornut/imgui/issues/3776 https://github.com/ocornut/imgui/issues/791
         if(pixel_perfect) {
            // original
            //r.x = IM_TRUNC(r.x + 0.99999f);
            // improved, see https://github.com/ocornut/imgui/issues/791
            r.x = ceilf(r.x);
         }
         remainingBytes = (uintptr_t)end-(uintptr_t)remaining;
;
    sendArray<float,2>(r);
    sendValue<uint64_t>(remainingBytes);
    flushSend();
  }
  }
  break;
case 0x000000ae:
  {
    FFFI_FUNCTION_INVOCATION("DestroyContext")
    {
    ImGui::DestroyContext();
  }
  }
  break;
case 0x000000af:
  {
    FFFI_FUNCTION_INVOCATION("NewFrame")
    {
    ImGui::NewFrame();
  }
  }
  break;
case 0x000000b0:
  {
    FFFI_FUNCTION_INVOCATION("EndFrame")
    {
    ImGui::EndFrame();
  }
  }
  break;
case 0x000000b1:
  {
    FFFI_FUNCTION_INVOCATION("Render")
    {
    ImGui::Render();
  }
  }
  break;
case 0x000000b2:
  {
    FFFI_FUNCTION_INVOCATION("ShowDemoWindow")
    {
    ImGui::ShowDemoWindow();
  }
  }
  break;
case 0x000000b3:
  {
    FFFI_FUNCTION_INVOCATION("ShowMetricsWindow")
    {
    ImGui::ShowMetricsWindow();
  }
  }
  break;
case 0x000000b4:
  {
    FFFI_FUNCTION_INVOCATION("ShowDebugLogWindow")
    {
    ImGui::ShowDebugLogWindow();
  }
  }
  break;
case 0x000000b5:
  {
    FFFI_FUNCTION_INVOCATION("ShowIDStackToolWindow")
    {
    ImGui::ShowIDStackToolWindow();
  }
  }
  break;
case 0x000000b6:
  {
    FFFI_FUNCTION_INVOCATION("ShowAboutWindow")
    {
    ImGui::ShowAboutWindow();
  }
  }
  break;
case 0x000000b7:
  {
    FFFI_FUNCTION_INVOCATION("ShowStyleEditor")
    {
    ImGui::ShowStyleEditor();
  }
  }
  break;
case 0x000000b8:
  {
    FFFI_FUNCTION_INVOCATION("ShowStyleSelector")
    auto label = receiveString();
    bool r;
    {
    auto r = ImGui::ShowStyleSelector(label);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000000b9:
  {
    FFFI_FUNCTION_INVOCATION("ShowFontSelector")
    auto label = receiveString();
    {
    ImGui::ShowFontSelector(label);
  }
  }
  break;
case 0x000000ba:
  {
    FFFI_FUNCTION_INVOCATION("ShowUserGuide")
    {
    ImGui::ShowUserGuide();
  }
  }
  break;
case 0x000000bb:
  {
    FFFI_FUNCTION_INVOCATION("GetVersion")
    const char * r;
    {
    auto r = ImGui::GetVersion();
    sendString(r);
    flushSend();
  }
  }
  break;
case 0x000000bc:
  {
    FFFI_FUNCTION_INVOCATION("StyleColorsDark")
    {
    ImGui::StyleColorsDark();
  }
  }
  break;
case 0x000000bd:
  {
    FFFI_FUNCTION_INVOCATION("StyleColorsLight")
    {
    ImGui::StyleColorsLight();
  }
  }
  break;
case 0x000000be:
  {
    FFFI_FUNCTION_INVOCATION("StyleColorsClassic")
    {
    ImGui::StyleColorsClassic();
  }
  }
  break;
case 0x000000bf:
  {
    FFFI_FUNCTION_INVOCATION("Begin")
    auto name = receiveString();
    bool r;
    {
    auto r = ImGui::Begin(name);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000000c0:
  {
    FFFI_FUNCTION_INVOCATION("BeginV")
    auto name = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    bool r;
    bool p_open;
    {
    p_open = true; /* see issue #5 */
auto r = ImGui::Begin(name, &p_open, flags);
    sendValue<bool>(r);
    sendValue<bool>(p_open);
    flushSend();
  }
  }
  break;
case 0x000000c1:
  {
    FFFI_FUNCTION_INVOCATION("End")
    {
    ImGui::End();
  }
  }
  break;
case 0x000000c2:
  {
    FFFI_FUNCTION_INVOCATION("BeginChild")
    auto str_id = receiveString();
    bool r;
    {
    auto r = ImGui::BeginChild(str_id);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000000c3:
  {
    FFFI_FUNCTION_INVOCATION("BeginChildV")
    auto str_id = receiveString();
    auto size = receiveArray<float,2>();
    auto child_flags = receiveValueSignMagnitude<int>();
    auto window_flags = receiveValueSignMagnitude<int>();
    bool r;
    {
    auto r = ImGui::BeginChild(str_id, size, child_flags, window_flags);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000000c4:
  {
    FFFI_FUNCTION_INVOCATION("BeginChildID")
    auto id = receiveValue<uint32_t>();
    bool r;
    {
    auto r = ImGui::BeginChild(id);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000000c5:
  {
    FFFI_FUNCTION_INVOCATION("BeginChildVID")
    auto id = receiveValue<uint32_t>();
    auto size = receiveArray<float,2>();
    auto child_flags = receiveValueSignMagnitude<int>();
    auto window_flags = receiveValueSignMagnitude<int>();
    bool r;
    {
    auto r = ImGui::BeginChild(id, size, child_flags, window_flags);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000000c6:
  {
    FFFI_FUNCTION_INVOCATION("EndChild")
    {
    ImGui::EndChild();
  }
  }
  break;
case 0x000000c7:
  {
    FFFI_FUNCTION_INVOCATION("IsWindowAppearing")
    bool r;
    {
    auto r = ImGui::IsWindowAppearing();
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000000c8:
  {
    FFFI_FUNCTION_INVOCATION("IsWindowCollapsed")
    bool r;
    {
    auto r = ImGui::IsWindowCollapsed();
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000000c9:
  {
    FFFI_FUNCTION_INVOCATION("IsWindowFocused")
    bool r;
    {
    auto r = ImGui::IsWindowFocused();
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000000ca:
  {
    FFFI_FUNCTION_INVOCATION("IsWindowFocusedV")
    auto flags = receiveValueSignMagnitude<int>();
    bool r;
    {
    auto r = ImGui::IsWindowFocused(flags);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000000cb:
  {
    FFFI_FUNCTION_INVOCATION("IsWindowHovered")
    bool r;
    {
    auto r = ImGui::IsWindowHovered();
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000000cc:
  {
    FFFI_FUNCTION_INVOCATION("IsWindowHoveredV")
    auto flags = receiveValueSignMagnitude<int>();
    bool r;
    {
    auto r = ImGui::IsWindowHovered(flags);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000000cd:
  {
    FFFI_FUNCTION_INVOCATION("GetWindowDrawList")
    uintptr_t r;
    {
    auto r = ImGui::GetWindowDrawList();
    sendValue(r);
    flushSend();
  }
  }
  break;
case 0x000000ce:
  {
    FFFI_FUNCTION_INVOCATION("GetWindowDpiScale")
    float r;
    {
    auto r = ImGui::GetWindowDpiScale();
    sendValue<float>(r);
    flushSend();
  }
  }
  break;
case 0x000000cf:
  {
    FFFI_FUNCTION_INVOCATION("GetWindowPos")
    float* r;
    {
    auto r = ImGui::GetWindowPos();
    sendArray<float,2>(r);
    flushSend();
  }
  }
  break;
case 0x000000d0:
  {
    FFFI_FUNCTION_INVOCATION("GetWindowSize")
    float* r;
    {
    auto r = ImGui::GetWindowSize();
    sendArray<float,2>(r);
    flushSend();
  }
  }
  break;
case 0x000000d1:
  {
    FFFI_FUNCTION_INVOCATION("GetWindowWidth")
    float r;
    {
    auto r = ImGui::GetWindowWidth();
    sendValue<float>(r);
    flushSend();
  }
  }
  break;
case 0x000000d2:
  {
    FFFI_FUNCTION_INVOCATION("GetWindowHeight")
    float r;
    {
    auto r = ImGui::GetWindowHeight();
    sendValue<float>(r);
    flushSend();
  }
  }
  break;
case 0x000000d3:
  {
    FFFI_FUNCTION_INVOCATION("SetNextWindowPos")
    auto pos = receiveArray<float,2>();
    {
    ImGui::SetNextWindowPos(pos);
  }
  }
  break;
case 0x000000d4:
  {
    FFFI_FUNCTION_INVOCATION("SetNextWindowPosV")
    auto pos = receiveArray<float,2>();
    auto cond = receiveValueSignMagnitude<int>();
    auto pivot = receiveArray<float,2>();
    {
    ImGui::SetNextWindowPos(pos, cond, pivot);
  }
  }
  break;
case 0x000000d5:
  {
    FFFI_FUNCTION_INVOCATION("SetNextWindowSize")
    auto size = receiveArray<float,2>();
    {
    ImGui::SetNextWindowSize(size);
  }
  }
  break;
case 0x000000d6:
  {
    FFFI_FUNCTION_INVOCATION("SetNextWindowSizeV")
    auto size = receiveArray<float,2>();
    auto cond = receiveValueSignMagnitude<int>();
    {
    ImGui::SetNextWindowSize(size, cond);
  }
  }
  break;
case 0x000000d7:
  {
    FFFI_FUNCTION_INVOCATION("SetNextWindowSizeConstraints")
    auto size_min = receiveArray<float,2>();
    auto size_max = receiveArray<float,2>();
    {
    ImGui::SetNextWindowSizeConstraints(size_min, size_max);
  }
  }
  break;
case 0x000000d8:
  {
    FFFI_FUNCTION_INVOCATION("SetNextWindowContentSize")
    auto size = receiveArray<float,2>();
    {
    ImGui::SetNextWindowContentSize(size);
  }
  }
  break;
case 0x000000d9:
  {
    FFFI_FUNCTION_INVOCATION("SetNextWindowCollapsed")
    auto collapsed = receiveValue<bool>();
    {
    ImGui::SetNextWindowCollapsed(collapsed);
  }
  }
  break;
case 0x000000da:
  {
    FFFI_FUNCTION_INVOCATION("SetNextWindowCollapsedV")
    auto collapsed = receiveValue<bool>();
    auto cond = receiveValueSignMagnitude<int>();
    {
    ImGui::SetNextWindowCollapsed(collapsed, cond);
  }
  }
  break;
case 0x000000db:
  {
    FFFI_FUNCTION_INVOCATION("SetNextWindowFocus")
    {
    ImGui::SetNextWindowFocus();
  }
  }
  break;
case 0x000000dc:
  {
    FFFI_FUNCTION_INVOCATION("SetNextWindowScroll")
    auto scroll = receiveArray<float,2>();
    {
    ImGui::SetNextWindowScroll(scroll);
  }
  }
  break;
case 0x000000dd:
  {
    FFFI_FUNCTION_INVOCATION("SetNextWindowBgAlpha")
    auto alpha = receiveValue<float>();
    {
    ImGui::SetNextWindowBgAlpha(alpha);
  }
  }
  break;
case 0x000000de:
  {
    FFFI_FUNCTION_INVOCATION("SetNextWindowViewport")
    auto viewport_id = receiveValue<uint32_t>();
    {
    ImGui::SetNextWindowViewport(viewport_id);
  }
  }
  break;
case 0x000000df:
  {
    FFFI_FUNCTION_INVOCATION("SetWindowPos")
    auto name = receiveString();
    auto pos = receiveArray<float,2>();
    {
    ImGui::SetWindowPos(name, pos);
  }
  }
  break;
case 0x000000e0:
  {
    FFFI_FUNCTION_INVOCATION("SetWindowPosV")
    auto name = receiveString();
    auto pos = receiveArray<float,2>();
    auto cond = receiveValueSignMagnitude<int>();
    {
    ImGui::SetWindowPos(name, pos, cond);
  }
  }
  break;
case 0x000000e1:
  {
    FFFI_FUNCTION_INVOCATION("SetWindowSize")
    auto name = receiveString();
    auto size = receiveArray<float,2>();
    {
    ImGui::SetWindowSize(name, size);
  }
  }
  break;
case 0x000000e2:
  {
    FFFI_FUNCTION_INVOCATION("SetWindowSizeV")
    auto name = receiveString();
    auto size = receiveArray<float,2>();
    auto cond = receiveValueSignMagnitude<int>();
    {
    ImGui::SetWindowSize(name, size, cond);
  }
  }
  break;
case 0x000000e3:
  {
    FFFI_FUNCTION_INVOCATION("SetWindowCollapsed")
    auto name = receiveString();
    auto collapsed = receiveValue<bool>();
    {
    ImGui::SetWindowCollapsed(name, collapsed);
  }
  }
  break;
case 0x000000e4:
  {
    FFFI_FUNCTION_INVOCATION("SetWindowCollapsedV")
    auto name = receiveString();
    auto collapsed = receiveValue<bool>();
    auto cond = receiveValueSignMagnitude<int>();
    {
    ImGui::SetWindowCollapsed(name, collapsed, cond);
  }
  }
  break;
case 0x000000e5:
  {
    FFFI_FUNCTION_INVOCATION("SetWindowFocus")
    auto name = receiveString();
    {
    ImGui::SetWindowFocus(name);
  }
  }
  break;
case 0x000000e6:
  {
    FFFI_FUNCTION_INVOCATION("GetScrollX")
    float r;
    {
    auto r = ImGui::GetScrollX();
    sendValue<float>(r);
    flushSend();
  }
  }
  break;
case 0x000000e7:
  {
    FFFI_FUNCTION_INVOCATION("GetScrollY")
    float r;
    {
    auto r = ImGui::GetScrollY();
    sendValue<float>(r);
    flushSend();
  }
  }
  break;
case 0x000000e8:
  {
    FFFI_FUNCTION_INVOCATION("SetScrollX")
    auto scroll_x = receiveValue<float>();
    {
    ImGui::SetScrollX(scroll_x);
  }
  }
  break;
case 0x000000e9:
  {
    FFFI_FUNCTION_INVOCATION("SetScrollY")
    auto scroll_y = receiveValue<float>();
    {
    ImGui::SetScrollY(scroll_y);
  }
  }
  break;
case 0x000000ea:
  {
    FFFI_FUNCTION_INVOCATION("GetScrollMaxX")
    float r;
    {
    auto r = ImGui::GetScrollMaxX();
    sendValue<float>(r);
    flushSend();
  }
  }
  break;
case 0x000000eb:
  {
    FFFI_FUNCTION_INVOCATION("GetScrollMaxY")
    float r;
    {
    auto r = ImGui::GetScrollMaxY();
    sendValue<float>(r);
    flushSend();
  }
  }
  break;
case 0x000000ec:
  {
    FFFI_FUNCTION_INVOCATION("SetScrollHereX")
    {
    ImGui::SetScrollHereX();
  }
  }
  break;
case 0x000000ed:
  {
    FFFI_FUNCTION_INVOCATION("SetScrollHereXV")
    auto center_x_ratio = receiveValue<float>();
    {
    ImGui::SetScrollHereX(center_x_ratio);
  }
  }
  break;
case 0x000000ee:
  {
    FFFI_FUNCTION_INVOCATION("SetScrollHereY")
    {
    ImGui::SetScrollHereY();
  }
  }
  break;
case 0x000000ef:
  {
    FFFI_FUNCTION_INVOCATION("SetScrollHereYV")
    auto center_y_ratio = receiveValue<float>();
    {
    ImGui::SetScrollHereY(center_y_ratio);
  }
  }
  break;
case 0x000000f0:
  {
    FFFI_FUNCTION_INVOCATION("SetScrollFromPosX")
    auto local_x = receiveValue<float>();
    {
    ImGui::SetScrollFromPosX(local_x);
  }
  }
  break;
case 0x000000f1:
  {
    FFFI_FUNCTION_INVOCATION("SetScrollFromPosXV")
    auto local_x = receiveValue<float>();
    auto center_x_ratio = receiveValue<float>();
    {
    ImGui::SetScrollFromPosX(local_x, center_x_ratio);
  }
  }
  break;
case 0x000000f2:
  {
    FFFI_FUNCTION_INVOCATION("SetScrollFromPosY")
    auto local_y = receiveValue<float>();
    {
    ImGui::SetScrollFromPosY(local_y);
  }
  }
  break;
case 0x000000f3:
  {
    FFFI_FUNCTION_INVOCATION("SetScrollFromPosYV")
    auto local_y = receiveValue<float>();
    auto center_y_ratio = receiveValue<float>();
    {
    ImGui::SetScrollFromPosY(local_y, center_y_ratio);
  }
  }
  break;
case 0x000000f4:
  {
    FFFI_FUNCTION_INVOCATION("PopFont")
    {
    ImGui::PopFont();
  }
  }
  break;
case 0x000000f5:
  {
    FFFI_FUNCTION_INVOCATION("PushStyleColor")
    auto idx = receiveValueSignMagnitude<int>();
    auto col = receiveValue<uint32_t>();
    {
    ImGui::PushStyleColor(idx, col);
  }
  }
  break;
case 0x000000f6:
  {
    FFFI_FUNCTION_INVOCATION("PushStyleColorImVec4")
    auto idx = receiveValueSignMagnitude<int>();
    auto col = receiveArray<float,4>();
    {
    ImGui::PushStyleColor(idx, col);
  }
  }
  break;
case 0x000000f7:
  {
    FFFI_FUNCTION_INVOCATION("PopStyleColor")
    {
    ImGui::PopStyleColor();
  }
  }
  break;
case 0x000000f8:
  {
    FFFI_FUNCTION_INVOCATION("PopStyleColorV")
    auto count = receiveValueSignMagnitude<int>();
    {
    ImGui::PopStyleColor(count);
  }
  }
  break;
case 0x000000f9:
  {
    FFFI_FUNCTION_INVOCATION("PushStyleVar")
    auto idx = receiveValueSignMagnitude<int>();
    auto val = receiveValue<float>();
    {
    ImGui::PushStyleVar(idx, val);
  }
  }
  break;
case 0x000000fa:
  {
    FFFI_FUNCTION_INVOCATION("PushStyleVarImVec2")
    auto idx = receiveValueSignMagnitude<int>();
    auto val = receiveArray<float,2>();
    {
    ImGui::PushStyleVar(idx, val);
  }
  }
  break;
case 0x000000fb:
  {
    FFFI_FUNCTION_INVOCATION("PushStyleVarX")
    auto idx = receiveValueSignMagnitude<int>();
    auto val_x = receiveValue<float>();
    {
    ImGui::PushStyleVarX(idx, val_x);
  }
  }
  break;
case 0x000000fc:
  {
    FFFI_FUNCTION_INVOCATION("PushStyleVarY")
    auto idx = receiveValueSignMagnitude<int>();
    auto val_y = receiveValue<float>();
    {
    ImGui::PushStyleVarY(idx, val_y);
  }
  }
  break;
case 0x000000fd:
  {
    FFFI_FUNCTION_INVOCATION("PopStyleVar")
    {
    ImGui::PopStyleVar();
  }
  }
  break;
case 0x000000fe:
  {
    FFFI_FUNCTION_INVOCATION("PopStyleVarV")
    auto count = receiveValueSignMagnitude<int>();
    {
    ImGui::PopStyleVar(count);
  }
  }
  break;
case 0x000000ff:
  {
    FFFI_FUNCTION_INVOCATION("PushItemFlag")
    auto option = receiveValueSignMagnitude<int>();
    auto enabled = receiveValue<bool>();
    {
    ImGui::PushItemFlag(option, enabled);
  }
  }
  break;
case 0x00000100:
  {
    FFFI_FUNCTION_INVOCATION("PopItemFlag")
    {
    ImGui::PopItemFlag();
  }
  }
  break;
case 0x00000101:
  {
    FFFI_FUNCTION_INVOCATION("PushItemWidth")
    auto item_width = receiveValue<float>();
    {
    ImGui::PushItemWidth(item_width);
  }
  }
  break;
case 0x00000102:
  {
    FFFI_FUNCTION_INVOCATION("PopItemWidth")
    {
    ImGui::PopItemWidth();
  }
  }
  break;
case 0x00000103:
  {
    FFFI_FUNCTION_INVOCATION("SetNextItemWidth")
    auto item_width = receiveValue<float>();
    {
    ImGui::SetNextItemWidth(item_width);
  }
  }
  break;
case 0x00000104:
  {
    FFFI_FUNCTION_INVOCATION("CalcItemWidth")
    float r;
    {
    auto r = ImGui::CalcItemWidth();
    sendValue<float>(r);
    flushSend();
  }
  }
  break;
case 0x00000105:
  {
    FFFI_FUNCTION_INVOCATION("PushTextWrapPos")
    {
    ImGui::PushTextWrapPos();
  }
  }
  break;
case 0x00000106:
  {
    FFFI_FUNCTION_INVOCATION("PushTextWrapPosV")
    auto wrap_local_pos_x = receiveValue<float>();
    {
    ImGui::PushTextWrapPos(wrap_local_pos_x);
  }
  }
  break;
case 0x00000107:
  {
    FFFI_FUNCTION_INVOCATION("PopTextWrapPos")
    {
    ImGui::PopTextWrapPos();
  }
  }
  break;
case 0x00000108:
  {
    FFFI_FUNCTION_INVOCATION("GetFontSize")
    float r;
    {
    auto r = ImGui::GetFontSize();
    sendValue<float>(r);
    flushSend();
  }
  }
  break;
case 0x00000109:
  {
    FFFI_FUNCTION_INVOCATION("GetFontTexUvWhitePixel")
    float* r;
    {
    auto r = ImGui::GetFontTexUvWhitePixel();
    sendArray<float,2>(r);
    flushSend();
  }
  }
  break;
case 0x0000010a:
  {
    FFFI_FUNCTION_INVOCATION("GetColorU32ImGuiCol")
    auto idx = receiveValueSignMagnitude<int>();
    uint32_t r;
    {
    auto r = ImGui::GetColorU32(idx);
    sendValue<uint32_t>(r);
    flushSend();
  }
  }
  break;
case 0x0000010b:
  {
    FFFI_FUNCTION_INVOCATION("GetColorU32ImGuiColV")
    auto idx = receiveValueSignMagnitude<int>();
    auto alpha_mul = receiveValue<float>();
    uint32_t r;
    {
    auto r = ImGui::GetColorU32(idx, alpha_mul);
    sendValue<uint32_t>(r);
    flushSend();
  }
  }
  break;
case 0x0000010c:
  {
    FFFI_FUNCTION_INVOCATION("GetColorU32ImVec4")
    auto col = receiveArray<float,4>();
    uint32_t r;
    {
    auto r = ImGui::GetColorU32(col);
    sendValue<uint32_t>(r);
    flushSend();
  }
  }
  break;
case 0x0000010d:
  {
    FFFI_FUNCTION_INVOCATION("GetColorU32")
    auto col = receiveValue<uint32_t>();
    uint32_t r;
    {
    auto r = ImGui::GetColorU32(col);
    sendValue<uint32_t>(r);
    flushSend();
  }
  }
  break;
case 0x0000010e:
  {
    FFFI_FUNCTION_INVOCATION("GetColorU32V")
    auto col = receiveValue<uint32_t>();
    auto alpha_mul = receiveValue<float>();
    uint32_t r;
    {
    auto r = ImGui::GetColorU32(col, alpha_mul);
    sendValue<uint32_t>(r);
    flushSend();
  }
  }
  break;
case 0x0000010f:
  {
    FFFI_FUNCTION_INVOCATION("GetStyleColorVec4")
    auto idx = receiveValueSignMagnitude<int>();
    float* r;
    {
    auto r = ImGui::GetStyleColorVec4(idx);
    sendArray<float,4>(r);
    flushSend();
  }
  }
  break;
case 0x00000110:
  {
    FFFI_FUNCTION_INVOCATION("GetCursorScreenPos")
    float* r;
    {
    auto r = ImGui::GetCursorScreenPos();
    sendArray<float,2>(r);
    flushSend();
  }
  }
  break;
case 0x00000111:
  {
    FFFI_FUNCTION_INVOCATION("SetCursorScreenPos")
    auto pos = receiveArray<float,2>();
    {
    ImGui::SetCursorScreenPos(pos);
  }
  }
  break;
case 0x00000112:
  {
    FFFI_FUNCTION_INVOCATION("GetContentRegionAvail")
    float* r;
    {
    auto r = ImGui::GetContentRegionAvail();
    sendArray<float,2>(r);
    flushSend();
  }
  }
  break;
case 0x00000113:
  {
    FFFI_FUNCTION_INVOCATION("GetCursorPos")
    float* r;
    {
    auto r = ImGui::GetCursorPos();
    sendArray<float,2>(r);
    flushSend();
  }
  }
  break;
case 0x00000114:
  {
    FFFI_FUNCTION_INVOCATION("GetCursorPosX")
    float r;
    {
    auto r = ImGui::GetCursorPosX();
    sendValue<float>(r);
    flushSend();
  }
  }
  break;
case 0x00000115:
  {
    FFFI_FUNCTION_INVOCATION("GetCursorPosY")
    float r;
    {
    auto r = ImGui::GetCursorPosY();
    sendValue<float>(r);
    flushSend();
  }
  }
  break;
case 0x00000116:
  {
    FFFI_FUNCTION_INVOCATION("SetCursorPos")
    auto local_pos = receiveArray<float,2>();
    {
    ImGui::SetCursorPos(local_pos);
  }
  }
  break;
case 0x00000117:
  {
    FFFI_FUNCTION_INVOCATION("SetCursorPosX")
    auto local_x = receiveValue<float>();
    {
    ImGui::SetCursorPosX(local_x);
  }
  }
  break;
case 0x00000118:
  {
    FFFI_FUNCTION_INVOCATION("SetCursorPosY")
    auto local_y = receiveValue<float>();
    {
    ImGui::SetCursorPosY(local_y);
  }
  }
  break;
case 0x00000119:
  {
    FFFI_FUNCTION_INVOCATION("GetCursorStartPos")
    float* r;
    {
    auto r = ImGui::GetCursorStartPos();
    sendArray<float,2>(r);
    flushSend();
  }
  }
  break;
case 0x0000011a:
  {
    FFFI_FUNCTION_INVOCATION("Separator")
    {
    ImGui::Separator();
  }
  }
  break;
case 0x0000011b:
  {
    FFFI_FUNCTION_INVOCATION("SameLine")
    {
    ImGui::SameLine();
  }
  }
  break;
case 0x0000011c:
  {
    FFFI_FUNCTION_INVOCATION("SameLineV")
    auto offset_from_start_x = receiveValue<float>();
    auto spacing = receiveValue<float>();
    {
    ImGui::SameLine(offset_from_start_x, spacing);
  }
  }
  break;
case 0x0000011d:
  {
    FFFI_FUNCTION_INVOCATION("NewLine")
    {
    ImGui::NewLine();
  }
  }
  break;
case 0x0000011e:
  {
    FFFI_FUNCTION_INVOCATION("Spacing")
    {
    ImGui::Spacing();
  }
  }
  break;
case 0x0000011f:
  {
    FFFI_FUNCTION_INVOCATION("Dummy")
    auto size = receiveArray<float,2>();
    {
    ImGui::Dummy(size);
  }
  }
  break;
case 0x00000120:
  {
    FFFI_FUNCTION_INVOCATION("Indent")
    {
    ImGui::Indent();
  }
  }
  break;
case 0x00000121:
  {
    FFFI_FUNCTION_INVOCATION("IndentV")
    auto indent_w = receiveValue<float>();
    {
    ImGui::Indent(indent_w);
  }
  }
  break;
case 0x00000122:
  {
    FFFI_FUNCTION_INVOCATION("Unindent")
    {
    ImGui::Unindent();
  }
  }
  break;
case 0x00000123:
  {
    FFFI_FUNCTION_INVOCATION("UnindentV")
    auto indent_w = receiveValue<float>();
    {
    ImGui::Unindent(indent_w);
  }
  }
  break;
case 0x00000124:
  {
    FFFI_FUNCTION_INVOCATION("BeginGroup")
    {
    ImGui::BeginGroup();
  }
  }
  break;
case 0x00000125:
  {
    FFFI_FUNCTION_INVOCATION("EndGroup")
    {
    ImGui::EndGroup();
  }
  }
  break;
case 0x00000126:
  {
    FFFI_FUNCTION_INVOCATION("AlignTextToFramePadding")
    {
    ImGui::AlignTextToFramePadding();
  }
  }
  break;
case 0x00000127:
  {
    FFFI_FUNCTION_INVOCATION("GetTextLineHeight")
    float r;
    {
    auto r = ImGui::GetTextLineHeight();
    sendValue<float>(r);
    flushSend();
  }
  }
  break;
case 0x00000128:
  {
    FFFI_FUNCTION_INVOCATION("GetTextLineHeightWithSpacing")
    float r;
    {
    auto r = ImGui::GetTextLineHeightWithSpacing();
    sendValue<float>(r);
    flushSend();
  }
  }
  break;
case 0x00000129:
  {
    FFFI_FUNCTION_INVOCATION("GetFrameHeight")
    float r;
    {
    auto r = ImGui::GetFrameHeight();
    sendValue<float>(r);
    flushSend();
  }
  }
  break;
case 0x0000012a:
  {
    FFFI_FUNCTION_INVOCATION("GetFrameHeightWithSpacing")
    float r;
    {
    auto r = ImGui::GetFrameHeightWithSpacing();
    sendValue<float>(r);
    flushSend();
  }
  }
  break;
case 0x0000012b:
  {
    FFFI_FUNCTION_INVOCATION("PushID")
    auto str_id = receiveString();
    {
    ImGui::PushID(str_id);
  }
  }
  break;
case 0x0000012c:
  {
    FFFI_FUNCTION_INVOCATION("PushIDInt")
    auto int_id = receiveValueSignMagnitude<int>();
    {
    ImGui::PushID(int_id);
  }
  }
  break;
case 0x0000012d:
  {
    FFFI_FUNCTION_INVOCATION("PopID")
    {
    ImGui::PopID();
  }
  }
  break;
case 0x0000012e:
  {
    FFFI_FUNCTION_INVOCATION("GetID")
    auto str_id = receiveString();
    uint32_t r;
    {
    auto r = ImGui::GetID(str_id);
    sendValue<uint32_t>(r);
    flushSend();
  }
  }
  break;
case 0x0000012f:
  {
    FFFI_FUNCTION_INVOCATION("GetIDInt")
    auto int_id = receiveValueSignMagnitude<int>();
    uint32_t r;
    {
    auto r = ImGui::GetID(int_id);
    sendValue<uint32_t>(r);
    flushSend();
  }
  }
  break;
case 0x00000130:
  {
    FFFI_FUNCTION_INVOCATION("SeparatorText")
    auto label = receiveString();
    {
    ImGui::SeparatorText(label);
  }
  }
  break;
case 0x00000131:
  {
    FFFI_FUNCTION_INVOCATION("Button")
    auto label = receiveString();
    bool r;
    {
    auto r = ImGui::Button(label);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000132:
  {
    FFFI_FUNCTION_INVOCATION("ButtonV")
    auto label = receiveString();
    auto size = receiveArray<float,2>();
    bool r;
    {
    auto r = ImGui::Button(label, size);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000133:
  {
    FFFI_FUNCTION_INVOCATION("SmallButton")
    auto label = receiveString();
    bool r;
    {
    auto r = ImGui::SmallButton(label);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000134:
  {
    FFFI_FUNCTION_INVOCATION("InvisibleButton")
    auto str_id = receiveString();
    auto size = receiveArray<float,2>();
    bool r;
    {
    auto r = ImGui::InvisibleButton(str_id, size);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000135:
  {
    FFFI_FUNCTION_INVOCATION("InvisibleButtonV")
    auto str_id = receiveString();
    auto size = receiveArray<float,2>();
    auto flags = receiveValueSignMagnitude<int>();
    bool r;
    {
    auto r = ImGui::InvisibleButton(str_id, size, flags);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000136:
  {
    FFFI_FUNCTION_INVOCATION("ArrowButton")
    auto str_id = receiveString();
    auto dir = receiveValueSignMagnitude<int>();
    bool r;
    {
    auto r = ImGui::ArrowButton(str_id, ImGuiDir(dir));
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000137:
  {
    FFFI_FUNCTION_INVOCATION("RadioButton")
    auto label = receiveString();
    auto active = receiveValue<bool>();
    bool r;
    {
    auto r = ImGui::RadioButton(label, active);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000138:
  {
    FFFI_FUNCTION_INVOCATION("ProgressBar")
    auto fraction = receiveValue<float>();
    {
    ImGui::ProgressBar(fraction);
  }
  }
  break;
case 0x00000139:
  {
    FFFI_FUNCTION_INVOCATION("ProgressBarV")
    auto fraction = receiveValue<float>();
    auto size_arg = receiveArray<float,2>();
    auto overlay = receiveString();
    {
    ImGui::ProgressBar(fraction, size_arg, overlay);
  }
  }
  break;
case 0x0000013a:
  {
    FFFI_FUNCTION_INVOCATION("Bullet")
    {
    ImGui::Bullet();
  }
  }
  break;
case 0x0000013b:
  {
    FFFI_FUNCTION_INVOCATION("TextLink")
    auto label = receiveString();
    bool r;
    {
    auto r = ImGui::TextLink(label);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x0000013c:
  {
    FFFI_FUNCTION_INVOCATION("TextLinkOpenURL")
    auto label = receiveString();
    {
    ImGui::TextLinkOpenURL(label);
  }
  }
  break;
case 0x0000013d:
  {
    FFFI_FUNCTION_INVOCATION("TextLinkOpenURLV")
    auto label = receiveString();
    auto url = receiveString();
    {
    ImGui::TextLinkOpenURL(label, url);
  }
  }
  break;
case 0x0000013e:
  {
    FFFI_FUNCTION_INVOCATION("Image")
    auto user_texture_id = receiveValue<uintptr_t>();
    auto image_size = receiveArray<float,2>();
    {
    ImGui::Image(ImTextureID(user_texture_id), image_size);
  }
  }
  break;
case 0x0000013f:
  {
    FFFI_FUNCTION_INVOCATION("ImageV")
    auto user_texture_id = receiveValue<uintptr_t>();
    auto image_size = receiveArray<float,2>();
    auto uv0 = receiveArray<float,2>();
    auto uv1 = receiveArray<float,2>();
    auto tint_col = receiveArray<float,4>();
    auto border_col = receiveArray<float,4>();
    {
    ImGui::Image(ImTextureID(user_texture_id), image_size, uv0, uv1, tint_col, border_col);
  }
  }
  break;
case 0x00000140:
  {
    FFFI_FUNCTION_INVOCATION("ImageButton")
    auto str_id = receiveString();
    auto user_texture_id = receiveValue<uintptr_t>();
    auto image_size = receiveArray<float,2>();
    bool r;
    {
    auto r = ImGui::ImageButton(str_id, ImTextureID(user_texture_id), image_size);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000141:
  {
    FFFI_FUNCTION_INVOCATION("ImageButtonV")
    auto str_id = receiveString();
    auto user_texture_id = receiveValue<uintptr_t>();
    auto image_size = receiveArray<float,2>();
    auto uv0 = receiveArray<float,2>();
    auto uv1 = receiveArray<float,2>();
    auto bg_col = receiveArray<float,4>();
    auto tint_col = receiveArray<float,4>();
    bool r;
    {
    auto r = ImGui::ImageButton(str_id, ImTextureID(user_texture_id), image_size, uv0, uv1, bg_col, tint_col);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000142:
  {
    FFFI_FUNCTION_INVOCATION("BeginCombo")
    auto label = receiveString();
    auto preview_value = receiveString();
    bool r;
    {
    auto r = ImGui::BeginCombo(label, preview_value);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000143:
  {
    FFFI_FUNCTION_INVOCATION("BeginComboV")
    auto label = receiveString();
    auto preview_value = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    bool r;
    {
    auto r = ImGui::BeginCombo(label, preview_value, flags);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000144:
  {
    FFFI_FUNCTION_INVOCATION("EndCombo")
    {
    ImGui::EndCombo();
  }
  }
  break;
case 0x00000145:
  {
    FFFI_FUNCTION_INVOCATION("ColorButton")
    auto desc_id = receiveString();
    auto col = receiveArray<float,4>();
    bool r;
    {
    auto r = ImGui::ColorButton(desc_id, col);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000146:
  {
    FFFI_FUNCTION_INVOCATION("ColorButtonV")
    auto desc_id = receiveString();
    auto col = receiveArray<float,4>();
    auto flags = receiveValueSignMagnitude<int>();
    auto size = receiveArray<float,2>();
    bool r;
    {
    auto r = ImGui::ColorButton(desc_id, col, flags, size);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000147:
  {
    FFFI_FUNCTION_INVOCATION("SetColorEditOptions")
    auto flags = receiveValueSignMagnitude<int>();
    {
    ImGui::SetColorEditOptions(flags);
  }
  }
  break;
case 0x00000148:
  {
    FFFI_FUNCTION_INVOCATION("TreeNode")
    auto label = receiveString();
    bool r;
    {
    auto r = ImGui::TreeNode(label);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000149:
  {
    FFFI_FUNCTION_INVOCATION("TreeNodeEx")
    auto label = receiveString();
    bool r;
    {
    auto r = ImGui::TreeNodeEx(label);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x0000014a:
  {
    FFFI_FUNCTION_INVOCATION("TreeNodeExV")
    auto label = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    bool r;
    {
    auto r = ImGui::TreeNodeEx(label, flags);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x0000014b:
  {
    FFFI_FUNCTION_INVOCATION("TreePush")
    auto str_id = receiveString();
    {
    ImGui::TreePush(str_id);
  }
  }
  break;
case 0x0000014c:
  {
    FFFI_FUNCTION_INVOCATION("TreePop")
    {
    ImGui::TreePop();
  }
  }
  break;
case 0x0000014d:
  {
    FFFI_FUNCTION_INVOCATION("GetTreeNodeToLabelSpacing")
    float r;
    {
    auto r = ImGui::GetTreeNodeToLabelSpacing();
    sendValue<float>(r);
    flushSend();
  }
  }
  break;
case 0x0000014e:
  {
    FFFI_FUNCTION_INVOCATION("CollapsingHeader")
    auto label = receiveString();
    bool r;
    {
    auto r = ImGui::CollapsingHeader(label);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x0000014f:
  {
    FFFI_FUNCTION_INVOCATION("CollapsingHeaderV")
    auto label = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    bool r;
    {
    auto r = ImGui::CollapsingHeader(label, flags);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000150:
  {
    FFFI_FUNCTION_INVOCATION("SetNextItemOpen")
    auto is_open = receiveValue<bool>();
    {
    ImGui::SetNextItemOpen(is_open);
  }
  }
  break;
case 0x00000151:
  {
    FFFI_FUNCTION_INVOCATION("SetNextItemOpenV")
    auto is_open = receiveValue<bool>();
    auto cond = receiveValueSignMagnitude<int>();
    {
    ImGui::SetNextItemOpen(is_open, cond);
  }
  }
  break;
case 0x00000152:
  {
    FFFI_FUNCTION_INVOCATION("SetNextItemStorageID")
    auto storage_id = receiveValue<uint32_t>();
    {
    ImGui::SetNextItemStorageID(storage_id);
  }
  }
  break;
case 0x00000153:
  {
    FFFI_FUNCTION_INVOCATION("Selectable")
    auto label = receiveString();
    bool r;
    {
    auto r = ImGui::Selectable(label);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000154:
  {
    FFFI_FUNCTION_INVOCATION("SelectableV")
    auto label = receiveString();
    auto selected = receiveValue<bool>();
    auto flags = receiveValueSignMagnitude<int>();
    auto size = receiveArray<float,2>();
    bool r;
    {
    auto r = ImGui::Selectable(label, selected, flags, size);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000155:
  {
    FFFI_FUNCTION_INVOCATION("IsItemToggledSelection")
    bool r;
    {
    auto r = ImGui::IsItemToggledSelection();
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000156:
  {
    FFFI_FUNCTION_INVOCATION("BeginListBox")
    auto label = receiveString();
    bool r;
    {
    auto r = ImGui::BeginListBox(label);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000157:
  {
    FFFI_FUNCTION_INVOCATION("BeginListBoxV")
    auto label = receiveString();
    auto size = receiveArray<float,2>();
    bool r;
    {
    auto r = ImGui::BeginListBox(label, size);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000158:
  {
    FFFI_FUNCTION_INVOCATION("EndListBox")
    {
    ImGui::EndListBox();
  }
  }
  break;
case 0x00000159:
  {
    FFFI_FUNCTION_INVOCATION("BeginMenuBar")
    bool r;
    {
    auto r = ImGui::BeginMenuBar();
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x0000015a:
  {
    FFFI_FUNCTION_INVOCATION("EndMenuBar")
    {
    ImGui::EndMenuBar();
  }
  }
  break;
case 0x0000015b:
  {
    FFFI_FUNCTION_INVOCATION("BeginMainMenuBar")
    bool r;
    {
    auto r = ImGui::BeginMainMenuBar();
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x0000015c:
  {
    FFFI_FUNCTION_INVOCATION("EndMainMenuBar")
    {
    ImGui::EndMainMenuBar();
  }
  }
  break;
case 0x0000015d:
  {
    FFFI_FUNCTION_INVOCATION("BeginMenu")
    auto label = receiveString();
    bool r;
    {
    auto r = ImGui::BeginMenu(label);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x0000015e:
  {
    FFFI_FUNCTION_INVOCATION("BeginMenuV")
    auto label = receiveString();
    auto enabled = receiveValue<bool>();
    bool r;
    {
    auto r = ImGui::BeginMenu(label, enabled);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x0000015f:
  {
    FFFI_FUNCTION_INVOCATION("EndMenu")
    {
    ImGui::EndMenu();
  }
  }
  break;
case 0x00000160:
  {
    FFFI_FUNCTION_INVOCATION("MenuItem")
    auto label = receiveString();
    bool r;
    {
    auto r = ImGui::MenuItem(label);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000161:
  {
    FFFI_FUNCTION_INVOCATION("MenuItemV")
    auto label = receiveString();
    auto shortcut = receiveString();
    auto selected = receiveValue<bool>();
    auto enabled = receiveValue<bool>();
    bool r;
    {
    auto r = ImGui::MenuItem(label, shortcut, selected, enabled);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000162:
  {
    FFFI_FUNCTION_INVOCATION("BeginTooltip")
    bool r;
    {
    auto r = ImGui::BeginTooltip();
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000163:
  {
    FFFI_FUNCTION_INVOCATION("EndTooltip")
    {
    ImGui::EndTooltip();
  }
  }
  break;
case 0x00000164:
  {
    FFFI_FUNCTION_INVOCATION("BeginItemTooltip")
    bool r;
    {
    auto r = ImGui::BeginItemTooltip();
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000165:
  {
    FFFI_FUNCTION_INVOCATION("BeginPopup")
    auto str_id = receiveString();
    bool r;
    {
    auto r = ImGui::BeginPopup(str_id);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000166:
  {
    FFFI_FUNCTION_INVOCATION("BeginPopupV")
    auto str_id = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    bool r;
    {
    auto r = ImGui::BeginPopup(str_id, flags);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000167:
  {
    FFFI_FUNCTION_INVOCATION("BeginPopupModal")
    auto name = receiveString();
    bool r;
    {
    auto r = ImGui::BeginPopupModal(name);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000168:
  {
    FFFI_FUNCTION_INVOCATION("BeginPopupModalV")
    auto name = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    bool r;
    bool p_open;
    {
    p_open = true; /* see issue #5 */
auto r = ImGui::BeginPopupModal(name, &p_open, flags);
    sendValue<bool>(r);
    sendValue<bool>(p_open);
    flushSend();
  }
  }
  break;
case 0x00000169:
  {
    FFFI_FUNCTION_INVOCATION("EndPopup")
    {
    ImGui::EndPopup();
  }
  }
  break;
case 0x0000016a:
  {
    FFFI_FUNCTION_INVOCATION("OpenPopup")
    auto str_id = receiveString();
    {
    ImGui::OpenPopup(str_id);
  }
  }
  break;
case 0x0000016b:
  {
    FFFI_FUNCTION_INVOCATION("OpenPopupV")
    auto str_id = receiveString();
    auto popup_flags = receiveValueSignMagnitude<int>();
    {
    ImGui::OpenPopup(str_id, popup_flags);
  }
  }
  break;
case 0x0000016c:
  {
    FFFI_FUNCTION_INVOCATION("OpenPopupID")
    auto id = receiveValue<uint32_t>();
    {
    ImGui::OpenPopup(id);
  }
  }
  break;
case 0x0000016d:
  {
    FFFI_FUNCTION_INVOCATION("OpenPopupVID")
    auto id = receiveValue<uint32_t>();
    auto popup_flags = receiveValueSignMagnitude<int>();
    {
    ImGui::OpenPopup(id, popup_flags);
  }
  }
  break;
case 0x0000016e:
  {
    FFFI_FUNCTION_INVOCATION("OpenPopupOnItemClick")
    {
    ImGui::OpenPopupOnItemClick();
  }
  }
  break;
case 0x0000016f:
  {
    FFFI_FUNCTION_INVOCATION("OpenPopupOnItemClickV")
    auto str_id = receiveString();
    auto popup_flags = receiveValueSignMagnitude<int>();
    {
    ImGui::OpenPopupOnItemClick(str_id, popup_flags);
  }
  }
  break;
case 0x00000170:
  {
    FFFI_FUNCTION_INVOCATION("CloseCurrentPopup")
    {
    ImGui::CloseCurrentPopup();
  }
  }
  break;
case 0x00000171:
  {
    FFFI_FUNCTION_INVOCATION("BeginPopupContextItem")
    bool r;
    {
    auto r = ImGui::BeginPopupContextItem();
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000172:
  {
    FFFI_FUNCTION_INVOCATION("BeginPopupContextItemV")
    auto str_id = receiveString();
    auto popup_flags = receiveValueSignMagnitude<int>();
    bool r;
    {
    auto r = ImGui::BeginPopupContextItem(str_id, popup_flags);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000173:
  {
    FFFI_FUNCTION_INVOCATION("BeginPopupContextWindow")
    bool r;
    {
    auto r = ImGui::BeginPopupContextWindow();
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000174:
  {
    FFFI_FUNCTION_INVOCATION("BeginPopupContextWindowV")
    auto str_id = receiveString();
    auto popup_flags = receiveValueSignMagnitude<int>();
    bool r;
    {
    auto r = ImGui::BeginPopupContextWindow(str_id, popup_flags);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000175:
  {
    FFFI_FUNCTION_INVOCATION("BeginPopupContextVoid")
    bool r;
    {
    auto r = ImGui::BeginPopupContextVoid();
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000176:
  {
    FFFI_FUNCTION_INVOCATION("BeginPopupContextVoidV")
    auto str_id = receiveString();
    auto popup_flags = receiveValueSignMagnitude<int>();
    bool r;
    {
    auto r = ImGui::BeginPopupContextVoid(str_id, popup_flags);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000177:
  {
    FFFI_FUNCTION_INVOCATION("IsPopupOpen")
    auto str_id = receiveString();
    bool r;
    {
    auto r = ImGui::IsPopupOpen(str_id);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000178:
  {
    FFFI_FUNCTION_INVOCATION("IsPopupOpenV")
    auto str_id = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    bool r;
    {
    auto r = ImGui::IsPopupOpen(str_id, flags);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000179:
  {
    FFFI_FUNCTION_INVOCATION("BeginTable")
    auto str_id = receiveString();
    auto columns = receiveValueSignMagnitude<int>();
    bool r;
    {
    auto r = ImGui::BeginTable(str_id, columns);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x0000017a:
  {
    FFFI_FUNCTION_INVOCATION("BeginTableV")
    auto str_id = receiveString();
    auto columns = receiveValueSignMagnitude<int>();
    auto flags = receiveValueSignMagnitude<int>();
    auto outer_size = receiveArray<float,2>();
    auto inner_width = receiveValue<float>();
    bool r;
    {
    auto r = ImGui::BeginTable(str_id, columns, flags, outer_size, inner_width);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x0000017b:
  {
    FFFI_FUNCTION_INVOCATION("EndTable")
    {
    ImGui::EndTable();
  }
  }
  break;
case 0x0000017c:
  {
    FFFI_FUNCTION_INVOCATION("TableNextRow")
    {
    ImGui::TableNextRow();
  }
  }
  break;
case 0x0000017d:
  {
    FFFI_FUNCTION_INVOCATION("TableNextRowV")
    auto row_flags = receiveValueSignMagnitude<int>();
    auto min_row_height = receiveValue<float>();
    {
    ImGui::TableNextRow(row_flags, min_row_height);
  }
  }
  break;
case 0x0000017e:
  {
    FFFI_FUNCTION_INVOCATION("TableNextColumn")
    bool r;
    {
    auto r = ImGui::TableNextColumn();
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x0000017f:
  {
    FFFI_FUNCTION_INVOCATION("TableSetColumnIndex")
    auto column_n = receiveValueSignMagnitude<int>();
    bool r;
    {
    auto r = ImGui::TableSetColumnIndex(column_n);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000180:
  {
    FFFI_FUNCTION_INVOCATION("TableSetupColumn")
    auto label = receiveString();
    {
    ImGui::TableSetupColumn(label);
  }
  }
  break;
case 0x00000181:
  {
    FFFI_FUNCTION_INVOCATION("TableSetupColumnV")
    auto label = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    auto init_width_or_weight = receiveValue<float>();
    auto user_id = receiveValue<uint32_t>();
    {
    ImGui::TableSetupColumn(label, flags, init_width_or_weight, user_id);
  }
  }
  break;
case 0x00000182:
  {
    FFFI_FUNCTION_INVOCATION("TableSetupScrollFreeze")
    auto cols = receiveValueSignMagnitude<int>();
    auto rows = receiveValueSignMagnitude<int>();
    {
    ImGui::TableSetupScrollFreeze(cols, rows);
  }
  }
  break;
case 0x00000183:
  {
    FFFI_FUNCTION_INVOCATION("TableHeader")
    auto label = receiveString();
    {
    ImGui::TableHeader(label);
  }
  }
  break;
case 0x00000184:
  {
    FFFI_FUNCTION_INVOCATION("TableHeadersRow")
    {
    ImGui::TableHeadersRow();
  }
  }
  break;
case 0x00000185:
  {
    FFFI_FUNCTION_INVOCATION("TableAngledHeadersRow")
    {
    ImGui::TableAngledHeadersRow();
  }
  }
  break;
case 0x00000186:
  {
    FFFI_FUNCTION_INVOCATION("TableGetColumnCount")
    int r;
    {
    auto r = ImGui::TableGetColumnCount();
    sendValueSignMagnitude<int>(r);
    flushSend();
  }
  }
  break;
case 0x00000187:
  {
    FFFI_FUNCTION_INVOCATION("TableGetColumnIndex")
    int r;
    {
    auto r = ImGui::TableGetColumnIndex();
    sendValueSignMagnitude<int>(r);
    flushSend();
  }
  }
  break;
case 0x00000188:
  {
    FFFI_FUNCTION_INVOCATION("TableGetRowIndex")
    int r;
    {
    auto r = ImGui::TableGetRowIndex();
    sendValueSignMagnitude<int>(r);
    flushSend();
  }
  }
  break;
case 0x00000189:
  {
    FFFI_FUNCTION_INVOCATION("TableGetColumnName")
    const char * r;
    {
    auto r = ImGui::TableGetColumnName();
    sendString(r);
    flushSend();
  }
  }
  break;
case 0x0000018a:
  {
    FFFI_FUNCTION_INVOCATION("TableGetColumnNameV")
    auto column_n = receiveValueSignMagnitude<int>();
    const char * r;
    {
    auto r = ImGui::TableGetColumnName(column_n);
    sendString(r);
    flushSend();
  }
  }
  break;
case 0x0000018b:
  {
    FFFI_FUNCTION_INVOCATION("TableGetColumnFlags")
    int r;
    {
    auto r = ImGui::TableGetColumnFlags();
    sendValueSignMagnitude<int>(r);
    flushSend();
  }
  }
  break;
case 0x0000018c:
  {
    FFFI_FUNCTION_INVOCATION("TableGetColumnFlagsV")
    auto column_n = receiveValueSignMagnitude<int>();
    int r;
    {
    auto r = ImGui::TableGetColumnFlags(column_n);
    sendValueSignMagnitude<int>(r);
    flushSend();
  }
  }
  break;
case 0x0000018d:
  {
    FFFI_FUNCTION_INVOCATION("TableSetColumnEnabled")
    auto column_n = receiveValueSignMagnitude<int>();
    auto v = receiveValue<bool>();
    {
    ImGui::TableSetColumnEnabled(column_n, v);
  }
  }
  break;
case 0x0000018e:
  {
    FFFI_FUNCTION_INVOCATION("TableGetHoveredColumn")
    int r;
    {
    auto r = ImGui::TableGetHoveredColumn();
    sendValueSignMagnitude<int>(r);
    flushSend();
  }
  }
  break;
case 0x0000018f:
  {
    FFFI_FUNCTION_INVOCATION("TableSetBgColor")
    auto target = receiveValueSignMagnitude<int>();
    auto color = receiveValue<uint32_t>();
    {
    ImGui::TableSetBgColor(target, color);
  }
  }
  break;
case 0x00000190:
  {
    FFFI_FUNCTION_INVOCATION("TableSetBgColorV")
    auto target = receiveValueSignMagnitude<int>();
    auto color = receiveValue<uint32_t>();
    auto column_n = receiveValueSignMagnitude<int>();
    {
    ImGui::TableSetBgColor(target, color, column_n);
  }
  }
  break;
case 0x00000191:
  {
    FFFI_FUNCTION_INVOCATION("Columns")
    {
    ImGui::Columns();
  }
  }
  break;
case 0x00000192:
  {
    FFFI_FUNCTION_INVOCATION("ColumnsV")
    auto count = receiveValueSignMagnitude<int>();
    auto id = receiveString();
    auto borders = receiveValue<bool>();
    {
    ImGui::Columns(count, id, borders);
  }
  }
  break;
case 0x00000193:
  {
    FFFI_FUNCTION_INVOCATION("NextColumn")
    {
    ImGui::NextColumn();
  }
  }
  break;
case 0x00000194:
  {
    FFFI_FUNCTION_INVOCATION("GetColumnIndex")
    int r;
    {
    auto r = ImGui::GetColumnIndex();
    sendValueSignMagnitude<int>(r);
    flushSend();
  }
  }
  break;
case 0x00000195:
  {
    FFFI_FUNCTION_INVOCATION("GetColumnWidth")
    float r;
    {
    auto r = ImGui::GetColumnWidth();
    sendValue<float>(r);
    flushSend();
  }
  }
  break;
case 0x00000196:
  {
    FFFI_FUNCTION_INVOCATION("GetColumnWidthV")
    auto column_index = receiveValueSignMagnitude<int>();
    float r;
    {
    auto r = ImGui::GetColumnWidth(column_index);
    sendValue<float>(r);
    flushSend();
  }
  }
  break;
case 0x00000197:
  {
    FFFI_FUNCTION_INVOCATION("SetColumnWidth")
    auto column_index = receiveValueSignMagnitude<int>();
    auto width = receiveValue<float>();
    {
    ImGui::SetColumnWidth(column_index, width);
  }
  }
  break;
case 0x00000198:
  {
    FFFI_FUNCTION_INVOCATION("GetColumnOffset")
    float r;
    {
    auto r = ImGui::GetColumnOffset();
    sendValue<float>(r);
    flushSend();
  }
  }
  break;
case 0x00000199:
  {
    FFFI_FUNCTION_INVOCATION("GetColumnOffsetV")
    auto column_index = receiveValueSignMagnitude<int>();
    float r;
    {
    auto r = ImGui::GetColumnOffset(column_index);
    sendValue<float>(r);
    flushSend();
  }
  }
  break;
case 0x0000019a:
  {
    FFFI_FUNCTION_INVOCATION("SetColumnOffset")
    auto column_index = receiveValueSignMagnitude<int>();
    auto offset_x = receiveValue<float>();
    {
    ImGui::SetColumnOffset(column_index, offset_x);
  }
  }
  break;
case 0x0000019b:
  {
    FFFI_FUNCTION_INVOCATION("GetColumnsCount")
    int r;
    {
    auto r = ImGui::GetColumnsCount();
    sendValueSignMagnitude<int>(r);
    flushSend();
  }
  }
  break;
case 0x0000019c:
  {
    FFFI_FUNCTION_INVOCATION("BeginTabBar")
    auto str_id = receiveString();
    bool r;
    {
    auto r = ImGui::BeginTabBar(str_id);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x0000019d:
  {
    FFFI_FUNCTION_INVOCATION("BeginTabBarV")
    auto str_id = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    bool r;
    {
    auto r = ImGui::BeginTabBar(str_id, flags);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x0000019e:
  {
    FFFI_FUNCTION_INVOCATION("EndTabBar")
    {
    ImGui::EndTabBar();
  }
  }
  break;
case 0x0000019f:
  {
    FFFI_FUNCTION_INVOCATION("BeginTabItem")
    auto label = receiveString();
    bool r;
    {
    auto r = ImGui::BeginTabItem(label);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000001a0:
  {
    FFFI_FUNCTION_INVOCATION("BeginTabItemV")
    auto label = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    bool r;
    bool p_open;
    {
    p_open = true; /* see issue #5 */
auto r = ImGui::BeginTabItem(label, &p_open, flags);
    sendValue<bool>(r);
    sendValue<bool>(p_open);
    flushSend();
  }
  }
  break;
case 0x000001a1:
  {
    FFFI_FUNCTION_INVOCATION("EndTabItem")
    {
    ImGui::EndTabItem();
  }
  }
  break;
case 0x000001a2:
  {
    FFFI_FUNCTION_INVOCATION("TabItemButton")
    auto label = receiveString();
    bool r;
    {
    auto r = ImGui::TabItemButton(label);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000001a3:
  {
    FFFI_FUNCTION_INVOCATION("TabItemButtonV")
    auto label = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    bool r;
    {
    auto r = ImGui::TabItemButton(label, flags);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000001a4:
  {
    FFFI_FUNCTION_INVOCATION("SetTabItemClosed")
    auto tab_or_docked_window_label = receiveString();
    {
    ImGui::SetTabItemClosed(tab_or_docked_window_label);
  }
  }
  break;
case 0x000001a5:
  {
    FFFI_FUNCTION_INVOCATION("DockSpace")
    auto dockspace_id = receiveValue<uint32_t>();
    uint32_t r;
    {
    auto r = ImGui::DockSpace(dockspace_id);
    sendValue<uint32_t>(r);
    flushSend();
  }
  }
  break;
case 0x000001a6:
  {
    FFFI_FUNCTION_INVOCATION("DockSpaceOverViewport")
    uint32_t r;
    {
    auto r = ImGui::DockSpaceOverViewport();
    sendValue<uint32_t>(r);
    flushSend();
  }
  }
  break;
case 0x000001a7:
  {
    FFFI_FUNCTION_INVOCATION("SetNextWindowDockID")
    auto dock_id = receiveValue<uint32_t>();
    {
    ImGui::SetNextWindowDockID(dock_id);
  }
  }
  break;
case 0x000001a8:
  {
    FFFI_FUNCTION_INVOCATION("SetNextWindowDockIDV")
    auto dock_id = receiveValue<uint32_t>();
    auto cond = receiveValueSignMagnitude<int>();
    {
    ImGui::SetNextWindowDockID(dock_id, cond);
  }
  }
  break;
case 0x000001a9:
  {
    FFFI_FUNCTION_INVOCATION("GetWindowDockID")
    uint32_t r;
    {
    auto r = ImGui::GetWindowDockID();
    sendValue<uint32_t>(r);
    flushSend();
  }
  }
  break;
case 0x000001aa:
  {
    FFFI_FUNCTION_INVOCATION("IsWindowDocked")
    bool r;
    {
    auto r = ImGui::IsWindowDocked();
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000001ab:
  {
    FFFI_FUNCTION_INVOCATION("LogToTTY")
    {
    ImGui::LogToTTY();
  }
  }
  break;
case 0x000001ac:
  {
    FFFI_FUNCTION_INVOCATION("LogToTTYV")
    auto auto_open_depth = receiveValueSignMagnitude<int>();
    {
    ImGui::LogToTTY(auto_open_depth);
  }
  }
  break;
case 0x000001ad:
  {
    FFFI_FUNCTION_INVOCATION("LogToFile")
    {
    ImGui::LogToFile();
  }
  }
  break;
case 0x000001ae:
  {
    FFFI_FUNCTION_INVOCATION("LogToFileV")
    auto auto_open_depth = receiveValueSignMagnitude<int>();
    auto filename = receiveString();
    {
    ImGui::LogToFile(auto_open_depth, filename);
  }
  }
  break;
case 0x000001af:
  {
    FFFI_FUNCTION_INVOCATION("LogToClipboard")
    {
    ImGui::LogToClipboard();
  }
  }
  break;
case 0x000001b0:
  {
    FFFI_FUNCTION_INVOCATION("LogToClipboardV")
    auto auto_open_depth = receiveValueSignMagnitude<int>();
    {
    ImGui::LogToClipboard(auto_open_depth);
  }
  }
  break;
case 0x000001b1:
  {
    FFFI_FUNCTION_INVOCATION("LogFinish")
    {
    ImGui::LogFinish();
  }
  }
  break;
case 0x000001b2:
  {
    FFFI_FUNCTION_INVOCATION("LogButtons")
    {
    ImGui::LogButtons();
  }
  }
  break;
case 0x000001b3:
  {
    FFFI_FUNCTION_INVOCATION("BeginDragDropSource")
    bool r;
    {
    auto r = ImGui::BeginDragDropSource();
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000001b4:
  {
    FFFI_FUNCTION_INVOCATION("BeginDragDropSourceV")
    auto flags = receiveValueSignMagnitude<int>();
    bool r;
    {
    auto r = ImGui::BeginDragDropSource(flags);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000001b5:
  {
    FFFI_FUNCTION_INVOCATION("EndDragDropSource")
    {
    ImGui::EndDragDropSource();
  }
  }
  break;
case 0x000001b6:
  {
    FFFI_FUNCTION_INVOCATION("BeginDragDropTarget")
    bool r;
    {
    auto r = ImGui::BeginDragDropTarget();
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000001b7:
  {
    FFFI_FUNCTION_INVOCATION("EndDragDropTarget")
    {
    ImGui::EndDragDropTarget();
  }
  }
  break;
case 0x000001b8:
  {
    FFFI_FUNCTION_INVOCATION("BeginDisabled")
    {
    ImGui::BeginDisabled();
  }
  }
  break;
case 0x000001b9:
  {
    FFFI_FUNCTION_INVOCATION("BeginDisabledV")
    auto disabled = receiveValue<bool>();
    {
    ImGui::BeginDisabled(disabled);
  }
  }
  break;
case 0x000001ba:
  {
    FFFI_FUNCTION_INVOCATION("EndDisabled")
    {
    ImGui::EndDisabled();
  }
  }
  break;
case 0x000001bb:
  {
    FFFI_FUNCTION_INVOCATION("PushClipRect")
    auto clip_rect_min = receiveArray<float,2>();
    auto clip_rect_max = receiveArray<float,2>();
    auto intersect_with_current_clip_rect = receiveValue<bool>();
    {
    ImGui::PushClipRect(clip_rect_min, clip_rect_max, intersect_with_current_clip_rect);
  }
  }
  break;
case 0x000001bc:
  {
    FFFI_FUNCTION_INVOCATION("PopClipRect")
    {
    ImGui::PopClipRect();
  }
  }
  break;
case 0x000001bd:
  {
    FFFI_FUNCTION_INVOCATION("SetItemDefaultFocus")
    {
    ImGui::SetItemDefaultFocus();
  }
  }
  break;
case 0x000001be:
  {
    FFFI_FUNCTION_INVOCATION("SetKeyboardFocusHere")
    {
    ImGui::SetKeyboardFocusHere();
  }
  }
  break;
case 0x000001bf:
  {
    FFFI_FUNCTION_INVOCATION("SetKeyboardFocusHereV")
    auto offset = receiveValueSignMagnitude<int>();
    {
    ImGui::SetKeyboardFocusHere(offset);
  }
  }
  break;
case 0x000001c0:
  {
    FFFI_FUNCTION_INVOCATION("SetNavCursorVisible")
    auto visible = receiveValue<bool>();
    {
    ImGui::SetNavCursorVisible(visible);
  }
  }
  break;
case 0x000001c1:
  {
    FFFI_FUNCTION_INVOCATION("SetNextItemAllowOverlap")
    {
    ImGui::SetNextItemAllowOverlap();
  }
  }
  break;
case 0x000001c2:
  {
    FFFI_FUNCTION_INVOCATION("IsItemHovered")
    bool r;
    {
    auto r = ImGui::IsItemHovered();
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000001c3:
  {
    FFFI_FUNCTION_INVOCATION("IsItemHoveredV")
    auto flags = receiveValueSignMagnitude<int>();
    bool r;
    {
    auto r = ImGui::IsItemHovered(flags);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000001c4:
  {
    FFFI_FUNCTION_INVOCATION("IsItemActive")
    bool r;
    {
    auto r = ImGui::IsItemActive();
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000001c5:
  {
    FFFI_FUNCTION_INVOCATION("IsItemFocused")
    bool r;
    {
    auto r = ImGui::IsItemFocused();
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000001c6:
  {
    FFFI_FUNCTION_INVOCATION("IsItemClicked")
    bool r;
    {
    auto r = ImGui::IsItemClicked();
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000001c7:
  {
    FFFI_FUNCTION_INVOCATION("IsItemClickedV")
    auto mouse_button = receiveValueSignMagnitude<int>();
    bool r;
    {
    auto r = ImGui::IsItemClicked(mouse_button);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000001c8:
  {
    FFFI_FUNCTION_INVOCATION("IsItemVisible")
    bool r;
    {
    auto r = ImGui::IsItemVisible();
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000001c9:
  {
    FFFI_FUNCTION_INVOCATION("IsItemEdited")
    bool r;
    {
    auto r = ImGui::IsItemEdited();
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000001ca:
  {
    FFFI_FUNCTION_INVOCATION("IsItemActivated")
    bool r;
    {
    auto r = ImGui::IsItemActivated();
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000001cb:
  {
    FFFI_FUNCTION_INVOCATION("IsItemDeactivated")
    bool r;
    {
    auto r = ImGui::IsItemDeactivated();
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000001cc:
  {
    FFFI_FUNCTION_INVOCATION("IsItemDeactivatedAfterEdit")
    bool r;
    {
    auto r = ImGui::IsItemDeactivatedAfterEdit();
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000001cd:
  {
    FFFI_FUNCTION_INVOCATION("IsItemToggledOpen")
    bool r;
    {
    auto r = ImGui::IsItemToggledOpen();
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000001ce:
  {
    FFFI_FUNCTION_INVOCATION("IsAnyItemHovered")
    bool r;
    {
    auto r = ImGui::IsAnyItemHovered();
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000001cf:
  {
    FFFI_FUNCTION_INVOCATION("IsAnyItemActive")
    bool r;
    {
    auto r = ImGui::IsAnyItemActive();
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000001d0:
  {
    FFFI_FUNCTION_INVOCATION("IsAnyItemFocused")
    bool r;
    {
    auto r = ImGui::IsAnyItemFocused();
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000001d1:
  {
    FFFI_FUNCTION_INVOCATION("GetItemID")
    uint32_t r;
    {
    auto r = ImGui::GetItemID();
    sendValue<uint32_t>(r);
    flushSend();
  }
  }
  break;
case 0x000001d2:
  {
    FFFI_FUNCTION_INVOCATION("GetItemRectMin")
    float* r;
    {
    auto r = ImGui::GetItemRectMin();
    sendArray<float,2>(r);
    flushSend();
  }
  }
  break;
case 0x000001d3:
  {
    FFFI_FUNCTION_INVOCATION("GetItemRectMax")
    float* r;
    {
    auto r = ImGui::GetItemRectMax();
    sendArray<float,2>(r);
    flushSend();
  }
  }
  break;
case 0x000001d4:
  {
    FFFI_FUNCTION_INVOCATION("GetItemRectSize")
    float* r;
    {
    auto r = ImGui::GetItemRectSize();
    sendArray<float,2>(r);
    flushSend();
  }
  }
  break;
case 0x000001d5:
  {
    FFFI_FUNCTION_INVOCATION("GetBackgroundDrawList")
    uintptr_t r;
    {
    auto r = ImGui::GetBackgroundDrawList();
    sendValue(r);
    flushSend();
  }
  }
  break;
case 0x000001d6:
  {
    FFFI_FUNCTION_INVOCATION("GetForegroundDrawList")
    uintptr_t r;
    {
    auto r = ImGui::GetForegroundDrawList();
    sendValue(r);
    flushSend();
  }
  }
  break;
case 0x000001d7:
  {
    FFFI_FUNCTION_INVOCATION("IsRectVisible")
    auto size = receiveArray<float,2>();
    bool r;
    {
    auto r = ImGui::IsRectVisible(size);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000001d8:
  {
    FFFI_FUNCTION_INVOCATION("IsRectVisible2")
    auto rect_min = receiveArray<float,2>();
    auto rect_max = receiveArray<float,2>();
    bool r;
    {
    auto r = ImGui::IsRectVisible(rect_min, rect_max);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000001d9:
  {
    FFFI_FUNCTION_INVOCATION("GetTime")
    double r;
    {
    auto r = ImGui::GetTime();
    sendValue<double>(r);
    flushSend();
  }
  }
  break;
case 0x000001da:
  {
    FFFI_FUNCTION_INVOCATION("GetFrameCount")
    int r;
    {
    auto r = ImGui::GetFrameCount();
    sendValueSignMagnitude<int>(r);
    flushSend();
  }
  }
  break;
case 0x000001db:
  {
    FFFI_FUNCTION_INVOCATION("GetStyleColorName")
    auto idx = receiveValueSignMagnitude<int>();
    const char * r;
    {
    auto r = ImGui::GetStyleColorName(idx);
    sendString(r);
    flushSend();
  }
  }
  break;
case 0x000001dc:
  {
    FFFI_FUNCTION_INVOCATION("ColorConvertU32ToFloat4")
    auto in = receiveValue<uint32_t>();
    float* r;
    {
    auto r = ImGui::ColorConvertU32ToFloat4(in);
    sendArray<float,4>(r);
    flushSend();
  }
  }
  break;
case 0x000001dd:
  {
    FFFI_FUNCTION_INVOCATION("ColorConvertFloat4ToU32")
    auto in = receiveArray<float,4>();
    uint32_t r;
    {
    auto r = ImGui::ColorConvertFloat4ToU32(in);
    sendValue<uint32_t>(r);
    flushSend();
  }
  }
  break;
case 0x000001de:
  {
    FFFI_FUNCTION_INVOCATION("IsKeyDown")
    auto key = receiveValueSignMagnitude<int>();
    bool r;
    {
    auto r = ImGui::IsKeyDown(ImGuiKey(key));
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000001df:
  {
    FFFI_FUNCTION_INVOCATION("IsKeyPressed")
    auto key = receiveValueSignMagnitude<int>();
    bool r;
    {
    auto r = ImGui::IsKeyPressed(ImGuiKey(key));
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000001e0:
  {
    FFFI_FUNCTION_INVOCATION("IsKeyPressedV")
    auto key = receiveValueSignMagnitude<int>();
    auto repeat = receiveValue<bool>();
    bool r;
    {
    auto r = ImGui::IsKeyPressed(ImGuiKey(key), repeat);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000001e1:
  {
    FFFI_FUNCTION_INVOCATION("IsKeyReleased")
    auto key = receiveValueSignMagnitude<int>();
    bool r;
    {
    auto r = ImGui::IsKeyReleased(ImGuiKey(key));
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000001e2:
  {
    FFFI_FUNCTION_INVOCATION("GetKeyPressedAmount")
    auto key = receiveValueSignMagnitude<int>();
    auto repeat_delay = receiveValue<float>();
    auto rate = receiveValue<float>();
    int r;
    {
    auto r = ImGui::GetKeyPressedAmount(ImGuiKey(key), repeat_delay, rate);
    sendValueSignMagnitude<int>(r);
    flushSend();
  }
  }
  break;
case 0x000001e3:
  {
    FFFI_FUNCTION_INVOCATION("GetKeyName")
    auto key = receiveValueSignMagnitude<int>();
    const char * r;
    {
    auto r = ImGui::GetKeyName(ImGuiKey(key));
    sendString(r);
    flushSend();
  }
  }
  break;
case 0x000001e4:
  {
    FFFI_FUNCTION_INVOCATION("SetNextFrameWantCaptureKeyboard")
    auto want_capture_keyboard = receiveValue<bool>();
    {
    ImGui::SetNextFrameWantCaptureKeyboard(want_capture_keyboard);
  }
  }
  break;
case 0x000001e5:
  {
    FFFI_FUNCTION_INVOCATION("SetItemKeyOwner")
    auto key = receiveValueSignMagnitude<int>();
    {
    ImGui::SetItemKeyOwner(ImGuiKey(key));
  }
  }
  break;
case 0x000001e6:
  {
    FFFI_FUNCTION_INVOCATION("IsMouseDown")
    auto button = receiveValueSignMagnitude<int>();
    bool r;
    {
    auto r = ImGui::IsMouseDown(button);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000001e7:
  {
    FFFI_FUNCTION_INVOCATION("IsMouseClicked")
    auto button = receiveValueSignMagnitude<int>();
    bool r;
    {
    auto r = ImGui::IsMouseClicked(button);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000001e8:
  {
    FFFI_FUNCTION_INVOCATION("IsMouseClickedV")
    auto button = receiveValueSignMagnitude<int>();
    auto repeat = receiveValue<bool>();
    bool r;
    {
    auto r = ImGui::IsMouseClicked(button, repeat);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000001e9:
  {
    FFFI_FUNCTION_INVOCATION("IsMouseReleased")
    auto button = receiveValueSignMagnitude<int>();
    bool r;
    {
    auto r = ImGui::IsMouseReleased(button);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000001ea:
  {
    FFFI_FUNCTION_INVOCATION("IsMouseDoubleClicked")
    auto button = receiveValueSignMagnitude<int>();
    bool r;
    {
    auto r = ImGui::IsMouseDoubleClicked(button);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000001eb:
  {
    FFFI_FUNCTION_INVOCATION("IsMouseReleasedWithDelay")
    auto button = receiveValueSignMagnitude<int>();
    auto delay = receiveValue<float>();
    bool r;
    {
    auto r = ImGui::IsMouseReleasedWithDelay(button, delay);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000001ec:
  {
    FFFI_FUNCTION_INVOCATION("GetMouseClickedCount")
    auto button = receiveValueSignMagnitude<int>();
    int r;
    {
    auto r = ImGui::GetMouseClickedCount(button);
    sendValueSignMagnitude<int>(r);
    flushSend();
  }
  }
  break;
case 0x000001ed:
  {
    FFFI_FUNCTION_INVOCATION("IsMouseHoveringRect")
    auto r_min = receiveArray<float,2>();
    auto r_max = receiveArray<float,2>();
    bool r;
    {
    auto r = ImGui::IsMouseHoveringRect(r_min, r_max);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000001ee:
  {
    FFFI_FUNCTION_INVOCATION("IsMouseHoveringRectV")
    auto r_min = receiveArray<float,2>();
    auto r_max = receiveArray<float,2>();
    auto clip = receiveValue<bool>();
    bool r;
    {
    auto r = ImGui::IsMouseHoveringRect(r_min, r_max, clip);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000001ef:
  {
    FFFI_FUNCTION_INVOCATION("IsMousePosValid")
    bool r;
    {
    auto r = ImGui::IsMousePosValid();
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000001f0:
  {
    FFFI_FUNCTION_INVOCATION("GetMousePos")
    float* r;
    {
    auto r = ImGui::GetMousePos();
    sendArray<float,2>(r);
    flushSend();
  }
  }
  break;
case 0x000001f1:
  {
    FFFI_FUNCTION_INVOCATION("GetMousePosOnOpeningCurrentPopup")
    float* r;
    {
    auto r = ImGui::GetMousePosOnOpeningCurrentPopup();
    sendArray<float,2>(r);
    flushSend();
  }
  }
  break;
case 0x000001f2:
  {
    FFFI_FUNCTION_INVOCATION("IsMouseDragging")
    auto button = receiveValueSignMagnitude<int>();
    bool r;
    {
    auto r = ImGui::IsMouseDragging(button);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000001f3:
  {
    FFFI_FUNCTION_INVOCATION("IsMouseDraggingV")
    auto button = receiveValueSignMagnitude<int>();
    auto lock_threshold = receiveValue<float>();
    bool r;
    {
    auto r = ImGui::IsMouseDragging(button, lock_threshold);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000001f4:
  {
    FFFI_FUNCTION_INVOCATION("GetMouseDragDelta")
    float* r;
    {
    auto r = ImGui::GetMouseDragDelta();
    sendArray<float,2>(r);
    flushSend();
  }
  }
  break;
case 0x000001f5:
  {
    FFFI_FUNCTION_INVOCATION("GetMouseDragDeltaV")
    auto button = receiveValueSignMagnitude<int>();
    auto lock_threshold = receiveValue<float>();
    float* r;
    {
    auto r = ImGui::GetMouseDragDelta(button, lock_threshold);
    sendArray<float,2>(r);
    flushSend();
  }
  }
  break;
case 0x000001f6:
  {
    FFFI_FUNCTION_INVOCATION("ResetMouseDragDelta")
    {
    ImGui::ResetMouseDragDelta();
  }
  }
  break;
case 0x000001f7:
  {
    FFFI_FUNCTION_INVOCATION("ResetMouseDragDeltaV")
    auto button = receiveValueSignMagnitude<int>();
    {
    ImGui::ResetMouseDragDelta(button);
  }
  }
  break;
case 0x000001f8:
  {
    FFFI_FUNCTION_INVOCATION("GetMouseCursor")
    int r;
    {
    auto r = ImGui::GetMouseCursor();
    sendValueSignMagnitude<int>(r);
    flushSend();
  }
  }
  break;
case 0x000001f9:
  {
    FFFI_FUNCTION_INVOCATION("SetMouseCursor")
    auto cursor_type = receiveValueSignMagnitude<int>();
    {
    ImGui::SetMouseCursor(cursor_type);
  }
  }
  break;
case 0x000001fa:
  {
    FFFI_FUNCTION_INVOCATION("SetNextFrameWantCaptureMouse")
    auto want_capture_mouse = receiveValue<bool>();
    {
    ImGui::SetNextFrameWantCaptureMouse(want_capture_mouse);
  }
  }
  break;
case 0x000001fb:
  {
    FFFI_FUNCTION_INVOCATION("GetClipboardText")
    const char * r;
    {
    auto r = ImGui::GetClipboardText();
    sendString(r);
    flushSend();
  }
  }
  break;
case 0x000001fc:
  {
    FFFI_FUNCTION_INVOCATION("SetClipboardText")
    auto text = receiveString();
    {
    ImGui::SetClipboardText(text);
  }
  }
  break;
case 0x000001fd:
  {
    FFFI_FUNCTION_INVOCATION("LoadIniSettingsFromDisk")
    auto ini_filename = receiveString();
    {
    ImGui::LoadIniSettingsFromDisk(ini_filename);
  }
  }
  break;
case 0x000001fe:
  {
    FFFI_FUNCTION_INVOCATION("LoadIniSettingsFromMemory")
    auto ini_data = receiveString();
    {
    ImGui::LoadIniSettingsFromMemory(ini_data);
  }
  }
  break;
case 0x000001ff:
  {
    FFFI_FUNCTION_INVOCATION("LoadIniSettingsFromMemoryV")
    auto ini_data = receiveString();
    auto ini_size = receiveValue<uint64_t>();
    {
    ImGui::LoadIniSettingsFromMemory(ini_data, ini_size);
  }
  }
  break;
case 0x00000200:
  {
    FFFI_FUNCTION_INVOCATION("SaveIniSettingsToDisk")
    auto ini_filename = receiveString();
    {
    ImGui::SaveIniSettingsToDisk(ini_filename);
  }
  }
  break;
case 0x00000201:
  {
    FFFI_FUNCTION_INVOCATION("SaveIniSettingsToMemory")
    const char * r;
    {
    auto r = ImGui::SaveIniSettingsToMemory();
    sendString(r);
    flushSend();
  }
  }
  break;
case 0x00000202:
  {
    FFFI_FUNCTION_INVOCATION("DebugTextEncoding")
    auto text = receiveString();
    {
    ImGui::DebugTextEncoding(text);
  }
  }
  break;
case 0x00000203:
  {
    FFFI_FUNCTION_INVOCATION("DebugFlashStyleColor")
    auto idx = receiveValueSignMagnitude<int>();
    {
    ImGui::DebugFlashStyleColor(idx);
  }
  }
  break;
case 0x00000204:
  {
    FFFI_FUNCTION_INVOCATION("DebugStartItemPicker")
    {
    ImGui::DebugStartItemPicker();
  }
  }
  break;
case 0x00000205:
  {
    FFFI_FUNCTION_INVOCATION("DebugCheckVersionAndDataLayout")
    auto version_str = receiveString();
    auto sz_io = receiveValue<uint64_t>();
    auto sz_style = receiveValue<uint64_t>();
    auto sz_vec2 = receiveValue<uint64_t>();
    auto sz_vec4 = receiveValue<uint64_t>();
    auto sz_drawvert = receiveValue<uint64_t>();
    auto sz_drawidx = receiveValue<uint64_t>();
    bool r;
    {
    auto r = ImGui::DebugCheckVersionAndDataLayout(version_str, sz_io, sz_style, sz_vec2, sz_vec4, sz_drawvert, sz_drawidx);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000206:
  {
    FFFI_FUNCTION_INVOCATION("UpdatePlatformWindows")
    {
    ImGui::UpdatePlatformWindows();
  }
  }
  break;
case 0x00000207:
  {
    FFFI_FUNCTION_INVOCATION("RenderPlatformWindowsDefault")
    {
    ImGui::RenderPlatformWindowsDefault();
  }
  }
  break;
case 0x00000208:
  {
    FFFI_FUNCTION_INVOCATION("DestroyPlatformWindows")
    {
    ImGui::DestroyPlatformWindows();
  }
  }
  break;
case 0x00000209:
  {
    FFFI_FUNCTION_INVOCATION("GetContentRegionMax")
    float* r;
    {
    auto r = ImGui::GetContentRegionMax();
    sendArray<float,2>(r);
    flushSend();
  }
  }
  break;
case 0x0000020a:
  {
    FFFI_FUNCTION_INVOCATION("GetWindowContentRegionMin")
    float* r;
    {
    auto r = ImGui::GetWindowContentRegionMin();
    sendArray<float,2>(r);
    flushSend();
  }
  }
  break;
case 0x0000020b:
  {
    FFFI_FUNCTION_INVOCATION("GetWindowContentRegionMax")
    float* r;
    {
    auto r = ImGui::GetWindowContentRegionMax();
    sendArray<float,2>(r);
    flushSend();
  }
  }
  break;
case 0x0000020c:
  {
    FFFI_FUNCTION_INVOCATION("SetItemAllowOverlap")
    {
    ImGui::SetItemAllowOverlap();
  }
  }
  break;
case 0x0000020d:
  {
    FFFI_FUNCTION_INVOCATION("SetNextWindowRefreshPolicy")
    auto flags = receiveValueSignMagnitude<int>();
    {
    ImGui::SetNextWindowRefreshPolicy(flags);
  }
  }
  break;
case 0x0000020e:
  {
    FFFI_FUNCTION_INVOCATION("PushPasswordFont")
    {
    ImGui::PushPasswordFont();
  }
  }
  break;
case 0x0000020f:
  {
    FFFI_FUNCTION_INVOCATION("Initialize")
    {
    ImGui::Initialize();
  }
  }
  break;
case 0x00000210:
  {
    FFFI_FUNCTION_INVOCATION("UpdateInputEvents")
    auto trickle_fast_inputs = receiveValue<bool>();
    {
    ImGui::UpdateInputEvents(trickle_fast_inputs);
  }
  }
  break;
case 0x00000211:
  {
    FFFI_FUNCTION_INVOCATION("UpdateHoveredWindowAndCaptureFlags")
    {
    ImGui::UpdateHoveredWindowAndCaptureFlags();
  }
  }
  break;
case 0x00000212:
  {
    FFFI_FUNCTION_INVOCATION("UpdateMouseMovingWindowNewFrame")
    {
    ImGui::UpdateMouseMovingWindowNewFrame();
  }
  }
  break;
case 0x00000213:
  {
    FFFI_FUNCTION_INVOCATION("UpdateMouseMovingWindowEndFrame")
    {
    ImGui::UpdateMouseMovingWindowEndFrame();
  }
  }
  break;
case 0x00000214:
  {
    FFFI_FUNCTION_INVOCATION("MarkIniSettingsDirty")
    {
    ImGui::MarkIniSettingsDirty();
  }
  }
  break;
case 0x00000215:
  {
    FFFI_FUNCTION_INVOCATION("ClearIniSettings")
    {
    ImGui::ClearIniSettings();
  }
  }
  break;
case 0x00000216:
  {
    FFFI_FUNCTION_INVOCATION("RemoveSettingsHandler")
    auto type_name = receiveString();
    {
    ImGui::RemoveSettingsHandler(type_name);
  }
  }
  break;
case 0x00000217:
  {
    FFFI_FUNCTION_INVOCATION("ClearWindowSettings")
    auto name = receiveString();
    {
    ImGui::ClearWindowSettings(name);
  }
  }
  break;
case 0x00000218:
  {
    FFFI_FUNCTION_INVOCATION("ScrollToItem")
    {
    ImGui::ScrollToItem();
  }
  }
  break;
case 0x00000219:
  {
    FFFI_FUNCTION_INVOCATION("ScrollToItemV")
    auto flags = receiveValueSignMagnitude<int>();
    {
    ImGui::ScrollToItem(flags);
  }
  }
  break;
case 0x0000021a:
  {
    FFFI_FUNCTION_INVOCATION("ClearActiveID")
    {
    ImGui::ClearActiveID();
  }
  }
  break;
case 0x0000021b:
  {
    FFFI_FUNCTION_INVOCATION("GetHoveredID")
    uint32_t r;
    {
    auto r = ImGui::GetHoveredID();
    sendValue<uint32_t>(r);
    flushSend();
  }
  }
  break;
case 0x0000021c:
  {
    FFFI_FUNCTION_INVOCATION("SetHoveredID")
    auto id = receiveValue<uint32_t>();
    {
    ImGui::SetHoveredID(id);
  }
  }
  break;
case 0x0000021d:
  {
    FFFI_FUNCTION_INVOCATION("KeepAliveID")
    auto id = receiveValue<uint32_t>();
    {
    ImGui::KeepAliveID(id);
  }
  }
  break;
case 0x0000021e:
  {
    FFFI_FUNCTION_INVOCATION("MarkItemEdited")
    auto id = receiveValue<uint32_t>();
    {
    ImGui::MarkItemEdited(id);
  }
  }
  break;
case 0x0000021f:
  {
    FFFI_FUNCTION_INVOCATION("PushOverrideID")
    auto id = receiveValue<uint32_t>();
    {
    ImGui::PushOverrideID(id);
  }
  }
  break;
case 0x00000220:
  {
    FFFI_FUNCTION_INVOCATION("GetIDWithSeed")
    auto n = receiveValueSignMagnitude<int>();
    auto seed = receiveValue<uint32_t>();
    uint32_t r;
    {
    auto r = ImGui::GetIDWithSeed(n, seed);
    sendValue<uint32_t>(r);
    flushSend();
  }
  }
  break;
case 0x00000221:
  {
    FFFI_FUNCTION_INVOCATION("ItemSize")
    auto size = receiveArray<float,2>();
    {
    ImGui::ItemSize(size);
  }
  }
  break;
case 0x00000222:
  {
    FFFI_FUNCTION_INVOCATION("ItemSizeV")
    auto size = receiveArray<float,2>();
    auto text_baseline_y = receiveValue<float>();
    {
    ImGui::ItemSize(size, text_baseline_y);
  }
  }
  break;
case 0x00000223:
  {
    FFFI_FUNCTION_INVOCATION("CalcItemSize")
    auto size = receiveArray<float,2>();
    auto default_w = receiveValue<float>();
    auto default_h = receiveValue<float>();
    float* r;
    {
    auto r = ImGui::CalcItemSize(size, default_w, default_h);
    sendArray<float,2>(r);
    flushSend();
  }
  }
  break;
case 0x00000224:
  {
    FFFI_FUNCTION_INVOCATION("CalcWrapWidthForPos")
    auto pos = receiveArray<float,2>();
    auto wrap_pos_x = receiveValue<float>();
    float r;
    {
    auto r = ImGui::CalcWrapWidthForPos(pos, wrap_pos_x);
    sendValue<float>(r);
    flushSend();
  }
  }
  break;
case 0x00000225:
  {
    FFFI_FUNCTION_INVOCATION("PushMultiItemsWidths")
    auto components = receiveValueSignMagnitude<int>();
    auto width_full = receiveValue<float>();
    {
    ImGui::PushMultiItemsWidths(components, width_full);
  }
  }
  break;
case 0x00000226:
  {
    FFFI_FUNCTION_INVOCATION("BeginDisabledOverrideReenable")
    {
    ImGui::BeginDisabledOverrideReenable();
  }
  }
  break;
case 0x00000227:
  {
    FFFI_FUNCTION_INVOCATION("EndDisabledOverrideReenable")
    {
    ImGui::EndDisabledOverrideReenable();
  }
  }
  break;
case 0x00000228:
  {
    FFFI_FUNCTION_INVOCATION("LogBegin")
    auto flags = receiveValueSignMagnitude<int>();
    auto auto_open_depth = receiveValueSignMagnitude<int>();
    {
    ImGui::LogBegin(flags, auto_open_depth);
  }
  }
  break;
case 0x00000229:
  {
    FFFI_FUNCTION_INVOCATION("LogToBuffer")
    {
    ImGui::LogToBuffer();
  }
  }
  break;
case 0x0000022a:
  {
    FFFI_FUNCTION_INVOCATION("LogToBufferV")
    auto auto_open_depth = receiveValueSignMagnitude<int>();
    {
    ImGui::LogToBuffer(auto_open_depth);
  }
  }
  break;
case 0x0000022b:
  {
    FFFI_FUNCTION_INVOCATION("LogSetNextTextDecoration")
    auto prefix = receiveString();
    auto suffix = receiveString();
    {
    ImGui::LogSetNextTextDecoration(prefix, suffix);
  }
  }
  break;
case 0x0000022c:
  {
    FFFI_FUNCTION_INVOCATION("BeginChildEx")
    auto name = receiveString();
    auto id = receiveValue<uint32_t>();
    auto size_arg = receiveArray<float,2>();
    auto child_flags = receiveValueSignMagnitude<int>();
    auto window_flags = receiveValueSignMagnitude<int>();
    bool r;
    {
    auto r = ImGui::BeginChildEx(name, id, size_arg, child_flags, window_flags);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x0000022d:
  {
    FFFI_FUNCTION_INVOCATION("BeginPopupEx")
    auto id = receiveValue<uint32_t>();
    auto extra_window_flags = receiveValueSignMagnitude<int>();
    bool r;
    {
    auto r = ImGui::BeginPopupEx(id, extra_window_flags);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x0000022e:
  {
    FFFI_FUNCTION_INVOCATION("OpenPopupEx")
    auto id = receiveValue<uint32_t>();
    {
    ImGui::OpenPopupEx(id);
  }
  }
  break;
case 0x0000022f:
  {
    FFFI_FUNCTION_INVOCATION("OpenPopupExV")
    auto id = receiveValue<uint32_t>();
    auto popup_flags = receiveValueSignMagnitude<int>();
    {
    ImGui::OpenPopupEx(id, popup_flags);
  }
  }
  break;
case 0x00000230:
  {
    FFFI_FUNCTION_INVOCATION("ClosePopupToLevel")
    auto remaining = receiveValueSignMagnitude<int>();
    auto restore_focus_to_window_under_popup = receiveValue<bool>();
    {
    ImGui::ClosePopupToLevel(remaining, restore_focus_to_window_under_popup);
  }
  }
  break;
case 0x00000231:
  {
    FFFI_FUNCTION_INVOCATION("ClosePopupsExceptModals")
    {
    ImGui::ClosePopupsExceptModals();
  }
  }
  break;
case 0x00000232:
  {
    FFFI_FUNCTION_INVOCATION("IsPopupOpenIdI")
    auto id = receiveValue<uint32_t>();
    auto popup_flags = receiveValueSignMagnitude<int>();
    bool r;
    {
    auto r = ImGui::IsPopupOpen(id, popup_flags);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000233:
  {
    FFFI_FUNCTION_INVOCATION("BeginTooltipEx")
    auto tooltip_flags = receiveValueSignMagnitude<int>();
    auto extra_window_flags = receiveValueSignMagnitude<int>();
    bool r;
    {
    auto r = ImGui::BeginTooltipEx(tooltip_flags, extra_window_flags);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000234:
  {
    FFFI_FUNCTION_INVOCATION("BeginTooltipHidden")
    bool r;
    {
    auto r = ImGui::BeginTooltipHidden();
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000235:
  {
    FFFI_FUNCTION_INVOCATION("BeginMenuEx")
    auto label = receiveString();
    auto icon = receiveString();
    bool r;
    {
    auto r = ImGui::BeginMenuEx(label, icon);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000236:
  {
    FFFI_FUNCTION_INVOCATION("BeginMenuExV")
    auto label = receiveString();
    auto icon = receiveString();
    auto enabled = receiveValue<bool>();
    bool r;
    {
    auto r = ImGui::BeginMenuEx(label, icon, enabled);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000237:
  {
    FFFI_FUNCTION_INVOCATION("MenuItemEx")
    auto label = receiveString();
    auto icon = receiveString();
    bool r;
    {
    auto r = ImGui::MenuItemEx(label, icon);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000238:
  {
    FFFI_FUNCTION_INVOCATION("MenuItemExV")
    auto label = receiveString();
    auto icon = receiveString();
    auto shortcut = receiveString();
    auto selected = receiveValue<bool>();
    auto enabled = receiveValue<bool>();
    bool r;
    {
    auto r = ImGui::MenuItemEx(label, icon, shortcut, selected, enabled);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000239:
  {
    FFFI_FUNCTION_INVOCATION("BeginComboPreview")
    bool r;
    {
    auto r = ImGui::BeginComboPreview();
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x0000023a:
  {
    FFFI_FUNCTION_INVOCATION("EndComboPreview")
    {
    ImGui::EndComboPreview();
  }
  }
  break;
case 0x0000023b:
  {
    FFFI_FUNCTION_INVOCATION("NavInitRequestApplyResult")
    {
    ImGui::NavInitRequestApplyResult();
  }
  }
  break;
case 0x0000023c:
  {
    FFFI_FUNCTION_INVOCATION("NavMoveRequestButNoResultYet")
    bool r;
    {
    auto r = ImGui::NavMoveRequestButNoResultYet();
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x0000023d:
  {
    FFFI_FUNCTION_INVOCATION("NavMoveRequestSubmit")
    auto move_dir = receiveValueSignMagnitude<int>();
    auto clip_dir = receiveValueSignMagnitude<int>();
    auto move_flags = receiveValueSignMagnitude<int>();
    auto scroll_flags = receiveValueSignMagnitude<int>();
    {
    ImGui::NavMoveRequestSubmit(ImGuiDir(move_dir), ImGuiDir(clip_dir), move_flags, scroll_flags);
  }
  }
  break;
case 0x0000023e:
  {
    FFFI_FUNCTION_INVOCATION("NavMoveRequestForward")
    auto move_dir = receiveValueSignMagnitude<int>();
    auto clip_dir = receiveValueSignMagnitude<int>();
    auto move_flags = receiveValueSignMagnitude<int>();
    auto scroll_flags = receiveValueSignMagnitude<int>();
    {
    ImGui::NavMoveRequestForward(ImGuiDir(move_dir), ImGuiDir(clip_dir), move_flags, scroll_flags);
  }
  }
  break;
case 0x0000023f:
  {
    FFFI_FUNCTION_INVOCATION("NavMoveRequestCancel")
    {
    ImGui::NavMoveRequestCancel();
  }
  }
  break;
case 0x00000240:
  {
    FFFI_FUNCTION_INVOCATION("NavMoveRequestApplyResult")
    {
    ImGui::NavMoveRequestApplyResult();
  }
  }
  break;
case 0x00000241:
  {
    FFFI_FUNCTION_INVOCATION("NavHighlightActivated")
    auto id = receiveValue<uint32_t>();
    {
    ImGui::NavHighlightActivated(id);
  }
  }
  break;
case 0x00000242:
  {
    FFFI_FUNCTION_INVOCATION("SetNavCursorVisibleAfterMove")
    {
    ImGui::SetNavCursorVisibleAfterMove();
  }
  }
  break;
case 0x00000243:
  {
    FFFI_FUNCTION_INVOCATION("NavUpdateCurrentWindowIsScrollPushableX")
    {
    ImGui::NavUpdateCurrentWindowIsScrollPushableX();
  }
  }
  break;
case 0x00000244:
  {
    FFFI_FUNCTION_INVOCATION("SetNavFocusScope")
    auto focus_scope_id = receiveValue<uint32_t>();
    {
    ImGui::SetNavFocusScope(focus_scope_id);
  }
  }
  break;
case 0x00000245:
  {
    FFFI_FUNCTION_INVOCATION("FocusItem")
    {
    ImGui::FocusItem();
  }
  }
  break;
case 0x00000246:
  {
    FFFI_FUNCTION_INVOCATION("ActivateItemByID")
    auto id = receiveValue<uint32_t>();
    {
    ImGui::ActivateItemByID(id);
  }
  }
  break;
case 0x00000247:
  {
    FFFI_FUNCTION_INVOCATION("IsMouseDragPastThreshold")
    auto button = receiveValueSignMagnitude<int>();
    bool r;
    {
    auto r = ImGui::IsMouseDragPastThreshold(button);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000248:
  {
    FFFI_FUNCTION_INVOCATION("IsMouseDragPastThresholdV")
    auto button = receiveValueSignMagnitude<int>();
    auto lock_threshold = receiveValue<float>();
    bool r;
    {
    auto r = ImGui::IsMouseDragPastThreshold(button, lock_threshold);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000249:
  {
    FFFI_FUNCTION_INVOCATION("GetKeyMagnitude2d")
    auto key_left = receiveValueSignMagnitude<int>();
    auto key_right = receiveValueSignMagnitude<int>();
    auto key_up = receiveValueSignMagnitude<int>();
    auto key_down = receiveValueSignMagnitude<int>();
    float* r;
    {
    auto r = ImGui::GetKeyMagnitude2d(ImGuiKey(key_left), ImGuiKey(key_right), ImGuiKey(key_up), ImGuiKey(key_down));
    sendArray<float,2>(r);
    flushSend();
  }
  }
  break;
case 0x0000024a:
  {
    FFFI_FUNCTION_INVOCATION("CalcTypematicRepeatAmount")
    auto t0 = receiveValue<float>();
    auto t1 = receiveValue<float>();
    auto repeat_delay = receiveValue<float>();
    auto repeat_rate = receiveValue<float>();
    int r;
    {
    auto r = ImGui::CalcTypematicRepeatAmount(t0, t1, repeat_delay, repeat_rate);
    sendValueSignMagnitude<int>(r);
    flushSend();
  }
  }
  break;
case 0x0000024b:
  {
    FFFI_FUNCTION_INVOCATION("TeleportMousePos")
    auto pos = receiveArray<float,2>();
    {
    ImGui::TeleportMousePos(pos);
  }
  }
  break;
case 0x0000024c:
  {
    FFFI_FUNCTION_INVOCATION("SetActiveIdUsingAllKeyboardKeys")
    {
    ImGui::SetActiveIdUsingAllKeyboardKeys();
  }
  }
  break;
case 0x0000024d:
  {
    FFFI_FUNCTION_INVOCATION("GetKeyOwner")
    auto key = receiveValueSignMagnitude<int>();
    uint32_t r;
    {
    auto r = ImGui::GetKeyOwner(ImGuiKey(key));
    sendValue<uint32_t>(r);
    flushSend();
  }
  }
  break;
case 0x0000024e:
  {
    FFFI_FUNCTION_INVOCATION("SetKeyOwner")
    auto key = receiveValueSignMagnitude<int>();
    auto owner_id = receiveValue<uint32_t>();
    {
    ImGui::SetKeyOwner(ImGuiKey(key), owner_id);
  }
  }
  break;
case 0x0000024f:
  {
    FFFI_FUNCTION_INVOCATION("SetKeyOwnerV")
    auto key = receiveValueSignMagnitude<int>();
    auto owner_id = receiveValue<uint32_t>();
    auto flags = receiveValueSignMagnitude<int>();
    {
    ImGui::SetKeyOwner(ImGuiKey(key), owner_id, flags);
  }
  }
  break;
case 0x00000250:
  {
    FFFI_FUNCTION_INVOCATION("SetItemKeyOwnerI")
    auto key = receiveValueSignMagnitude<int>();
    auto flags = receiveValueSignMagnitude<int>();
    {
    ImGui::SetItemKeyOwner(ImGuiKey(key), flags);
  }
  }
  break;
case 0x00000251:
  {
    FFFI_FUNCTION_INVOCATION("TestKeyOwner")
    auto key = receiveValueSignMagnitude<int>();
    auto owner_id = receiveValue<uint32_t>();
    bool r;
    {
    auto r = ImGui::TestKeyOwner(ImGuiKey(key), owner_id);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000252:
  {
    FFFI_FUNCTION_INVOCATION("IsKeyDownI")
    auto key = receiveValueSignMagnitude<int>();
    auto owner_id = receiveValue<uint32_t>();
    bool r;
    {
    auto r = ImGui::IsKeyDown(ImGuiKey(key), owner_id);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000253:
  {
    FFFI_FUNCTION_INVOCATION("IsKeyPressedI")
    auto key = receiveValueSignMagnitude<int>();
    auto flags = receiveValueSignMagnitude<int>();
    bool r;
    {
    auto r = ImGui::IsKeyPressed(ImGuiKey(key), flags);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000254:
  {
    FFFI_FUNCTION_INVOCATION("IsKeyPressedVI")
    auto key = receiveValueSignMagnitude<int>();
    auto flags = receiveValueSignMagnitude<int>();
    auto owner_id = receiveValue<uint32_t>();
    bool r;
    {
    auto r = ImGui::IsKeyPressed(ImGuiKey(key), flags, owner_id);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000255:
  {
    FFFI_FUNCTION_INVOCATION("IsKeyReleasedI")
    auto key = receiveValueSignMagnitude<int>();
    auto owner_id = receiveValue<uint32_t>();
    bool r;
    {
    auto r = ImGui::IsKeyReleased(ImGuiKey(key), owner_id);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000256:
  {
    FFFI_FUNCTION_INVOCATION("IsMouseDownI")
    auto button = receiveValueSignMagnitude<int>();
    auto owner_id = receiveValue<uint32_t>();
    bool r;
    {
    auto r = ImGui::IsMouseDown(button, owner_id);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000257:
  {
    FFFI_FUNCTION_INVOCATION("IsMouseClickedI")
    auto button = receiveValueSignMagnitude<int>();
    auto flags = receiveValueSignMagnitude<int>();
    bool r;
    {
    auto r = ImGui::IsMouseClicked(button, flags);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000258:
  {
    FFFI_FUNCTION_INVOCATION("IsMouseClickedVI")
    auto button = receiveValueSignMagnitude<int>();
    auto flags = receiveValueSignMagnitude<int>();
    auto owner_id = receiveValue<uint32_t>();
    bool r;
    {
    auto r = ImGui::IsMouseClicked(button, flags, owner_id);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000259:
  {
    FFFI_FUNCTION_INVOCATION("IsMouseReleasedI")
    auto button = receiveValueSignMagnitude<int>();
    auto owner_id = receiveValue<uint32_t>();
    bool r;
    {
    auto r = ImGui::IsMouseReleased(button, owner_id);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x0000025a:
  {
    FFFI_FUNCTION_INVOCATION("IsMouseDoubleClickedI")
    auto button = receiveValueSignMagnitude<int>();
    auto owner_id = receiveValue<uint32_t>();
    bool r;
    {
    auto r = ImGui::IsMouseDoubleClicked(button, owner_id);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x0000025b:
  {
    FFFI_FUNCTION_INVOCATION("DockNodeEndAmendTabBar")
    {
    ImGui::DockNodeEndAmendTabBar();
  }
  }
  break;
case 0x0000025c:
  {
    FFFI_FUNCTION_INVOCATION("DockBuilderDockWindow")
    auto window_name = receiveString();
    auto node_id = receiveValue<uint32_t>();
    {
    ImGui::DockBuilderDockWindow(window_name, node_id);
  }
  }
  break;
case 0x0000025d:
  {
    FFFI_FUNCTION_INVOCATION("DockBuilderAddNode")
    uint32_t r;
    {
    auto r = ImGui::DockBuilderAddNode();
    sendValue<uint32_t>(r);
    flushSend();
  }
  }
  break;
case 0x0000025e:
  {
    FFFI_FUNCTION_INVOCATION("DockBuilderAddNodeV")
    auto node_id = receiveValue<uint32_t>();
    auto flags = receiveValueSignMagnitude<int>();
    uint32_t r;
    {
    auto r = ImGui::DockBuilderAddNode(node_id, flags);
    sendValue<uint32_t>(r);
    flushSend();
  }
  }
  break;
case 0x0000025f:
  {
    FFFI_FUNCTION_INVOCATION("DockBuilderRemoveNode")
    auto node_id = receiveValue<uint32_t>();
    {
    ImGui::DockBuilderRemoveNode(node_id);
  }
  }
  break;
case 0x00000260:
  {
    FFFI_FUNCTION_INVOCATION("DockBuilderRemoveNodeDockedWindows")
    auto node_id = receiveValue<uint32_t>();
    {
    ImGui::DockBuilderRemoveNodeDockedWindows(node_id);
  }
  }
  break;
case 0x00000261:
  {
    FFFI_FUNCTION_INVOCATION("DockBuilderRemoveNodeDockedWindowsV")
    auto node_id = receiveValue<uint32_t>();
    auto clear_settings_refs = receiveValue<bool>();
    {
    ImGui::DockBuilderRemoveNodeDockedWindows(node_id, clear_settings_refs);
  }
  }
  break;
case 0x00000262:
  {
    FFFI_FUNCTION_INVOCATION("DockBuilderRemoveNodeChildNodes")
    auto node_id = receiveValue<uint32_t>();
    {
    ImGui::DockBuilderRemoveNodeChildNodes(node_id);
  }
  }
  break;
case 0x00000263:
  {
    FFFI_FUNCTION_INVOCATION("DockBuilderSetNodePos")
    auto node_id = receiveValue<uint32_t>();
    auto pos = receiveArray<float,2>();
    {
    ImGui::DockBuilderSetNodePos(node_id, pos);
  }
  }
  break;
case 0x00000264:
  {
    FFFI_FUNCTION_INVOCATION("DockBuilderSetNodeSize")
    auto node_id = receiveValue<uint32_t>();
    auto size = receiveArray<float,2>();
    {
    ImGui::DockBuilderSetNodeSize(node_id, size);
  }
  }
  break;
case 0x00000265:
  {
    FFFI_FUNCTION_INVOCATION("DockBuilderCopyWindowSettings")
    auto src_name = receiveString();
    auto dst_name = receiveString();
    {
    ImGui::DockBuilderCopyWindowSettings(src_name, dst_name);
  }
  }
  break;
case 0x00000266:
  {
    FFFI_FUNCTION_INVOCATION("DockBuilderFinish")
    auto node_id = receiveValue<uint32_t>();
    {
    ImGui::DockBuilderFinish(node_id);
  }
  }
  break;
case 0x00000267:
  {
    FFFI_FUNCTION_INVOCATION("PushFocusScope")
    auto id = receiveValue<uint32_t>();
    {
    ImGui::PushFocusScope(id);
  }
  }
  break;
case 0x00000268:
  {
    FFFI_FUNCTION_INVOCATION("PopFocusScope")
    {
    ImGui::PopFocusScope();
  }
  }
  break;
case 0x00000269:
  {
    FFFI_FUNCTION_INVOCATION("IsDragDropActive")
    bool r;
    {
    auto r = ImGui::IsDragDropActive();
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x0000026a:
  {
    FFFI_FUNCTION_INVOCATION("ClearDragDrop")
    {
    ImGui::ClearDragDrop();
  }
  }
  break;
case 0x0000026b:
  {
    FFFI_FUNCTION_INVOCATION("IsDragDropPayloadBeingAccepted")
    bool r;
    {
    auto r = ImGui::IsDragDropPayloadBeingAccepted();
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x0000026c:
  {
    FFFI_FUNCTION_INVOCATION("BeginColumns")
    auto str_id = receiveString();
    auto count = receiveValueSignMagnitude<int>();
    {
    ImGui::BeginColumns(str_id, count);
  }
  }
  break;
case 0x0000026d:
  {
    FFFI_FUNCTION_INVOCATION("BeginColumnsV")
    auto str_id = receiveString();
    auto count = receiveValueSignMagnitude<int>();
    auto flags = receiveValueSignMagnitude<int>();
    {
    ImGui::BeginColumns(str_id, count, flags);
  }
  }
  break;
case 0x0000026e:
  {
    FFFI_FUNCTION_INVOCATION("EndColumns")
    {
    ImGui::EndColumns();
  }
  }
  break;
case 0x0000026f:
  {
    FFFI_FUNCTION_INVOCATION("PushColumnClipRect")
    auto column_index = receiveValueSignMagnitude<int>();
    {
    ImGui::PushColumnClipRect(column_index);
  }
  }
  break;
case 0x00000270:
  {
    FFFI_FUNCTION_INVOCATION("PushColumnsBackground")
    {
    ImGui::PushColumnsBackground();
  }
  }
  break;
case 0x00000271:
  {
    FFFI_FUNCTION_INVOCATION("PopColumnsBackground")
    {
    ImGui::PopColumnsBackground();
  }
  }
  break;
case 0x00000272:
  {
    FFFI_FUNCTION_INVOCATION("GetColumnsID")
    auto str_id = receiveString();
    auto count = receiveValueSignMagnitude<int>();
    uint32_t r;
    {
    auto r = ImGui::GetColumnsID(str_id, count);
    sendValue<uint32_t>(r);
    flushSend();
  }
  }
  break;
case 0x00000273:
  {
    FFFI_FUNCTION_INVOCATION("TableOpenContextMenu")
    {
    ImGui::TableOpenContextMenu();
  }
  }
  break;
case 0x00000274:
  {
    FFFI_FUNCTION_INVOCATION("TableOpenContextMenuV")
    auto column_n = receiveValueSignMagnitude<int>();
    {
    ImGui::TableOpenContextMenu(column_n);
  }
  }
  break;
case 0x00000275:
  {
    FFFI_FUNCTION_INVOCATION("TableSetColumnWidth")
    auto column_n = receiveValueSignMagnitude<int>();
    auto width = receiveValue<float>();
    {
    ImGui::TableSetColumnWidth(column_n, width);
  }
  }
  break;
case 0x00000276:
  {
    FFFI_FUNCTION_INVOCATION("TableSetColumnSortDirection")
    auto column_n = receiveValueSignMagnitude<int>();
    auto sort_direction = receiveValue<uint8_t>();
    auto append_to_sort_specs = receiveValue<bool>();
    {
    ImGui::TableSetColumnSortDirection(column_n, (ImGuiSortDirection)sort_direction, append_to_sort_specs);
  }
  }
  break;
case 0x00000277:
  {
    FFFI_FUNCTION_INVOCATION("TableGetHoveredRow")
    int r;
    {
    auto r = ImGui::TableGetHoveredRow();
    sendValueSignMagnitude<int>(r);
    flushSend();
  }
  }
  break;
case 0x00000278:
  {
    FFFI_FUNCTION_INVOCATION("TableGetHeaderRowHeight")
    float r;
    {
    auto r = ImGui::TableGetHeaderRowHeight();
    sendValue<float>(r);
    flushSend();
  }
  }
  break;
case 0x00000279:
  {
    FFFI_FUNCTION_INVOCATION("TableGetHeaderAngledMaxLabelWidth")
    float r;
    {
    auto r = ImGui::TableGetHeaderAngledMaxLabelWidth();
    sendValue<float>(r);
    flushSend();
  }
  }
  break;
case 0x0000027a:
  {
    FFFI_FUNCTION_INVOCATION("TablePushBackgroundChannel")
    {
    ImGui::TablePushBackgroundChannel();
  }
  }
  break;
case 0x0000027b:
  {
    FFFI_FUNCTION_INVOCATION("TablePopBackgroundChannel")
    {
    ImGui::TablePopBackgroundChannel();
  }
  }
  break;
case 0x0000027c:
  {
    FFFI_FUNCTION_INVOCATION("BeginTableEx")
    auto name = receiveString();
    auto id = receiveValue<uint32_t>();
    auto columns_count = receiveValueSignMagnitude<int>();
    bool r;
    {
    auto r = ImGui::BeginTableEx(name, id, columns_count);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x0000027d:
  {
    FFFI_FUNCTION_INVOCATION("BeginTableExV")
    auto name = receiveString();
    auto id = receiveValue<uint32_t>();
    auto columns_count = receiveValueSignMagnitude<int>();
    auto flags = receiveValueSignMagnitude<int>();
    auto outer_size = receiveArray<float,2>();
    auto inner_width = receiveValue<float>();
    bool r;
    {
    auto r = ImGui::BeginTableEx(name, id, columns_count, flags, outer_size, inner_width);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x0000027e:
  {
    FFFI_FUNCTION_INVOCATION("TableGcCompactSettings")
    {
    ImGui::TableGcCompactSettings();
  }
  }
  break;
case 0x0000027f:
  {
    FFFI_FUNCTION_INVOCATION("TableSettingsAddSettingsHandler")
    {
    ImGui::TableSettingsAddSettingsHandler();
  }
  }
  break;
case 0x00000280:
  {
    FFFI_FUNCTION_INVOCATION("TabItemSpacing")
    auto str_id = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    auto width = receiveValue<float>();
    {
    ImGui::TabItemSpacing(str_id, flags, width);
  }
  }
  break;
case 0x00000281:
  {
    FFFI_FUNCTION_INVOCATION("TabItemCalcSize")
    auto label = receiveString();
    auto has_close_button_or_unsaved_marker = receiveValue<bool>();
    float* r;
    {
    auto r = ImGui::TabItemCalcSize(label, has_close_button_or_unsaved_marker);
    sendArray<float,2>(r);
    flushSend();
  }
  }
  break;
case 0x00000282:
  {
    FFFI_FUNCTION_INVOCATION("RenderFrame")
    auto p_min = receiveArray<float,2>();
    auto p_max = receiveArray<float,2>();
    auto fill_col = receiveValue<uint32_t>();
    {
    ImGui::RenderFrame(p_min, p_max, fill_col);
  }
  }
  break;
case 0x00000283:
  {
    FFFI_FUNCTION_INVOCATION("RenderFrameV")
    auto p_min = receiveArray<float,2>();
    auto p_max = receiveArray<float,2>();
    auto fill_col = receiveValue<uint32_t>();
    auto borders = receiveValue<bool>();
    auto rounding = receiveValue<float>();
    {
    ImGui::RenderFrame(p_min, p_max, fill_col, borders, rounding);
  }
  }
  break;
case 0x00000284:
  {
    FFFI_FUNCTION_INVOCATION("RenderFrameBorder")
    auto p_min = receiveArray<float,2>();
    auto p_max = receiveArray<float,2>();
    {
    ImGui::RenderFrameBorder(p_min, p_max);
  }
  }
  break;
case 0x00000285:
  {
    FFFI_FUNCTION_INVOCATION("RenderFrameBorderV")
    auto p_min = receiveArray<float,2>();
    auto p_max = receiveArray<float,2>();
    auto rounding = receiveValue<float>();
    {
    ImGui::RenderFrameBorder(p_min, p_max, rounding);
  }
  }
  break;
case 0x00000286:
  {
    FFFI_FUNCTION_INVOCATION("RenderColorRectWithAlphaCheckerboard")
    auto draw_list = receiveValue<uintptr_t>();
    auto p_min = receiveArray<float,2>();
    auto p_max = receiveArray<float,2>();
    auto fill_col = receiveValue<uint32_t>();
    auto grid_step = receiveValue<float>();
    auto grid_off = receiveArray<float,2>();
    {
    ImGui::RenderColorRectWithAlphaCheckerboard((ImDrawList *)draw_list, p_min, p_max, fill_col, grid_step, grid_off);
  }
  }
  break;
case 0x00000287:
  {
    FFFI_FUNCTION_INVOCATION("RenderColorRectWithAlphaCheckerboardV")
    auto draw_list = receiveValue<uintptr_t>();
    auto p_min = receiveArray<float,2>();
    auto p_max = receiveArray<float,2>();
    auto fill_col = receiveValue<uint32_t>();
    auto grid_step = receiveValue<float>();
    auto grid_off = receiveArray<float,2>();
    auto rounding = receiveValue<float>();
    auto flags = receiveValueSignMagnitude<int>();
    {
    ImGui::RenderColorRectWithAlphaCheckerboard((ImDrawList *)draw_list, p_min, p_max, fill_col, grid_step, grid_off, rounding, flags);
  }
  }
  break;
case 0x00000288:
  {
    FFFI_FUNCTION_INVOCATION("RenderMouseCursor")
    auto pos = receiveArray<float,2>();
    auto scale = receiveValue<float>();
    auto mouse_cursor = receiveValueSignMagnitude<int>();
    auto col_fill = receiveValue<uint32_t>();
    auto col_border = receiveValue<uint32_t>();
    auto col_shadow = receiveValue<uint32_t>();
    {
    ImGui::RenderMouseCursor(pos, scale, mouse_cursor, col_fill, col_border, col_shadow);
  }
  }
  break;
case 0x00000289:
  {
    FFFI_FUNCTION_INVOCATION("RenderArrow")
    auto draw_list = receiveValue<uintptr_t>();
    auto pos = receiveArray<float,2>();
    auto col = receiveValue<uint32_t>();
    auto dir = receiveValueSignMagnitude<int>();
    {
    ImGui::RenderArrow((ImDrawList *)draw_list, pos, col, ImGuiDir(dir));
  }
  }
  break;
case 0x0000028a:
  {
    FFFI_FUNCTION_INVOCATION("RenderArrowV")
    auto draw_list = receiveValue<uintptr_t>();
    auto pos = receiveArray<float,2>();
    auto col = receiveValue<uint32_t>();
    auto dir = receiveValueSignMagnitude<int>();
    auto scale = receiveValue<float>();
    {
    ImGui::RenderArrow((ImDrawList *)draw_list, pos, col, ImGuiDir(dir), scale);
  }
  }
  break;
case 0x0000028b:
  {
    FFFI_FUNCTION_INVOCATION("RenderBullet")
    auto draw_list = receiveValue<uintptr_t>();
    auto pos = receiveArray<float,2>();
    auto col = receiveValue<uint32_t>();
    {
    ImGui::RenderBullet((ImDrawList *)draw_list, pos, col);
  }
  }
  break;
case 0x0000028c:
  {
    FFFI_FUNCTION_INVOCATION("RenderCheckMark")
    auto draw_list = receiveValue<uintptr_t>();
    auto pos = receiveArray<float,2>();
    auto col = receiveValue<uint32_t>();
    auto sz = receiveValue<float>();
    {
    ImGui::RenderCheckMark((ImDrawList *)draw_list, pos, col, sz);
  }
  }
  break;
case 0x0000028d:
  {
    FFFI_FUNCTION_INVOCATION("RenderArrowPointingAt")
    auto draw_list = receiveValue<uintptr_t>();
    auto pos = receiveArray<float,2>();
    auto half_sz = receiveArray<float,2>();
    auto direction = receiveValueSignMagnitude<int>();
    auto col = receiveValue<uint32_t>();
    {
    ImGui::RenderArrowPointingAt((ImDrawList *)draw_list, pos, half_sz, ImGuiDir(direction), col);
  }
  }
  break;
case 0x0000028e:
  {
    FFFI_FUNCTION_INVOCATION("RenderArrowDockMenu")
    auto draw_list = receiveValue<uintptr_t>();
    auto p_min = receiveArray<float,2>();
    auto sz = receiveValue<float>();
    auto col = receiveValue<uint32_t>();
    {
    ImGui::RenderArrowDockMenu((ImDrawList *)draw_list, p_min, sz, col);
  }
  }
  break;
case 0x0000028f:
  {
    FFFI_FUNCTION_INVOCATION("ButtonEx")
    auto label = receiveString();
    bool r;
    {
    auto r = ImGui::ButtonEx(label);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000290:
  {
    FFFI_FUNCTION_INVOCATION("ButtonExV")
    auto label = receiveString();
    auto size_arg = receiveArray<float,2>();
    auto flags = receiveValueSignMagnitude<int>();
    bool r;
    {
    auto r = ImGui::ButtonEx(label, size_arg, flags);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000291:
  {
    FFFI_FUNCTION_INVOCATION("ArrowButtonEx")
    auto str_id = receiveString();
    auto dir = receiveValueSignMagnitude<int>();
    auto size_arg = receiveArray<float,2>();
    bool r;
    {
    auto r = ImGui::ArrowButtonEx(str_id, ImGuiDir(dir), size_arg);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000292:
  {
    FFFI_FUNCTION_INVOCATION("ArrowButtonExV")
    auto str_id = receiveString();
    auto dir = receiveValueSignMagnitude<int>();
    auto size_arg = receiveArray<float,2>();
    auto flags = receiveValueSignMagnitude<int>();
    bool r;
    {
    auto r = ImGui::ArrowButtonEx(str_id, ImGuiDir(dir), size_arg, flags);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000293:
  {
    FFFI_FUNCTION_INVOCATION("ImageButtonEx")
    auto id = receiveValue<uint32_t>();
    auto user_texture_id = receiveValue<uintptr_t>();
    auto image_size = receiveArray<float,2>();
    auto uv0 = receiveArray<float,2>();
    auto uv1 = receiveArray<float,2>();
    auto bg_col = receiveArray<float,4>();
    auto tint_col = receiveArray<float,4>();
    bool r;
    {
    auto r = ImGui::ImageButtonEx(id, ImTextureID(user_texture_id), image_size, uv0, uv1, bg_col, tint_col);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000294:
  {
    FFFI_FUNCTION_INVOCATION("ImageButtonExV")
    auto id = receiveValue<uint32_t>();
    auto user_texture_id = receiveValue<uintptr_t>();
    auto image_size = receiveArray<float,2>();
    auto uv0 = receiveArray<float,2>();
    auto uv1 = receiveArray<float,2>();
    auto bg_col = receiveArray<float,4>();
    auto tint_col = receiveArray<float,4>();
    auto flags = receiveValueSignMagnitude<int>();
    bool r;
    {
    auto r = ImGui::ImageButtonEx(id, ImTextureID(user_texture_id), image_size, uv0, uv1, bg_col, tint_col, flags);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000295:
  {
    FFFI_FUNCTION_INVOCATION("SeparatorEx")
    auto flags = receiveValueSignMagnitude<int>();
    {
    ImGui::SeparatorEx(flags);
  }
  }
  break;
case 0x00000296:
  {
    FFFI_FUNCTION_INVOCATION("SeparatorExV")
    auto flags = receiveValueSignMagnitude<int>();
    auto thickness = receiveValue<float>();
    {
    ImGui::SeparatorEx(flags, thickness);
  }
  }
  break;
case 0x00000297:
  {
    FFFI_FUNCTION_INVOCATION("CloseButton")
    auto id = receiveValue<uint32_t>();
    auto pos = receiveArray<float,2>();
    bool r;
    {
    auto r = ImGui::CloseButton(id, pos);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000298:
  {
    FFFI_FUNCTION_INVOCATION("TreePushOverrideID")
    auto id = receiveValue<uint32_t>();
    {
    ImGui::TreePushOverrideID(id);
  }
  }
  break;
case 0x00000299:
  {
    FFFI_FUNCTION_INVOCATION("TreeNodeGetOpen")
    auto storage_id = receiveValue<uint32_t>();
    bool r;
    {
    auto r = ImGui::TreeNodeGetOpen(storage_id);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x0000029a:
  {
    FFFI_FUNCTION_INVOCATION("TreeNodeSetOpen")
    auto storage_id = receiveValue<uint32_t>();
    auto open = receiveValue<bool>();
    {
    ImGui::TreeNodeSetOpen(storage_id, open);
  }
  }
  break;
case 0x0000029b:
  {
    FFFI_FUNCTION_INVOCATION("TreeNodeUpdateNextOpen")
    auto storage_id = receiveValue<uint32_t>();
    auto flags = receiveValueSignMagnitude<int>();
    bool r;
    {
    auto r = ImGui::TreeNodeUpdateNextOpen(storage_id, flags);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x0000029c:
  {
    FFFI_FUNCTION_INVOCATION("InputTextDeactivateHook")
    auto id = receiveValue<uint32_t>();
    {
    ImGui::InputTextDeactivateHook(id);
  }
  }
  break;
case 0x0000029d:
  {
    FFFI_FUNCTION_INVOCATION("ShadeVertsLinearColorGradientKeepAlpha")
    auto draw_list = receiveValue<uintptr_t>();
    auto vert_start_idx = receiveValueSignMagnitude<int>();
    auto vert_end_idx = receiveValueSignMagnitude<int>();
    auto gradient_p0 = receiveArray<float,2>();
    auto gradient_p1 = receiveArray<float,2>();
    auto col0 = receiveValue<uint32_t>();
    auto col1 = receiveValue<uint32_t>();
    {
    ImGui::ShadeVertsLinearColorGradientKeepAlpha((ImDrawList *)draw_list, vert_start_idx, vert_end_idx, gradient_p0, gradient_p1, col0, col1);
  }
  }
  break;
case 0x0000029e:
  {
    FFFI_FUNCTION_INVOCATION("ShadeVertsLinearUV")
    auto draw_list = receiveValue<uintptr_t>();
    auto vert_start_idx = receiveValueSignMagnitude<int>();
    auto vert_end_idx = receiveValueSignMagnitude<int>();
    auto a = receiveArray<float,2>();
    auto b = receiveArray<float,2>();
    auto uv_a = receiveArray<float,2>();
    auto uv_b = receiveArray<float,2>();
    auto clamp = receiveValue<bool>();
    {
    ImGui::ShadeVertsLinearUV((ImDrawList *)draw_list, vert_start_idx, vert_end_idx, a, b, uv_a, uv_b, clamp);
  }
  }
  break;
case 0x0000029f:
  {
    FFFI_FUNCTION_INVOCATION("ShadeVertsTransformPos")
    auto draw_list = receiveValue<uintptr_t>();
    auto vert_start_idx = receiveValueSignMagnitude<int>();
    auto vert_end_idx = receiveValueSignMagnitude<int>();
    auto pivot_in = receiveArray<float,2>();
    auto cos_a = receiveValue<float>();
    auto sin_a = receiveValue<float>();
    auto pivot_out = receiveArray<float,2>();
    {
    ImGui::ShadeVertsTransformPos((ImDrawList *)draw_list, vert_start_idx, vert_end_idx, pivot_in, cos_a, sin_a, pivot_out);
  }
  }
  break;
case 0x000002a0:
  {
    FFFI_FUNCTION_INVOCATION("GcCompactTransientMiscBuffers")
    {
    ImGui::GcCompactTransientMiscBuffers();
  }
  }
  break;
case 0x000002a1:
  {
    FFFI_FUNCTION_INVOCATION("ErrorLog")
    auto msg = receiveString();
    bool r;
    {
    auto r = ImGui::ErrorLog(msg);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000002a2:
  {
    FFFI_FUNCTION_INVOCATION("ErrorCheckUsingSetCursorPosToExtendParentBoundaries")
    {
    ImGui::ErrorCheckUsingSetCursorPosToExtendParentBoundaries();
  }
  }
  break;
case 0x000002a3:
  {
    FFFI_FUNCTION_INVOCATION("ErrorCheckEndFrameFinalizeErrorTooltip")
    {
    ImGui::ErrorCheckEndFrameFinalizeErrorTooltip();
  }
  }
  break;
case 0x000002a4:
  {
    FFFI_FUNCTION_INVOCATION("BeginErrorTooltip")
    bool r;
    {
    auto r = ImGui::BeginErrorTooltip();
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000002a5:
  {
    FFFI_FUNCTION_INVOCATION("EndErrorTooltip")
    {
    ImGui::EndErrorTooltip();
  }
  }
  break;
case 0x000002a6:
  {
    FFFI_FUNCTION_INVOCATION("DebugDrawCursorPos")
    {
    ImGui::DebugDrawCursorPos();
  }
  }
  break;
case 0x000002a7:
  {
    FFFI_FUNCTION_INVOCATION("DebugDrawCursorPosV")
    auto col = receiveValue<uint32_t>();
    {
    ImGui::DebugDrawCursorPos(col);
  }
  }
  break;
case 0x000002a8:
  {
    FFFI_FUNCTION_INVOCATION("DebugDrawLineExtents")
    {
    ImGui::DebugDrawLineExtents();
  }
  }
  break;
case 0x000002a9:
  {
    FFFI_FUNCTION_INVOCATION("DebugDrawLineExtentsV")
    auto col = receiveValue<uint32_t>();
    {
    ImGui::DebugDrawLineExtents(col);
  }
  }
  break;
case 0x000002aa:
  {
    FFFI_FUNCTION_INVOCATION("DebugDrawItemRect")
    {
    ImGui::DebugDrawItemRect();
  }
  }
  break;
case 0x000002ab:
  {
    FFFI_FUNCTION_INVOCATION("DebugDrawItemRectV")
    auto col = receiveValue<uint32_t>();
    {
    ImGui::DebugDrawItemRect(col);
  }
  }
  break;
case 0x000002ac:
  {
    FFFI_FUNCTION_INVOCATION("DebugLocateItem")
    auto target_id = receiveValue<uint32_t>();
    {
    ImGui::DebugLocateItem(target_id);
  }
  }
  break;
case 0x000002ad:
  {
    FFFI_FUNCTION_INVOCATION("DebugLocateItemOnHover")
    auto target_id = receiveValue<uint32_t>();
    {
    ImGui::DebugLocateItemOnHover(target_id);
  }
  }
  break;
case 0x000002ae:
  {
    FFFI_FUNCTION_INVOCATION("DebugLocateItemResolveWithLastItem")
    {
    ImGui::DebugLocateItemResolveWithLastItem();
  }
  }
  break;
case 0x000002af:
  {
    FFFI_FUNCTION_INVOCATION("DebugBreakClearData")
    {
    ImGui::DebugBreakClearData();
  }
  }
  break;
case 0x000002b0:
  {
    FFFI_FUNCTION_INVOCATION("DebugBreakButton")
    auto label = receiveString();
    auto description_of_location = receiveString();
    bool r;
    {
    auto r = ImGui::DebugBreakButton(label, description_of_location);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000002b1:
  {
    FFFI_FUNCTION_INVOCATION("DebugBreakButtonTooltip")
    auto keyboard_only = receiveValue<bool>();
    auto description_of_location = receiveString();
    {
    ImGui::DebugBreakButtonTooltip(keyboard_only, description_of_location);
  }
  }
  break;
case 0x000002b2:
  {
    FFFI_FUNCTION_INVOCATION("DebugRenderKeyboardPreview")
    auto draw_list = receiveValue<uintptr_t>();
    {
    ImGui::DebugRenderKeyboardPreview((ImDrawList *)draw_list);
  }
  }
  break;
case 0x000002b3:
  {
    FFFI_FUNCTION_INVOCATION("NewHexEditor")
    uintptr_t r;
    {
    r = (uintptr_t)(new HexEditor());
    sendValue(r);
    flushSend();
  }
  }
  break;
case 0x000002b4:
  {
    FFFI_FUNCTION_INVOCATION("Destroy")
    auto foreignptr = receiveValue<uintptr_t>();
    {
    delete((HexEditor*)foreignptr);
  }
  }
  break;
case 0x000002b5:
  {
    FFFI_FUNCTION_INVOCATION("GetSettings")
    auto foreignptr = receiveValue<uintptr_t>();
    bool readOnly;
    int cols;
    bool showOptions;
    bool showDataPreview;
    bool showHexII;
    bool showAscii;
    bool greyOutZeroes;
    bool upperCaseHex;
    int midColsCount;
    int addrDigitsCount;
    float footerExtraHeight;
    uint32_t highlightColor;
    {
    
auto e = ((HexEditor*)foreignptr);
auto t = e->memEditor;
#define ASSIGN(l,r) ((l) = (r))
ASSIGN(readOnly, t->ReadOnly);
ASSIGN(cols, t->Cols);
ASSIGN(showOptions, t->OptShowOptions);
ASSIGN(showDataPreview, t->OptShowDataPreview);
ASSIGN(showHexII, t->OptShowHexII);
ASSIGN(showAscii, t->OptShowAscii);
ASSIGN(greyOutZeroes, t->OptGreyOutZeroes);
ASSIGN(upperCaseHex, t->OptUpperCaseHex);
ASSIGN(midColsCount, t->OptMidColsCount);
ASSIGN(addrDigitsCount, t->OptAddrDigitsCount);
ASSIGN(footerExtraHeight, t->OptFooterExtraHeight);
ASSIGN(highlightColor, t->HighlightColor);
#undef ASSIGN
;
    sendValue<bool>(readOnly);
    sendValueSignMagnitude<int>(cols);
    sendValue<bool>(showOptions);
    sendValue<bool>(showDataPreview);
    sendValue<bool>(showHexII);
    sendValue<bool>(showAscii);
    sendValue<bool>(greyOutZeroes);
    sendValue<bool>(upperCaseHex);
    sendValueSignMagnitude<int>(midColsCount);
    sendValueSignMagnitude<int>(addrDigitsCount);
    sendValue<float>(footerExtraHeight);
    sendValue<uint32_t>(highlightColor);
    flushSend();
  }
  }
  break;
case 0x000002b6:
  {
    FFFI_FUNCTION_INVOCATION("SetSettings")
    auto foreignptr = receiveValue<uintptr_t>();
    auto readOnly = receiveValue<bool>();
    auto cols = receiveValueSignMagnitude<int>();
    auto showOptions = receiveValue<bool>();
    auto showDataPreview = receiveValue<bool>();
    auto showHexII = receiveValue<bool>();
    auto showAscii = receiveValue<bool>();
    auto greyOutZeroes = receiveValue<bool>();
    auto upperCaseHex = receiveValue<bool>();
    auto midColsCount = receiveValueSignMagnitude<int>();
    auto addrDigitsCount = receiveValueSignMagnitude<int>();
    auto footerExtraHeight = receiveValue<float>();
    auto highlightColor = receiveValue<uint32_t>();
    {
    
auto e = ((HexEditor*)foreignptr);
auto t = e->memEditor;
#define ASSIGN(l,r) ((r) = (l))
ASSIGN(readOnly, t->ReadOnly);
ASSIGN(cols, t->Cols);
ASSIGN(showOptions, t->OptShowOptions);
ASSIGN(showDataPreview, t->OptShowDataPreview);
ASSIGN(showHexII, t->OptShowHexII);
ASSIGN(showAscii, t->OptShowAscii);
ASSIGN(greyOutZeroes, t->OptGreyOutZeroes);
ASSIGN(upperCaseHex, t->OptUpperCaseHex);
ASSIGN(midColsCount, t->OptMidColsCount);
ASSIGN(addrDigitsCount, t->OptAddrDigitsCount);
ASSIGN(footerExtraHeight, t->OptFooterExtraHeight);
ASSIGN(highlightColor, t->HighlightColor);
#undef ASSIGN
;
  }
  }
  break;
case 0x000002b7:
  {
    FFFI_FUNCTION_INVOCATION("GotoAddrAndHighlight")
    auto foreignptr = receiveValue<uintptr_t>();
    auto addrMin = receiveValue<uint64_t>();
    auto addrMax = receiveValue<uint64_t>();
    {
    ((HexEditor*)foreignptr)->memEditor->GotoAddrAndHighlight(addrMin,addrMax);
  }
  }
  break;
case 0x000002b8:
  {
    FFFI_FUNCTION_INVOCATION("DrawWindow")
    auto foreignptr = receiveValue<uintptr_t>();
    auto title = receiveString();
    auto data = receiveSlice<uint8_t>();
    {
    
auto e = ((HexEditor*)foreignptr);
auto t = e->memEditor;
t->DrawWindow(title,e->data,e->data_length);
;
  }
  }
  break;
case 0x000002b9:
  {
    FFFI_FUNCTION_INVOCATION("DrawWindowV")
    auto foreignptr = receiveValue<uintptr_t>();
    auto title = receiveString();
    auto baseDisplayAddr = receiveValue<uint64_t>();
    {
    
auto e = ((HexEditor*)foreignptr);
auto t = e->memEditor;
t->DrawWindow(title,e->data,e->data_length,baseDisplayAddr);
;
  }
  }
  break;
case 0x000002ba:
  {
    FFFI_FUNCTION_INVOCATION("DrawContents")
    auto foreignptr = receiveValue<uintptr_t>();
    {
    
auto e = ((HexEditor*)foreignptr);
auto t = e->memEditor;
t->DrawContents(e->data,e->data_length);
;
  }
  }
  break;
case 0x000002bb:
  {
    FFFI_FUNCTION_INVOCATION("DrawContentV")
    auto foreignptr = receiveValue<uintptr_t>();
    auto baseDisplayAddr = receiveValue<uint64_t>();
    {
    
auto e = ((HexEditor*)foreignptr);
auto t = e->memEditor;
t->DrawContents(e->data,e->data_length,baseDisplayAddr);
;
  }
  }
  break;
case 0x000002bc:
  {
    FFFI_FUNCTION_INVOCATION("SetData")
    auto foreignptr = receiveValue<uintptr_t>();
    auto data = receiveSlice<uint8_t>();
    {
    
auto e = ((HexEditor*)foreignptr);
auto sz = getSliceLength(data);
e->data_length = sz;
if(e->data != nullptr) {
   free(e->data);
}
if(sz != 0) {
   e->data = (decltype(e->data))malloc(sz);
   assert(e->data != nullptr);
   memcpy(e->data,data,sz);
} else {
   e->data = nullptr;
}
;
  }
  }
  break;
case 0x000002bd:
  {
    FFFI_FUNCTION_INVOCATION("GetData")
    auto foreignptr = receiveValue<uintptr_t>();
    const char * data;
    {
    
auto e = ((HexEditor*)foreignptr);
auto data = (const uint8_t*)e->data;
auto data_len = e->data_length;
;
    sendSlice<uint8_t>(data,data_len);
    flushSend();
  }
  }
  break;
case 0x000002be:
  {
    FFFI_FUNCTION_INVOCATION("TextUnformatted")
    auto text = receiveString();
    {
    ImGui::TextUnformatted(text,text+getStringLength(text));
  }
  }
  break;
case 0x000002bf:
  {
    FFFI_FUNCTION_INVOCATION("LabelText")
    auto label = receiveString();
    auto text = receiveString();
    {
    ImGui::LabelText(label,"%.*s",(int)getStringLength(text),text);
  }
  }
  break;
case 0x000002c0:
  {
    FFFI_FUNCTION_INVOCATION("BulletText")
    auto text = receiveString();
    {
    ImGui::BulletText("%.*s",(int)getStringLength(text),text);
  }
  }
  break;
case 0x000002c1:
  {
    FFFI_FUNCTION_INVOCATION("GetIoDeltaTime")
    float dt;
    {
    dt = ImGui::GetIO().DeltaTime;
    sendValue<float>(dt);
    flushSend();
  }
  }
  break;
case 0x000002c2:
  {
    FFFI_FUNCTION_INVOCATION("CalcTextWidth")
    auto text = receiveString();
    float* r;
    {
    auto r = ImGui::CalcTextSize(text,text+getStringLength(text));
    sendArray<float,2>(r);
    flushSend();
  }
  }
  break;
case 0x000002c3:
  {
    FFFI_FUNCTION_INVOCATION("CalcTextWidthV")
    auto text = receiveString();
    auto hideTextAfterDoubleHash = receiveValue<bool>();
    auto floatWrapWidth = receiveValue<float>();
    float* r;
    {
    auto r = ImGui::CalcTextSize(text,text+getStringLength(text),hideTextAfterDoubleHash,floatWrapWidth);
    sendArray<float,2>(r);
    flushSend();
  }
  }
  break;
case 0x000002c4:
  {
    FFFI_FUNCTION_INVOCATION("InputText")
    auto label = receiveString();
    auto textIn = receiveString();
    auto maxLength = receiveValue<uint64_t>();
    const char * textOut;
    bool changed;
    {
    
auto textOut = (char *)arenaMalloc(maxLength);
memcpy(textOut,textIn,getStringLength(textIn)+1);
changed = ImGui::InputText(label,textOut,maxLength);
auto textOut_len = strlen(textOut);
;
    sendString(textOut);
    sendValue<bool>(changed);
    flushSend();
  }
  }
  break;
case 0x000002c5:
  {
    FFFI_FUNCTION_INVOCATION("InputTextV")
    auto label = receiveString();
    auto textIn = receiveString();
    auto maxLength = receiveValue<uint64_t>();
    auto flags = receiveValueSignMagnitude<int>();
    const char * textOut;
    bool changed;
    {
    
auto textOut = (char *)arenaMalloc(maxLength);
memcpy(textOut,textIn,getStringLength(textIn)+1);
changed = ImGui::InputText(label,textOut,maxLength,flags);
auto textOut_len = strlen(textOut);
;
    sendString(textOut);
    sendValue<bool>(changed);
    flushSend();
  }
  }
  break;
case 0x000002c6:
  {
    FFFI_FUNCTION_INVOCATION("InputTextWithHint")
    auto label = receiveString();
    auto hint = receiveString();
    auto textIn = receiveString();
    auto maxLength = receiveValue<uint64_t>();
    const char * textOut;
    bool changed;
    {
    
auto textOut = (char *)arenaMalloc(maxLength);
memcpy(textOut,textIn,getStringLength(textIn)+1);
changed = ImGui::InputTextWithHint(label,hint,textOut,maxLength);
auto textOut_len = strlen(textOut);
;
    sendString(textOut);
    sendValue<bool>(changed);
    flushSend();
  }
  }
  break;
case 0x000002c7:
  {
    FFFI_FUNCTION_INVOCATION("InputTextWithHintV")
    auto label = receiveString();
    auto hint = receiveString();
    auto textIn = receiveString();
    auto maxLength = receiveValue<uint64_t>();
    auto flags = receiveValueSignMagnitude<int>();
    const char * textOut;
    bool changed;
    {
    
auto textOut = (char *)arenaMalloc(maxLength);
memcpy(textOut,textIn,getStringLength(textIn)+1);
changed = ImGui::InputTextWithHint(label,hint,textOut,maxLength,flags);
auto textOut_len = strlen(textOut);
;
    sendString(textOut);
    sendValue<bool>(changed);
    flushSend();
  }
  }
  break;
case 0x000002c8:
  {
    FFFI_FUNCTION_INVOCATION("BringCurrentWindowToDisplayFront")
    {
    ImGui::BringWindowToDisplayFront(ImGui::GetCurrentWindow());
  }
  }
  break;
case 0x000002c9:
  {
    FFFI_FUNCTION_INVOCATION("GetIdPreviousFrame")
    uint32_t hoveredId;
    uint32_t activeId;
    {
    
	ImGuiContext& g = *GImGui;
	hoveredId = g.HoveredIdPreviousFrame;
	activeId = g.ActiveId;
;
    sendValue<uint32_t>(hoveredId);
    sendValue<uint32_t>(activeId);
    flushSend();
  }
  }
  break;
case 0x000002ca:
  {
    FFFI_FUNCTION_INVOCATION("Knob")
    auto label = receiveString();
    auto valueP = receiveValue<float>();
    auto v_min = receiveValue<float>();
    auto v_max = receiveValue<float>();
    float value;
    bool r;
    {
    r = ImGuiKnobs::Knob(label,&valueP,v_min,v_max);
         value = valueP;
    sendValue<float>(value);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000002cb:
  {
    FFFI_FUNCTION_INVOCATION("KnobV")
    auto label = receiveString();
    auto valueP = receiveValue<float>();
    auto v_min = receiveValue<float>();
    auto v_max = receiveValue<float>();
    auto speed = receiveValue<float>();
    auto format = receiveString();
    auto variant = receiveValueSignMagnitude<int>();
    auto size = receiveValue<float>();
    auto flags = receiveValueSignMagnitude<int>();
    auto steps = receiveValueSignMagnitude<int>();
    float value;
    bool r;
    {
    r = ImGuiKnobs::Knob(label,&valueP,v_min,v_max,speed,format,variant,size,flags,steps);
         value = valueP;
    sendValue<float>(value);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000002cc:
  {
    FFFI_FUNCTION_INVOCATION("KnobInt")
    auto label = receiveString();
    auto valueP = receiveValueSignMagnitude<int>();
    auto v_min = receiveValueSignMagnitude<int>();
    auto v_max = receiveValueSignMagnitude<int>();
    int value;
    bool r;
    {
    r = ImGuiKnobs::KnobInt(label,&valueP,v_min,v_max);
         value = valueP;
    sendValueSignMagnitude<int>(value);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000002cd:
  {
    FFFI_FUNCTION_INVOCATION("KnobIntV")
    auto label = receiveString();
    auto valueP = receiveValueSignMagnitude<int>();
    auto v_min = receiveValueSignMagnitude<int>();
    auto v_max = receiveValueSignMagnitude<int>();
    auto speed = receiveValue<float>();
    auto format = receiveString();
    auto variant = receiveValueSignMagnitude<int>();
    auto size = receiveValue<float>();
    auto flags = receiveValueSignMagnitude<int>();
    auto steps = receiveValueSignMagnitude<int>();
    int value;
    bool r;
    {
    r = ImGuiKnobs::KnobInt(label,&valueP,v_min,v_max,speed,format,variant,size,flags,steps);
         value = valueP;
    sendValueSignMagnitude<int>(value);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000002ce:
  {
    FFFI_FUNCTION_INVOCATION("BeginPiePopup")
    auto name = receiveString();
    bool r;
    {
    r = ImGui::BeginPiePopup(name);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000002cf:
  {
    FFFI_FUNCTION_INVOCATION("BeginPiePopupV")
    auto name = receiveString();
    auto iMouseButton = receiveValueSignMagnitude<int>();
    bool r;
    {
    r = ImGui::BeginPiePopup(name,iMouseButton);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000002d0:
  {
    FFFI_FUNCTION_INVOCATION("EndPiePopup")
    {
    ImGui::EndPiePopup();
  }
  }
  break;
case 0x000002d1:
  {
    FFFI_FUNCTION_INVOCATION("PieMenuItem")
    auto name = receiveString();
    bool r;
    {
    r = ImGui::PieMenuItem(name);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000002d2:
  {
    FFFI_FUNCTION_INVOCATION("PieMenuItemV")
    auto name = receiveString();
    auto bEnabled = receiveValue<bool>();
    bool r;
    {
    r = ImGui::PieMenuItem(name,bEnabled);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000002d3:
  {
    FFFI_FUNCTION_INVOCATION("BeginPieMenu")
    auto name = receiveString();
    bool r;
    {
    r = ImGui::BeginPieMenu(name);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000002d4:
  {
    FFFI_FUNCTION_INVOCATION("BeginPieMenuV")
    auto name = receiveString();
    auto bEnabled = receiveValue<bool>();
    bool r;
    {
    r = ImGui::BeginPieMenu(name,bEnabled);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000002d5:
  {
    FFFI_FUNCTION_INVOCATION("EndPieMenu")
    {
    ImGui::EndPieMenu();
  }
  }
  break;
case 0x000002d6:
  {
    FFFI_FUNCTION_INVOCATION("GetSkiaFontDyFudge")
    float fudge;
    {
    fudge = ImGui::skiaFontDyFudge;;
    sendValue<float>(fudge);
    flushSend();
  }
  }
  break;
case 0x000002d7:
  {
    FFFI_FUNCTION_INVOCATION("SetSkiaFontDyFudge")
    auto fudge = receiveValue<float>();
    {
    ImGui::skiaFontDyFudge = fudge;;
  }
  }
  break;
case 0x000002d8:
  {
    FFFI_FUNCTION_INVOCATION("SliderFloat32")
    auto label = receiveString();
    auto vP = receiveValue<float>();
    auto p_min = receiveValue<float>();
    auto p_max = receiveValue<float>();
    float v;
    bool r;
    {
    
r = ImGui::SliderScalar(label,ImGuiDataType_Float,(void*)&vP,(const void*)&p_min,(const void*)&p_max);
v = vP;
;
    sendValue<float>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000002d9:
  {
    FFFI_FUNCTION_INVOCATION("SliderFloat32V")
    auto label = receiveString();
    auto vP = receiveValue<float>();
    auto p_min = receiveValue<float>();
    auto p_max = receiveValue<float>();
    auto format = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    float v;
    bool r;
    {
    
r = ImGui::SliderScalar(label,ImGuiDataType_Float,(void*)&vP,(const void*)&p_min,(const void*)&p_max,format,flags);
v = vP;
;
    sendValue<float>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000002da:
  {
    FFFI_FUNCTION_INVOCATION("SliderFloat32NV")
    auto label = receiveString();
    auto vP = receiveSlice<float>();
    auto v_min = receiveValue<float>();
    auto v_max = receiveValue<float>();
    auto format = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    float* v;
    bool r;
    {
    
size_t v_len = getSliceLength(vP);
r = ImGui::SliderScalarN(label,ImGuiDataType_Float,(void*)vP,(int)v_len,(const void*)&v_min,(const void*)&v_max,format,flags);
v = vP;
;
    sendSlice<float>(v,v_len);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000002db:
  {
    FFFI_FUNCTION_INVOCATION("SliderFloat32N")
    auto label = receiveString();
    auto vP = receiveSlice<float>();
    auto v_min = receiveValue<float>();
    auto v_max = receiveValue<float>();
    float* v;
    bool r;
    {
    
size_t v_len = getSliceLength(vP);
r = ImGui::SliderScalarN(label,ImGuiDataType_Float,(void*)vP,(int)v_len,(const void*)&v_min,(const void*)&v_max);
v = vP;
;
    sendSlice<float>(v,v_len);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000002dc:
  {
    FFFI_FUNCTION_INVOCATION("SliderFloat64")
    auto label = receiveString();
    auto vP = receiveValue<double>();
    auto p_min = receiveValue<double>();
    auto p_max = receiveValue<double>();
    double v;
    bool r;
    {
    
r = ImGui::SliderScalar(label,ImGuiDataType_Double,(void*)&vP,(const void*)&p_min,(const void*)&p_max);
v = vP;
;
    sendValue<double>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000002dd:
  {
    FFFI_FUNCTION_INVOCATION("SliderFloat64V")
    auto label = receiveString();
    auto vP = receiveValue<double>();
    auto p_min = receiveValue<double>();
    auto p_max = receiveValue<double>();
    auto format = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    double v;
    bool r;
    {
    
r = ImGui::SliderScalar(label,ImGuiDataType_Double,(void*)&vP,(const void*)&p_min,(const void*)&p_max,format,flags);
v = vP;
;
    sendValue<double>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000002de:
  {
    FFFI_FUNCTION_INVOCATION("SliderFloat64NV")
    auto label = receiveString();
    auto vP = receiveSlice<double>();
    auto v_min = receiveValue<double>();
    auto v_max = receiveValue<double>();
    auto format = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    double* v;
    bool r;
    {
    
size_t v_len = getSliceLength(vP);
r = ImGui::SliderScalarN(label,ImGuiDataType_Double,(void*)vP,(int)v_len,(const void*)&v_min,(const void*)&v_max,format,flags);
v = vP;
;
    sendSlice<double>(v,v_len);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000002df:
  {
    FFFI_FUNCTION_INVOCATION("SliderFloat64N")
    auto label = receiveString();
    auto vP = receiveSlice<double>();
    auto v_min = receiveValue<double>();
    auto v_max = receiveValue<double>();
    double* v;
    bool r;
    {
    
size_t v_len = getSliceLength(vP);
r = ImGui::SliderScalarN(label,ImGuiDataType_Double,(void*)vP,(int)v_len,(const void*)&v_min,(const void*)&v_max);
v = vP;
;
    sendSlice<double>(v,v_len);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000002e0:
  {
    FFFI_FUNCTION_INVOCATION("SliderInt")
    auto label = receiveString();
    auto vP = receiveValueSignMagnitude<int>();
    auto p_min = receiveValueSignMagnitude<int>();
    auto p_max = receiveValueSignMagnitude<int>();
    int v;
    bool r;
    {
    
r = ImGui::SliderScalar(label,ImGuiDataType_S32,(void*)&vP,(const void*)&p_min,(const void*)&p_max);
v = vP;
;
    sendValueSignMagnitude<int>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000002e1:
  {
    FFFI_FUNCTION_INVOCATION("SliderIntV")
    auto label = receiveString();
    auto vP = receiveValueSignMagnitude<int>();
    auto p_min = receiveValueSignMagnitude<int>();
    auto p_max = receiveValueSignMagnitude<int>();
    auto format = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    int v;
    bool r;
    {
    
r = ImGui::SliderScalar(label,ImGuiDataType_S32,(void*)&vP,(const void*)&p_min,(const void*)&p_max,format,flags);
v = vP;
;
    sendValueSignMagnitude<int>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000002e2:
  {
    FFFI_FUNCTION_INVOCATION("SliderIntNV")
    auto label = receiveString();
    auto vP = receiveSlice<int>();
    auto v_min = receiveValueSignMagnitude<int>();
    auto v_max = receiveValueSignMagnitude<int>();
    auto format = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    int* v;
    bool r;
    {
    
size_t v_len = getSliceLength(vP);
r = ImGui::SliderScalarN(label,ImGuiDataType_S32,(void*)vP,(int)v_len,(const void*)&v_min,(const void*)&v_max,format,flags);
v = vP;
;
    sendSlice<int>(v,v_len);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000002e3:
  {
    FFFI_FUNCTION_INVOCATION("SliderIntN")
    auto label = receiveString();
    auto vP = receiveSlice<int>();
    auto v_min = receiveValueSignMagnitude<int>();
    auto v_max = receiveValueSignMagnitude<int>();
    int* v;
    bool r;
    {
    
size_t v_len = getSliceLength(vP);
r = ImGui::SliderScalarN(label,ImGuiDataType_S32,(void*)vP,(int)v_len,(const void*)&v_min,(const void*)&v_max);
v = vP;
;
    sendSlice<int>(v,v_len);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000002e4:
  {
    FFFI_FUNCTION_INVOCATION("SliderInt16")
    auto label = receiveString();
    auto vP = receiveValueSignMagnitude<int16_t>();
    auto p_min = receiveValueSignMagnitude<int16_t>();
    auto p_max = receiveValueSignMagnitude<int16_t>();
    int16_t v;
    bool r;
    {
    
r = ImGui::SliderScalar(label,ImGuiDataType_S16,(void*)&vP,(const void*)&p_min,(const void*)&p_max);
v = vP;
;
    sendValueSignMagnitude<int16_t>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000002e5:
  {
    FFFI_FUNCTION_INVOCATION("SliderInt16V")
    auto label = receiveString();
    auto vP = receiveValueSignMagnitude<int16_t>();
    auto p_min = receiveValueSignMagnitude<int16_t>();
    auto p_max = receiveValueSignMagnitude<int16_t>();
    auto format = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    int16_t v;
    bool r;
    {
    
r = ImGui::SliderScalar(label,ImGuiDataType_S16,(void*)&vP,(const void*)&p_min,(const void*)&p_max,format,flags);
v = vP;
;
    sendValueSignMagnitude<int16_t>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000002e6:
  {
    FFFI_FUNCTION_INVOCATION("SliderInt16NV")
    auto label = receiveString();
    auto vP = receiveSlice<int16_t>();
    auto v_min = receiveValueSignMagnitude<int16_t>();
    auto v_max = receiveValueSignMagnitude<int16_t>();
    auto format = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    int16_t* v;
    bool r;
    {
    
size_t v_len = getSliceLength(vP);
r = ImGui::SliderScalarN(label,ImGuiDataType_S16,(void*)vP,(int)v_len,(const void*)&v_min,(const void*)&v_max,format,flags);
v = vP;
;
    sendSlice<int16_t>(v,v_len);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000002e7:
  {
    FFFI_FUNCTION_INVOCATION("SliderInt16N")
    auto label = receiveString();
    auto vP = receiveSlice<int16_t>();
    auto v_min = receiveValueSignMagnitude<int16_t>();
    auto v_max = receiveValueSignMagnitude<int16_t>();
    int16_t* v;
    bool r;
    {
    
size_t v_len = getSliceLength(vP);
r = ImGui::SliderScalarN(label,ImGuiDataType_S16,(void*)vP,(int)v_len,(const void*)&v_min,(const void*)&v_max);
v = vP;
;
    sendSlice<int16_t>(v,v_len);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000002e8:
  {
    FFFI_FUNCTION_INVOCATION("SliderInt32")
    auto label = receiveString();
    auto vP = receiveValueSignMagnitude<int32_t>();
    auto p_min = receiveValueSignMagnitude<int32_t>();
    auto p_max = receiveValueSignMagnitude<int32_t>();
    int32_t v;
    bool r;
    {
    
r = ImGui::SliderScalar(label,ImGuiDataType_S32,(void*)&vP,(const void*)&p_min,(const void*)&p_max);
v = vP;
;
    sendValueSignMagnitude<int32_t>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000002e9:
  {
    FFFI_FUNCTION_INVOCATION("SliderInt32V")
    auto label = receiveString();
    auto vP = receiveValueSignMagnitude<int32_t>();
    auto p_min = receiveValueSignMagnitude<int32_t>();
    auto p_max = receiveValueSignMagnitude<int32_t>();
    auto format = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    int32_t v;
    bool r;
    {
    
r = ImGui::SliderScalar(label,ImGuiDataType_S32,(void*)&vP,(const void*)&p_min,(const void*)&p_max,format,flags);
v = vP;
;
    sendValueSignMagnitude<int32_t>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000002ea:
  {
    FFFI_FUNCTION_INVOCATION("SliderInt32NV")
    auto label = receiveString();
    auto vP = receiveSlice<int32_t>();
    auto v_min = receiveValueSignMagnitude<int32_t>();
    auto v_max = receiveValueSignMagnitude<int32_t>();
    auto format = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    int32_t* v;
    bool r;
    {
    
size_t v_len = getSliceLength(vP);
r = ImGui::SliderScalarN(label,ImGuiDataType_S32,(void*)vP,(int)v_len,(const void*)&v_min,(const void*)&v_max,format,flags);
v = vP;
;
    sendSlice<int32_t>(v,v_len);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000002eb:
  {
    FFFI_FUNCTION_INVOCATION("SliderInt32N")
    auto label = receiveString();
    auto vP = receiveSlice<int32_t>();
    auto v_min = receiveValueSignMagnitude<int32_t>();
    auto v_max = receiveValueSignMagnitude<int32_t>();
    int32_t* v;
    bool r;
    {
    
size_t v_len = getSliceLength(vP);
r = ImGui::SliderScalarN(label,ImGuiDataType_S32,(void*)vP,(int)v_len,(const void*)&v_min,(const void*)&v_max);
v = vP;
;
    sendSlice<int32_t>(v,v_len);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000002ec:
  {
    FFFI_FUNCTION_INVOCATION("SliderInt8")
    auto label = receiveString();
    auto vP = receiveValueSignMagnitude<int8_t>();
    auto p_min = receiveValueSignMagnitude<int8_t>();
    auto p_max = receiveValueSignMagnitude<int8_t>();
    int8_t v;
    bool r;
    {
    
r = ImGui::SliderScalar(label,ImGuiDataType_S8,(void*)&vP,(const void*)&p_min,(const void*)&p_max);
v = vP;
;
    sendValueSignMagnitude<int8_t>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000002ed:
  {
    FFFI_FUNCTION_INVOCATION("SliderInt8V")
    auto label = receiveString();
    auto vP = receiveValueSignMagnitude<int8_t>();
    auto p_min = receiveValueSignMagnitude<int8_t>();
    auto p_max = receiveValueSignMagnitude<int8_t>();
    auto format = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    int8_t v;
    bool r;
    {
    
r = ImGui::SliderScalar(label,ImGuiDataType_S8,(void*)&vP,(const void*)&p_min,(const void*)&p_max,format,flags);
v = vP;
;
    sendValueSignMagnitude<int8_t>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000002ee:
  {
    FFFI_FUNCTION_INVOCATION("SliderInt8NV")
    auto label = receiveString();
    auto vP = receiveSlice<int8_t>();
    auto v_min = receiveValueSignMagnitude<int8_t>();
    auto v_max = receiveValueSignMagnitude<int8_t>();
    auto format = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    int8_t* v;
    bool r;
    {
    
size_t v_len = getSliceLength(vP);
r = ImGui::SliderScalarN(label,ImGuiDataType_S8,(void*)vP,(int)v_len,(const void*)&v_min,(const void*)&v_max,format,flags);
v = vP;
;
    sendSlice<int8_t>(v,v_len);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000002ef:
  {
    FFFI_FUNCTION_INVOCATION("SliderInt8N")
    auto label = receiveString();
    auto vP = receiveSlice<int8_t>();
    auto v_min = receiveValueSignMagnitude<int8_t>();
    auto v_max = receiveValueSignMagnitude<int8_t>();
    int8_t* v;
    bool r;
    {
    
size_t v_len = getSliceLength(vP);
r = ImGui::SliderScalarN(label,ImGuiDataType_S8,(void*)vP,(int)v_len,(const void*)&v_min,(const void*)&v_max);
v = vP;
;
    sendSlice<int8_t>(v,v_len);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000002f0:
  {
    FFFI_FUNCTION_INVOCATION("SliderUInt")
    auto label = receiveString();
    auto vP = receiveValue<unsigned>();
    auto p_min = receiveValue<unsigned>();
    auto p_max = receiveValue<unsigned>();
    unsigned v;
    bool r;
    {
    
r = ImGui::SliderScalar(label,ImGuiDataType_U32,(void*)&vP,(const void*)&p_min,(const void*)&p_max);
v = vP;
;
    sendValue<unsigned>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000002f1:
  {
    FFFI_FUNCTION_INVOCATION("SliderUIntV")
    auto label = receiveString();
    auto vP = receiveValue<unsigned>();
    auto p_min = receiveValue<unsigned>();
    auto p_max = receiveValue<unsigned>();
    auto format = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    unsigned v;
    bool r;
    {
    
r = ImGui::SliderScalar(label,ImGuiDataType_U32,(void*)&vP,(const void*)&p_min,(const void*)&p_max,format,flags);
v = vP;
;
    sendValue<unsigned>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000002f2:
  {
    FFFI_FUNCTION_INVOCATION("SliderUIntNV")
    auto label = receiveString();
    auto vP = receiveSlice<unsigned>();
    auto v_min = receiveValue<unsigned>();
    auto v_max = receiveValue<unsigned>();
    auto format = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    unsigned* v;
    bool r;
    {
    
size_t v_len = getSliceLength(vP);
r = ImGui::SliderScalarN(label,ImGuiDataType_U32,(void*)vP,(int)v_len,(const void*)&v_min,(const void*)&v_max,format,flags);
v = vP;
;
    sendSlice<unsigned>(v,v_len);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000002f3:
  {
    FFFI_FUNCTION_INVOCATION("SliderUIntN")
    auto label = receiveString();
    auto vP = receiveSlice<unsigned>();
    auto v_min = receiveValue<unsigned>();
    auto v_max = receiveValue<unsigned>();
    unsigned* v;
    bool r;
    {
    
size_t v_len = getSliceLength(vP);
r = ImGui::SliderScalarN(label,ImGuiDataType_U32,(void*)vP,(int)v_len,(const void*)&v_min,(const void*)&v_max);
v = vP;
;
    sendSlice<unsigned>(v,v_len);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000002f4:
  {
    FFFI_FUNCTION_INVOCATION("SliderUInt16")
    auto label = receiveString();
    auto vP = receiveValue<uint16_t>();
    auto p_min = receiveValue<uint16_t>();
    auto p_max = receiveValue<uint16_t>();
    uint16_t v;
    bool r;
    {
    
r = ImGui::SliderScalar(label,ImGuiDataType_U16,(void*)&vP,(const void*)&p_min,(const void*)&p_max);
v = vP;
;
    sendValue<uint16_t>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000002f5:
  {
    FFFI_FUNCTION_INVOCATION("SliderUInt16V")
    auto label = receiveString();
    auto vP = receiveValue<uint16_t>();
    auto p_min = receiveValue<uint16_t>();
    auto p_max = receiveValue<uint16_t>();
    auto format = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    uint16_t v;
    bool r;
    {
    
r = ImGui::SliderScalar(label,ImGuiDataType_U16,(void*)&vP,(const void*)&p_min,(const void*)&p_max,format,flags);
v = vP;
;
    sendValue<uint16_t>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000002f6:
  {
    FFFI_FUNCTION_INVOCATION("SliderUInt16NV")
    auto label = receiveString();
    auto vP = receiveSlice<uint16_t>();
    auto v_min = receiveValue<uint16_t>();
    auto v_max = receiveValue<uint16_t>();
    auto format = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    uint16_t* v;
    bool r;
    {
    
size_t v_len = getSliceLength(vP);
r = ImGui::SliderScalarN(label,ImGuiDataType_U16,(void*)vP,(int)v_len,(const void*)&v_min,(const void*)&v_max,format,flags);
v = vP;
;
    sendSlice<uint16_t>(v,v_len);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000002f7:
  {
    FFFI_FUNCTION_INVOCATION("SliderUInt16N")
    auto label = receiveString();
    auto vP = receiveSlice<uint16_t>();
    auto v_min = receiveValue<uint16_t>();
    auto v_max = receiveValue<uint16_t>();
    uint16_t* v;
    bool r;
    {
    
size_t v_len = getSliceLength(vP);
r = ImGui::SliderScalarN(label,ImGuiDataType_U16,(void*)vP,(int)v_len,(const void*)&v_min,(const void*)&v_max);
v = vP;
;
    sendSlice<uint16_t>(v,v_len);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000002f8:
  {
    FFFI_FUNCTION_INVOCATION("SliderUInt32")
    auto label = receiveString();
    auto vP = receiveValue<uint32_t>();
    auto p_min = receiveValue<uint32_t>();
    auto p_max = receiveValue<uint32_t>();
    uint32_t v;
    bool r;
    {
    
r = ImGui::SliderScalar(label,ImGuiDataType_U32,(void*)&vP,(const void*)&p_min,(const void*)&p_max);
v = vP;
;
    sendValue<uint32_t>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000002f9:
  {
    FFFI_FUNCTION_INVOCATION("SliderUInt32V")
    auto label = receiveString();
    auto vP = receiveValue<uint32_t>();
    auto p_min = receiveValue<uint32_t>();
    auto p_max = receiveValue<uint32_t>();
    auto format = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    uint32_t v;
    bool r;
    {
    
r = ImGui::SliderScalar(label,ImGuiDataType_U32,(void*)&vP,(const void*)&p_min,(const void*)&p_max,format,flags);
v = vP;
;
    sendValue<uint32_t>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000002fa:
  {
    FFFI_FUNCTION_INVOCATION("SliderUInt32NV")
    auto label = receiveString();
    auto vP = receiveSlice<uint32_t>();
    auto v_min = receiveValue<uint32_t>();
    auto v_max = receiveValue<uint32_t>();
    auto format = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    uint32_t* v;
    bool r;
    {
    
size_t v_len = getSliceLength(vP);
r = ImGui::SliderScalarN(label,ImGuiDataType_U32,(void*)vP,(int)v_len,(const void*)&v_min,(const void*)&v_max,format,flags);
v = vP;
;
    sendSlice<uint32_t>(v,v_len);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000002fb:
  {
    FFFI_FUNCTION_INVOCATION("SliderUInt32N")
    auto label = receiveString();
    auto vP = receiveSlice<uint32_t>();
    auto v_min = receiveValue<uint32_t>();
    auto v_max = receiveValue<uint32_t>();
    uint32_t* v;
    bool r;
    {
    
size_t v_len = getSliceLength(vP);
r = ImGui::SliderScalarN(label,ImGuiDataType_U32,(void*)vP,(int)v_len,(const void*)&v_min,(const void*)&v_max);
v = vP;
;
    sendSlice<uint32_t>(v,v_len);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000002fc:
  {
    FFFI_FUNCTION_INVOCATION("SliderUInt8")
    auto label = receiveString();
    auto vP = receiveValue<uint8_t>();
    auto p_min = receiveValue<uint8_t>();
    auto p_max = receiveValue<uint8_t>();
    uint8_t v;
    bool r;
    {
    
r = ImGui::SliderScalar(label,ImGuiDataType_U8,(void*)&vP,(const void*)&p_min,(const void*)&p_max);
v = vP;
;
    sendValue<uint8_t>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000002fd:
  {
    FFFI_FUNCTION_INVOCATION("SliderUInt8V")
    auto label = receiveString();
    auto vP = receiveValue<uint8_t>();
    auto p_min = receiveValue<uint8_t>();
    auto p_max = receiveValue<uint8_t>();
    auto format = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    uint8_t v;
    bool r;
    {
    
r = ImGui::SliderScalar(label,ImGuiDataType_U8,(void*)&vP,(const void*)&p_min,(const void*)&p_max,format,flags);
v = vP;
;
    sendValue<uint8_t>(v);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000002fe:
  {
    FFFI_FUNCTION_INVOCATION("SliderUInt8NV")
    auto label = receiveString();
    auto vP = receiveSlice<uint8_t>();
    auto v_min = receiveValue<uint8_t>();
    auto v_max = receiveValue<uint8_t>();
    auto format = receiveString();
    auto flags = receiveValueSignMagnitude<int>();
    uint8_t* v;
    bool r;
    {
    
size_t v_len = getSliceLength(vP);
r = ImGui::SliderScalarN(label,ImGuiDataType_U8,(void*)vP,(int)v_len,(const void*)&v_min,(const void*)&v_max,format,flags);
v = vP;
;
    sendSlice<uint8_t>(v,v_len);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x000002ff:
  {
    FFFI_FUNCTION_INVOCATION("SliderUInt8N")
    auto label = receiveString();
    auto vP = receiveSlice<uint8_t>();
    auto v_min = receiveValue<uint8_t>();
    auto v_max = receiveValue<uint8_t>();
    uint8_t* v;
    bool r;
    {
    
size_t v_len = getSliceLength(vP);
r = ImGui::SliderScalarN(label,ImGuiDataType_U8,(void*)vP,(int)v_len,(const void*)&v_min,(const void*)&v_max);
v = vP;
;
    sendSlice<uint8_t>(v,v_len);
    sendValue<bool>(r);
    flushSend();
  }
  }
  break;
case 0x00000300:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerDots")
    auto label = receiveString();
    auto nextdotP = receiveValue<float>();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    float nextdot;
    {
    ImSpinner::SpinnerDots(label, &nextdotP, radius, thickness);
nextdot = nextdotP;;
    sendValue<float>(nextdot);
    flushSend();
  }
  }
  break;
case 0x00000301:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerDotsV")
    auto label = receiveString();
    auto nextdotP = receiveValue<float>();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto dots = receiveValue<uint64_t>();
    auto minth = receiveValue<float>();
    float nextdot;
    {
    ImSpinner::SpinnerDots(label, &nextdotP, radius, thickness, color, speed, dots, minth);
nextdot = nextdotP;;
    sendValue<float>(nextdot);
    flushSend();
  }
  }
  break;
case 0x00000302:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerDemos")
    {
    ImSpinner::demoSpinners();
  }
  }
  break;
case 0x00000303:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerRainbow")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    {
    ImSpinner::SpinnerRainbow(label, radius, thickness, color, speed);
  }
  }
  break;
case 0x00000304:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerRainbowV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto ang_min = receiveValue<float>();
    auto ang_max = receiveValue<float>();
    auto arcs = receiveValueSignMagnitude<int>();
    auto mode = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerRainbow(label, radius, thickness, color, speed, ang_min, ang_max, arcs, mode);
  }
  }
  break;
case 0x00000305:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerRainbowMix")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    {
    ImSpinner::SpinnerRainbowMix(label, radius, thickness, color, speed);
  }
  }
  break;
case 0x00000306:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerRainbowMixV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto ang_min = receiveValue<float>();
    auto ang_max = receiveValue<float>();
    auto arcs = receiveValueSignMagnitude<int>();
    auto mode = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerRainbowMix(label, radius, thickness, color, speed, ang_min, ang_max, arcs, mode);
  }
  }
  break;
case 0x00000307:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerRotatingHeart")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    {
    ImSpinner::SpinnerRotatingHeart(label, radius, thickness, color, speed);
  }
  }
  break;
case 0x00000308:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerRotatingHeartV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto ang_min = receiveValue<float>();
    {
    ImSpinner::SpinnerRotatingHeart(label, radius, thickness, color, speed, ang_min);
  }
  }
  break;
case 0x00000309:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerAng")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerAng(label, radius, thickness);
  }
  }
  break;
case 0x0000030a:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerAngV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto bg = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto angle = receiveValue<float>();
    auto mode = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerAng(label, radius, thickness, color, bg, speed, angle, mode);
  }
  }
  break;
case 0x0000030b:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerAng8")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerAng8(label, radius, thickness);
  }
  }
  break;
case 0x0000030c:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerAng8V")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto bg = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto angle = receiveValue<float>();
    auto mode = receiveValueSignMagnitude<int>();
    auto rkoef = receiveValue<float>();
    {
    ImSpinner::SpinnerAng8(label, radius, thickness, color, bg, speed, angle, mode, rkoef);
  }
  }
  break;
case 0x0000030d:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerAngMix")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerAngMix(label, radius, thickness);
  }
  }
  break;
case 0x0000030e:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerAngMixV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto angle = receiveValue<float>();
    auto arcs = receiveValueSignMagnitude<int>();
    auto mode = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerAngMix(label, radius, thickness, color, speed, angle, arcs, mode);
  }
  }
  break;
case 0x0000030f:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerLoadingRing")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerLoadingRing(label, radius, thickness);
  }
  }
  break;
case 0x00000310:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerLoadingRingV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto bg = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto segments = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerLoadingRing(label, radius, thickness, color, bg, speed, segments);
  }
  }
  break;
case 0x00000311:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerClock")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerClock(label, radius, thickness);
  }
  }
  break;
case 0x00000312:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerClockV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto bg = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    {
    ImSpinner::SpinnerClock(label, radius, thickness, color, bg, speed);
  }
  }
  break;
case 0x00000313:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerPulsar")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerPulsar(label, radius, thickness);
  }
  }
  break;
case 0x00000314:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerPulsarV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto bg = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto sequence = receiveValue<bool>();
    auto angle = receiveValue<float>();
    auto mode = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerPulsar(label, radius, thickness, bg, speed, sequence, angle, mode);
  }
  }
  break;
case 0x00000315:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerTwinPulsar")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerTwinPulsar(label, radius, thickness);
  }
  }
  break;
case 0x00000316:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerTwinPulsarV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto rings = receiveValueSignMagnitude<int>();
    auto mode = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerTwinPulsar(label, radius, thickness, color, speed, rings, mode);
  }
  }
  break;
case 0x00000317:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerFadePulsar")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    {
    ImSpinner::SpinnerFadePulsar(label, radius);
  }
  }
  break;
case 0x00000318:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerFadePulsarV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto rings = receiveValueSignMagnitude<int>();
    auto mode = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerFadePulsar(label, radius, color, speed, rings, mode);
  }
  }
  break;
case 0x00000319:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerFadePulsarSquare")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    {
    ImSpinner::SpinnerFadePulsarSquare(label, radius);
  }
  }
  break;
case 0x0000031a:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerFadePulsarSquareV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto rings = receiveValueSignMagnitude<int>();
    auto mode = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerFadePulsarSquare(label, radius, color, speed, rings, mode);
  }
  }
  break;
case 0x0000031b:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerCircularLines")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    {
    ImSpinner::SpinnerCircularLines(label, radius);
  }
  }
  break;
case 0x0000031c:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerCircularLinesV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto lines = receiveValueSignMagnitude<int>();
    auto mode = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerCircularLines(label, radius, color, speed, lines, mode);
  }
  }
  break;
case 0x0000031d:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerVDots")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerVDots(label, radius, thickness);
  }
  }
  break;
case 0x0000031e:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerVDotsV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto bgcolor = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto dots = receiveValue<uint64_t>();
    auto mdots = receiveValue<uint64_t>();
    auto mode = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerVDots(label, radius, thickness, color, bgcolor, speed, dots, mdots, mode);
  }
  }
  break;
case 0x0000031f:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerBounceDots")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerBounceDots(label, radius, thickness);
  }
  }
  break;
case 0x00000320:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerBounceDotsV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto dots = receiveValue<uint64_t>();
    auto mode = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerBounceDots(label, radius, thickness, color, speed, dots, mode);
  }
  }
  break;
case 0x00000321:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerZipDots")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerZipDots(label, radius, thickness);
  }
  }
  break;
case 0x00000322:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerZipDotsV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto dots = receiveValue<uint64_t>();
    {
    ImSpinner::SpinnerZipDots(label, radius, thickness, color, speed, dots);
  }
  }
  break;
case 0x00000323:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerDotsToPoints")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto offset_k = receiveValue<float>();
    {
    ImSpinner::SpinnerDotsToPoints(label, radius, thickness, offset_k);
  }
  }
  break;
case 0x00000324:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerDotsToPointsV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto offset_k = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto dots = receiveValue<uint64_t>();
    {
    ImSpinner::SpinnerDotsToPoints(label, radius, thickness, offset_k, color, speed, dots);
  }
  }
  break;
case 0x00000325:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerDotsToBar")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto offset_k = receiveValue<float>();
    {
    ImSpinner::SpinnerDotsToBar(label, radius, thickness, offset_k);
  }
  }
  break;
case 0x00000326:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerDotsToBarV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto offset_k = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto dots = receiveValue<uint64_t>();
    {
    ImSpinner::SpinnerDotsToBar(label, radius, thickness, offset_k, color, speed, dots);
  }
  }
  break;
case 0x00000327:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerWaveDots")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerWaveDots(label, radius, thickness);
  }
  }
  break;
case 0x00000328:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerWaveDotsV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto lt = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerWaveDots(label, radius, thickness, color, speed, lt);
  }
  }
  break;
case 0x00000329:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerFadeDots")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerFadeDots(label, radius, thickness);
  }
  }
  break;
case 0x0000032a:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerFadeDotsV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto lt = receiveValueSignMagnitude<int>();
    auto mode = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerFadeDots(label, radius, thickness, color, speed, lt, mode);
  }
  }
  break;
case 0x0000032b:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerThreeDots")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerThreeDots(label, radius, thickness);
  }
  }
  break;
case 0x0000032c:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerThreeDotsV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto lt = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerThreeDots(label, radius, thickness, color, speed, lt);
  }
  }
  break;
case 0x0000032d:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerFiveDots")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerFiveDots(label, radius, thickness);
  }
  }
  break;
case 0x0000032e:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerFiveDotsV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto lt = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerFiveDots(label, radius, thickness, color, speed, lt);
  }
  }
  break;
case 0x0000032f:
  {
    FFFI_FUNCTION_INVOCATION("Spinner4Caleidospcope")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::Spinner4Caleidospcope(label, radius, thickness);
  }
  }
  break;
case 0x00000330:
  {
    FFFI_FUNCTION_INVOCATION("Spinner4CaleidospcopeV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto lt = receiveValueSignMagnitude<int>();
    {
    ImSpinner::Spinner4Caleidospcope(label, radius, thickness, color, speed, lt);
  }
  }
  break;
case 0x00000331:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerMultiFadeDots")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerMultiFadeDots(label, radius, thickness);
  }
  }
  break;
case 0x00000332:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerMultiFadeDotsV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto lt = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerMultiFadeDots(label, radius, thickness, color, speed, lt);
  }
  }
  break;
case 0x00000333:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerThickToSin")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerThickToSin(label, radius, thickness);
  }
  }
  break;
case 0x00000334:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerThickToSinV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto lt = receiveValueSignMagnitude<int>();
    auto mode = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerThickToSin(label, radius, thickness, color, speed, lt, mode);
  }
  }
  break;
case 0x00000335:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerScaleDots")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerScaleDots(label, radius, thickness);
  }
  }
  break;
case 0x00000336:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerScaleDotsV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto lt = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerScaleDots(label, radius, thickness, color, speed, lt);
  }
  }
  break;
case 0x00000337:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerSquareSpins")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerSquareSpins(label, radius, thickness);
  }
  }
  break;
case 0x00000338:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerSquareSpinsV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    {
    ImSpinner::SpinnerSquareSpins(label, radius, thickness, color, speed);
  }
  }
  break;
case 0x00000339:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerMovingDots")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerMovingDots(label, radius, thickness);
  }
  }
  break;
case 0x0000033a:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerMovingDotsV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto dots = receiveValue<uint64_t>();
    {
    ImSpinner::SpinnerMovingDots(label, radius, thickness, color, speed, dots);
  }
  }
  break;
case 0x0000033b:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerRotateDots")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerRotateDots(label, radius, thickness);
  }
  }
  break;
case 0x0000033c:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerRotateDotsV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto dots = receiveValueSignMagnitude<int>();
    auto mode = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerRotateDots(label, radius, thickness, color, speed, dots, mode);
  }
  }
  break;
case 0x0000033d:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerOrionDots")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerOrionDots(label, radius, thickness);
  }
  }
  break;
case 0x0000033e:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerOrionDotsV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto arcs = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerOrionDots(label, radius, thickness, color, speed, arcs);
  }
  }
  break;
case 0x0000033f:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerGalaxyDots")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerGalaxyDots(label, radius, thickness);
  }
  }
  break;
case 0x00000340:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerGalaxyDotsV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto arcs = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerGalaxyDots(label, radius, thickness, color, speed, arcs);
  }
  }
  break;
case 0x00000341:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerTwinAng")
    auto label = receiveString();
    auto radius1 = receiveValue<float>();
    auto radius2 = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerTwinAng(label, radius1, radius2, thickness);
  }
  }
  break;
case 0x00000342:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerTwinAngV")
    auto label = receiveString();
    auto radius1 = receiveValue<float>();
    auto radius2 = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color1 = receiveValue<uint32_t>();
    auto color2 = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto angle = receiveValue<float>();
    auto mode = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerTwinAng(label, radius1, radius2, thickness, color1, color2, speed, angle, mode);
  }
  }
  break;
case 0x00000343:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerFilling")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerFilling(label, radius, thickness);
  }
  }
  break;
case 0x00000344:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerFillingV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color1 = receiveValue<uint32_t>();
    auto color2 = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    {
    ImSpinner::SpinnerFilling(label, radius, thickness, color1, color2, speed);
  }
  }
  break;
case 0x00000345:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerTopup")
    auto label = receiveString();
    auto radius1 = receiveValue<float>();
    auto radius2 = receiveValue<float>();
    {
    ImSpinner::SpinnerTopup(label, radius1, radius2);
  }
  }
  break;
case 0x00000346:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerTopupV")
    auto label = receiveString();
    auto radius1 = receiveValue<float>();
    auto radius2 = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto fg = receiveValue<uint32_t>();
    auto bg = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    {
    ImSpinner::SpinnerTopup(label, radius1, radius2, color, fg, bg, speed);
  }
  }
  break;
case 0x00000347:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerTwinAng180")
    auto label = receiveString();
    auto radius1 = receiveValue<float>();
    auto radius2 = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerTwinAng180(label, radius1, radius2, thickness);
  }
  }
  break;
case 0x00000348:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerTwinAng180V")
    auto label = receiveString();
    auto radius1 = receiveValue<float>();
    auto radius2 = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color1 = receiveValue<uint32_t>();
    auto color2 = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto angle = receiveValue<float>();
    auto mode = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerTwinAng180(label, radius1, radius2, thickness, color1, color2, speed, angle, mode);
  }
  }
  break;
case 0x00000349:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerTwinAng360")
    auto label = receiveString();
    auto radius1 = receiveValue<float>();
    auto radius2 = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerTwinAng360(label, radius1, radius2, thickness);
  }
  }
  break;
case 0x0000034a:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerTwinAng360V")
    auto label = receiveString();
    auto radius1 = receiveValue<float>();
    auto radius2 = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color1 = receiveValue<uint32_t>();
    auto color2 = receiveValue<uint32_t>();
    auto speed1 = receiveValue<float>();
    auto speed2 = receiveValue<float>();
    auto mode = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerTwinAng360(label, radius1, radius2, thickness, color1, color2, speed1, speed2, mode);
  }
  }
  break;
case 0x0000034b:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerIncDots")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerIncDots(label, radius, thickness);
  }
  }
  break;
case 0x0000034c:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerIncDotsV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto dots = receiveValue<uint64_t>();
    {
    ImSpinner::SpinnerIncDots(label, radius, thickness, color, speed, dots);
  }
  }
  break;
case 0x0000034d:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerIncFullDots")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerIncFullDots(label, radius, thickness);
  }
  }
  break;
case 0x0000034e:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerIncFullDotsV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto dots = receiveValue<uint64_t>();
    {
    ImSpinner::SpinnerIncFullDots(label, radius, thickness, color, speed, dots);
  }
  }
  break;
case 0x0000034f:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerFadeBars")
    auto label = receiveString();
    auto w = receiveValue<float>();
    {
    ImSpinner::SpinnerFadeBars(label, w);
  }
  }
  break;
case 0x00000350:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerFadeBarsV")
    auto label = receiveString();
    auto w = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto bars = receiveValue<uint64_t>();
    auto scale = receiveValue<bool>();
    {
    ImSpinner::SpinnerFadeBars(label, w, color, speed, bars, scale);
  }
  }
  break;
case 0x00000351:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerFadeTris")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    {
    ImSpinner::SpinnerFadeTris(label, radius);
  }
  }
  break;
case 0x00000352:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerFadeTrisV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto dim = receiveValue<uint64_t>();
    auto scale = receiveValue<bool>();
    auto mode = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerFadeTris(label, radius, color, speed, dim, scale, mode);
  }
  }
  break;
case 0x00000353:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerBarsRotateFade")
    auto label = receiveString();
    auto rmin = receiveValue<float>();
    auto rmax = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerBarsRotateFade(label, rmin, rmax, thickness);
  }
  }
  break;
case 0x00000354:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerBarsRotateFadeV")
    auto label = receiveString();
    auto rmin = receiveValue<float>();
    auto rmax = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto bars = receiveValue<uint64_t>();
    {
    ImSpinner::SpinnerBarsRotateFade(label, rmin, rmax, thickness, color, speed, bars);
  }
  }
  break;
case 0x00000355:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerBarsScaleMiddle")
    auto label = receiveString();
    auto w = receiveValue<float>();
    {
    ImSpinner::SpinnerBarsScaleMiddle(label, w);
  }
  }
  break;
case 0x00000356:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerBarsScaleMiddleV")
    auto label = receiveString();
    auto w = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto bars = receiveValue<uint64_t>();
    {
    ImSpinner::SpinnerBarsScaleMiddle(label, w, color, speed, bars);
  }
  }
  break;
case 0x00000357:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerAngTwin")
    auto label = receiveString();
    auto radius1 = receiveValue<float>();
    auto radius2 = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerAngTwin(label, radius1, radius2, thickness);
  }
  }
  break;
case 0x00000358:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerAngTwinV")
    auto label = receiveString();
    auto radius1 = receiveValue<float>();
    auto radius2 = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto bg = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto angle = receiveValue<float>();
    auto arcs = receiveValue<uint64_t>();
    auto mode = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerAngTwin(label, radius1, radius2, thickness, color, bg, speed, angle, arcs, mode);
  }
  }
  break;
case 0x00000359:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerArcRotation")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerArcRotation(label, radius, thickness);
  }
  }
  break;
case 0x0000035a:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerArcRotationV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto arcs = receiveValue<uint64_t>();
    auto mode = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerArcRotation(label, radius, thickness, color, speed, arcs, mode);
  }
  }
  break;
case 0x0000035b:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerArcFade")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerArcFade(label, radius, thickness);
  }
  }
  break;
case 0x0000035c:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerArcFadeV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto arcs = receiveValue<uint64_t>();
    auto mode = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerArcFade(label, radius, thickness, color, speed, arcs, mode);
  }
  }
  break;
case 0x0000035d:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerSimpleArcFade")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerSimpleArcFade(label, radius, thickness);
  }
  }
  break;
case 0x0000035e:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerSimpleArcFadeV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    {
    ImSpinner::SpinnerSimpleArcFade(label, radius, thickness, color, speed);
  }
  }
  break;
case 0x0000035f:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerSquareStrokeFade")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerSquareStrokeFade(label, radius, thickness);
  }
  }
  break;
case 0x00000360:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerSquareStrokeFadeV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    {
    ImSpinner::SpinnerSquareStrokeFade(label, radius, thickness, color, speed);
  }
  }
  break;
case 0x00000361:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerAsciiSymbolPoints")
    auto label = receiveString();
    auto text = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerAsciiSymbolPoints(label, text, radius, thickness);
  }
  }
  break;
case 0x00000362:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerAsciiSymbolPointsV")
    auto label = receiveString();
    auto text = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    {
    ImSpinner::SpinnerAsciiSymbolPoints(label, text, radius, thickness, color, speed);
  }
  }
  break;
case 0x00000363:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerTextFading")
    auto label = receiveString();
    auto text = receiveString();
    auto radius = receiveValue<float>();
    auto fsize = receiveValue<float>();
    {
    ImSpinner::SpinnerTextFading(label, text, radius, fsize);
  }
  }
  break;
case 0x00000364:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerTextFadingV")
    auto label = receiveString();
    auto text = receiveString();
    auto radius = receiveValue<float>();
    auto fsize = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    {
    ImSpinner::SpinnerTextFading(label, text, radius, fsize, color, speed);
  }
  }
  break;
case 0x00000365:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerSevenSegments")
    auto label = receiveString();
    auto text = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerSevenSegments(label, text, radius, thickness);
  }
  }
  break;
case 0x00000366:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerSevenSegmentsV")
    auto label = receiveString();
    auto text = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    {
    ImSpinner::SpinnerSevenSegments(label, text, radius, thickness, color, speed);
  }
  }
  break;
case 0x00000367:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerSquareStrokeFill")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerSquareStrokeFill(label, radius, thickness);
  }
  }
  break;
case 0x00000368:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerSquareStrokeFillV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    {
    ImSpinner::SpinnerSquareStrokeFill(label, radius, thickness, color, speed);
  }
  }
  break;
case 0x00000369:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerSquareStrokeLoading")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerSquareStrokeLoading(label, radius, thickness);
  }
  }
  break;
case 0x0000036a:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerSquareStrokeLoadingV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    {
    ImSpinner::SpinnerSquareStrokeLoading(label, radius, thickness, color, speed);
  }
  }
  break;
case 0x0000036b:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerSquareLoading")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerSquareLoading(label, radius, thickness);
  }
  }
  break;
case 0x0000036c:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerSquareLoadingV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    {
    ImSpinner::SpinnerSquareLoading(label, radius, thickness, color, speed);
  }
  }
  break;
case 0x0000036d:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerFilledArcFade")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    {
    ImSpinner::SpinnerFilledArcFade(label, radius);
  }
  }
  break;
case 0x0000036e:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerFilledArcFadeV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto arcs = receiveValue<uint64_t>();
    auto mode = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerFilledArcFade(label, radius, color, speed, arcs, mode);
  }
  }
  break;
case 0x0000036f:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerPointsRoller")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerPointsRoller(label, radius, thickness);
  }
  }
  break;
case 0x00000370:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerPointsRollerV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto points = receiveValue<uint64_t>();
    auto circles = receiveValueSignMagnitude<int>();
    auto rspeed = receiveValue<float>();
    {
    ImSpinner::SpinnerPointsRoller(label, radius, thickness, color, speed, points, circles, rspeed);
  }
  }
  break;
case 0x00000371:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerPointsArcBounce")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerPointsArcBounce(label, radius, thickness);
  }
  }
  break;
case 0x00000372:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerPointsArcBounceV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto points = receiveValue<uint64_t>();
    auto circles = receiveValueSignMagnitude<int>();
    auto rspeed = receiveValue<float>();
    {
    ImSpinner::SpinnerPointsArcBounce(label, radius, thickness, color, speed, points, circles, rspeed);
  }
  }
  break;
case 0x00000373:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerFilledArcColor")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    {
    ImSpinner::SpinnerFilledArcColor(label, radius);
  }
  }
  break;
case 0x00000374:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerFilledArcColorV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto bg = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto arcs = receiveValue<uint64_t>();
    {
    ImSpinner::SpinnerFilledArcColor(label, radius, color, bg, speed, arcs);
  }
  }
  break;
case 0x00000375:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerFilledArcRing")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerFilledArcRing(label, radius, thickness);
  }
  }
  break;
case 0x00000376:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerFilledArcRingV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto bg = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto arcs = receiveValue<uint64_t>();
    {
    ImSpinner::SpinnerFilledArcRing(label, radius, thickness, color, bg, speed, arcs);
  }
  }
  break;
case 0x00000377:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerArcWedges")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    {
    ImSpinner::SpinnerArcWedges(label, radius);
  }
  }
  break;
case 0x00000378:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerArcWedgesV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto arcs = receiveValue<uint64_t>();
    auto mode = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerArcWedges(label, radius, color, speed, arcs, mode);
  }
  }
  break;
case 0x00000379:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerTwinBall")
    auto label = receiveString();
    auto radius1 = receiveValue<float>();
    auto radius2 = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto b_thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerTwinBall(label, radius1, radius2, thickness, b_thickness);
  }
  }
  break;
case 0x0000037a:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerTwinBallV")
    auto label = receiveString();
    auto radius1 = receiveValue<float>();
    auto radius2 = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto b_thickness = receiveValue<float>();
    auto ball = receiveValue<uint32_t>();
    auto bg = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto balls = receiveValue<uint64_t>();
    auto mode = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerTwinBall(label, radius1, radius2, thickness, b_thickness, ball, bg, speed, balls, mode);
  }
  }
  break;
case 0x0000037b:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerSolarBalls")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerSolarBalls(label, radius, thickness);
  }
  }
  break;
case 0x0000037c:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerSolarBallsV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto ball = receiveValue<uint32_t>();
    auto bg = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto balls = receiveValue<uint64_t>();
    {
    ImSpinner::SpinnerSolarBalls(label, radius, thickness, ball, bg, speed, balls);
  }
  }
  break;
case 0x0000037d:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerSolarScaleBalls")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerSolarScaleBalls(label, radius, thickness);
  }
  }
  break;
case 0x0000037e:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerSolarScaleBallsV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto ball = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto balls = receiveValue<uint64_t>();
    {
    ImSpinner::SpinnerSolarScaleBalls(label, radius, thickness, ball, speed, balls);
  }
  }
  break;
case 0x0000037f:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerSolarArcs")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerSolarArcs(label, radius, thickness);
  }
  }
  break;
case 0x00000380:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerSolarArcsV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto ball = receiveValue<uint32_t>();
    auto bg = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto balls = receiveValue<uint64_t>();
    {
    ImSpinner::SpinnerSolarArcs(label, radius, thickness, ball, bg, speed, balls);
  }
  }
  break;
case 0x00000381:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerMovingArcs")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerMovingArcs(label, radius, thickness);
  }
  }
  break;
case 0x00000382:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerMovingArcsV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto arcs = receiveValue<uint64_t>();
    {
    ImSpinner::SpinnerMovingArcs(label, radius, thickness, color, speed, arcs);
  }
  }
  break;
case 0x00000383:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerRainbowCircle")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerRainbowCircle(label, radius, thickness);
  }
  }
  break;
case 0x00000384:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerRainbowCircleV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto arcs = receiveValue<uint64_t>();
    auto mode = receiveValue<float>();
    {
    ImSpinner::SpinnerRainbowCircle(label, radius, thickness, color, speed, arcs, mode);
  }
  }
  break;
case 0x00000385:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerBounceBall")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerBounceBall(label, radius, thickness);
  }
  }
  break;
case 0x00000386:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerBounceBallV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto dots = receiveValueSignMagnitude<int>();
    auto shadow = receiveValue<bool>();
    {
    ImSpinner::SpinnerBounceBall(label, radius, thickness, color, speed, dots, shadow);
  }
  }
  break;
case 0x00000387:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerPulsarBall")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerPulsarBall(label, radius, thickness);
  }
  }
  break;
case 0x00000388:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerPulsarBallV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto shadow = receiveValue<bool>();
    auto mode = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerPulsarBall(label, radius, thickness, color, speed, shadow, mode);
  }
  }
  break;
case 0x00000389:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerIncScaleDots")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerIncScaleDots(label, radius, thickness);
  }
  }
  break;
case 0x0000038a:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerIncScaleDotsV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto dots = receiveValue<uint64_t>();
    auto angle = receiveValue<float>();
    auto mode = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerIncScaleDots(label, radius, thickness, color, speed, dots, angle, mode);
  }
  }
  break;
case 0x0000038b:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerSomeScaleDots")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerSomeScaleDots(label, radius, thickness);
  }
  }
  break;
case 0x0000038c:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerSomeScaleDotsV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto dots = receiveValue<uint64_t>();
    auto mode = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerSomeScaleDots(label, radius, thickness, color, speed, dots, mode);
  }
  }
  break;
case 0x0000038d:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerAngTriple")
    auto label = receiveString();
    auto radius1 = receiveValue<float>();
    auto radius2 = receiveValue<float>();
    auto radius3 = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerAngTriple(label, radius1, radius2, radius3, thickness);
  }
  }
  break;
case 0x0000038e:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerAngTripleV")
    auto label = receiveString();
    auto radius1 = receiveValue<float>();
    auto radius2 = receiveValue<float>();
    auto radius3 = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto c1 = receiveValue<uint32_t>();
    auto c2 = receiveValue<uint32_t>();
    auto c3 = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto angle = receiveValue<float>();
    {
    ImSpinner::SpinnerAngTriple(label, radius1, radius2, radius3, thickness, c1, c2, c3, speed, angle);
  }
  }
  break;
case 0x0000038f:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerAngEclipse")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerAngEclipse(label, radius, thickness);
  }
  }
  break;
case 0x00000390:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerAngEclipseV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto angle = receiveValue<float>();
    {
    ImSpinner::SpinnerAngEclipse(label, radius, thickness, color, speed, angle);
  }
  }
  break;
case 0x00000391:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerIngYang")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto reverse = receiveValue<bool>();
    auto yang_detlta_r = receiveValue<float>();
    {
    ImSpinner::SpinnerIngYang(label, radius, thickness, reverse, yang_detlta_r);
  }
  }
  break;
case 0x00000392:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerIngYangV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto reverse = receiveValue<bool>();
    auto yang_detlta_r = receiveValue<float>();
    auto colorI = receiveValue<uint32_t>();
    auto colorY = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto angle = receiveValue<float>();
    auto mode = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerIngYang(label, radius, thickness, reverse, yang_detlta_r, colorI, colorY, speed, angle, mode);
  }
  }
  break;
case 0x00000393:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerGooeyBalls")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    {
    ImSpinner::SpinnerGooeyBalls(label, radius, color, speed);
  }
  }
  break;
case 0x00000394:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerGooeyBallsV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto mode = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerGooeyBalls(label, radius, color, speed, mode);
  }
  }
  break;
case 0x00000395:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerDotsLoading")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto bg = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    {
    ImSpinner::SpinnerDotsLoading(label, radius, thickness, color, bg, speed);
  }
  }
  break;
case 0x00000396:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerRotateGooeyBalls")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto balls = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerRotateGooeyBalls(label, radius, thickness, color, speed, balls);
  }
  }
  break;
case 0x00000397:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerRotateGooeyBallsV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto balls = receiveValueSignMagnitude<int>();
    auto mode = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerRotateGooeyBalls(label, radius, thickness, color, speed, balls, mode);
  }
  }
  break;
case 0x00000398:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerHerbertBalls")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto balls = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerHerbertBalls(label, radius, thickness, color, speed, balls);
  }
  }
  break;
case 0x00000399:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerHerbertBalls3D")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    {
    ImSpinner::SpinnerHerbertBalls3D(label, radius, thickness, color, speed);
  }
  }
  break;
case 0x0000039a:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerRotateTriangles")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto tris = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerRotateTriangles(label, radius, thickness, color, speed, tris);
  }
  }
  break;
case 0x0000039b:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerRotateTrianglesV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto tris = receiveValueSignMagnitude<int>();
    auto mode = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerRotateTriangles(label, radius, thickness, color, speed, tris, mode);
  }
  }
  break;
case 0x0000039c:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerRotateShapes")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto shapes = receiveValueSignMagnitude<int>();
    auto pnt = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerRotateShapes(label, radius, thickness, color, speed, shapes, pnt);
  }
  }
  break;
case 0x0000039d:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerSinSquares")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    {
    ImSpinner::SpinnerSinSquares(label, radius, thickness, color, speed);
  }
  }
  break;
case 0x0000039e:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerSinSquaresV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto mode = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerSinSquares(label, radius, thickness, color, speed, mode);
  }
  }
  break;
case 0x0000039f:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerMoonLine")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerMoonLine(label, radius, thickness);
  }
  }
  break;
case 0x000003a0:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerMoonLineV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto bg = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto angle = receiveValue<float>();
    {
    ImSpinner::SpinnerMoonLine(label, radius, thickness, color, bg, speed, angle);
  }
  }
  break;
case 0x000003a1:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerCircleDrop")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto thickness_drop = receiveValue<float>();
    {
    ImSpinner::SpinnerCircleDrop(label, radius, thickness, thickness_drop);
  }
  }
  break;
case 0x000003a2:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerCircleDropV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto thickness_drop = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto bg = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto angle = receiveValue<float>();
    {
    ImSpinner::SpinnerCircleDrop(label, radius, thickness, thickness_drop, color, bg, speed, angle);
  }
  }
  break;
case 0x000003a3:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerSurroundedIndicator")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerSurroundedIndicator(label, radius, thickness);
  }
  }
  break;
case 0x000003a4:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerSurroundedIndicatorV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto bg = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    {
    ImSpinner::SpinnerSurroundedIndicator(label, radius, thickness, color, bg, speed);
  }
  }
  break;
case 0x000003a5:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerWifiIndicator")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerWifiIndicator(label, radius, thickness);
  }
  }
  break;
case 0x000003a6:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerWifiIndicatorV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto bg = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto cangle = receiveValue<float>();
    auto dots = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerWifiIndicator(label, radius, thickness, color, bg, speed, cangle, dots);
  }
  }
  break;
case 0x000003a7:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerTrianglesSelector")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerTrianglesSelector(label, radius, thickness);
  }
  }
  break;
case 0x000003a8:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerTrianglesSelectorV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto bg = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto bars = receiveValue<uint64_t>();
    {
    ImSpinner::SpinnerTrianglesSelector(label, radius, thickness, color, bg, speed, bars);
  }
  }
  break;
case 0x000003a9:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerFlowingGradient")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerFlowingGradient(label, radius, thickness);
  }
  }
  break;
case 0x000003aa:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerFlowingGradientV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto bg = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto angle = receiveValue<float>();
    {
    ImSpinner::SpinnerFlowingGradient(label, radius, thickness, color, bg, speed, angle);
  }
  }
  break;
case 0x000003ab:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerRotateSegments")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerRotateSegments(label, radius, thickness);
  }
  }
  break;
case 0x000003ac:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerRotateSegmentsV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto arcs = receiveValue<uint64_t>();
    auto layers = receiveValue<uint64_t>();
    auto mode = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerRotateSegments(label, radius, thickness, color, speed, arcs, layers, mode);
  }
  }
  break;
case 0x000003ad:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerLemniscate")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerLemniscate(label, radius, thickness);
  }
  }
  break;
case 0x000003ae:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerLemniscateV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto angle = receiveValue<float>();
    {
    ImSpinner::SpinnerLemniscate(label, radius, thickness, color, speed, angle);
  }
  }
  break;
case 0x000003af:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerRotateGear")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerRotateGear(label, radius, thickness);
  }
  }
  break;
case 0x000003b0:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerRotateGearV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto pins = receiveValue<uint64_t>();
    {
    ImSpinner::SpinnerRotateGear(label, radius, thickness, color, speed, pins);
  }
  }
  break;
case 0x000003b1:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerRotateWheel")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerRotateWheel(label, radius, thickness);
  }
  }
  break;
case 0x000003b2:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerRotateWheelV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto bg_color = receiveValue<uint32_t>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto pins = receiveValue<uint64_t>();
    {
    ImSpinner::SpinnerRotateWheel(label, radius, thickness, bg_color, color, speed, pins);
  }
  }
  break;
case 0x000003b3:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerAtom")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerAtom(label, radius, thickness);
  }
  }
  break;
case 0x000003b4:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerAtomV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto elipses = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerAtom(label, radius, thickness, color, speed, elipses);
  }
  }
  break;
case 0x000003b5:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerPatternRings")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerPatternRings(label, radius, thickness);
  }
  }
  break;
case 0x000003b6:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerPatternRingsV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto elipses = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerPatternRings(label, radius, thickness, color, speed, elipses);
  }
  }
  break;
case 0x000003b7:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerPatternEclipse")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerPatternEclipse(label, radius, thickness);
  }
  }
  break;
case 0x000003b8:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerPatternEclipseV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto elipses = receiveValueSignMagnitude<int>();
    auto delta_a = receiveValue<float>();
    auto delta_y = receiveValue<float>();
    {
    ImSpinner::SpinnerPatternEclipse(label, radius, thickness, color, speed, elipses, delta_a, delta_y);
  }
  }
  break;
case 0x000003b9:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerPatternSphere")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerPatternSphere(label, radius, thickness);
  }
  }
  break;
case 0x000003ba:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerPatternSphereV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto elipses = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerPatternSphere(label, radius, thickness, color, speed, elipses);
  }
  }
  break;
case 0x000003bb:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerRingSynchronous")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerRingSynchronous(label, radius, thickness);
  }
  }
  break;
case 0x000003bc:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerRingSynchronousV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto elipses = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerRingSynchronous(label, radius, thickness, color, speed, elipses);
  }
  }
  break;
case 0x000003bd:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerRingWatermarks")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerRingWatermarks(label, radius, thickness);
  }
  }
  break;
case 0x000003be:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerRingWatermarksV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto elipses = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerRingWatermarks(label, radius, thickness, color, speed, elipses);
  }
  }
  break;
case 0x000003bf:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerRotatedAtom")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerRotatedAtom(label, radius, thickness);
  }
  }
  break;
case 0x000003c0:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerRotatedAtomV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto elipses = receiveValueSignMagnitude<int>();
    auto mode = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerRotatedAtom(label, radius, thickness, color, speed, elipses, mode);
  }
  }
  break;
case 0x000003c1:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerRainbowBalls")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    {
    ImSpinner::SpinnerRainbowBalls(label, radius, thickness, color, speed);
  }
  }
  break;
case 0x000003c2:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerRainbowBallsV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto balls = receiveValueSignMagnitude<int>();
    auto mode = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerRainbowBalls(label, radius, thickness, color, speed, balls, mode);
  }
  }
  break;
case 0x000003c3:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerRainbowShot")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    {
    ImSpinner::SpinnerRainbowShot(label, radius, thickness, color, speed);
  }
  }
  break;
case 0x000003c4:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerRainbowShotV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto balls = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerRainbowShot(label, radius, thickness, color, speed, balls);
  }
  }
  break;
case 0x000003c5:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerSpiral")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerSpiral(label, radius, thickness);
  }
  }
  break;
case 0x000003c6:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerSpiralV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto arcs = receiveValue<uint64_t>();
    {
    ImSpinner::SpinnerSpiral(label, radius, thickness, color, speed, arcs);
  }
  }
  break;
case 0x000003c7:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerSpiralEye")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerSpiralEye(label, radius, thickness);
  }
  }
  break;
case 0x000003c8:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerSpiralEyeV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    {
    ImSpinner::SpinnerSpiralEye(label, radius, thickness, color, speed);
  }
  }
  break;
case 0x000003c9:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerBarChartSine")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    {
    ImSpinner::SpinnerBarChartSine(label, radius, thickness, color, speed);
  }
  }
  break;
case 0x000003ca:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerBarChartSineV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto bars = receiveValueSignMagnitude<int>();
    auto mode = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerBarChartSine(label, radius, thickness, color, speed, bars, mode);
  }
  }
  break;
case 0x000003cb:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerBarChartAdvSine")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    {
    ImSpinner::SpinnerBarChartAdvSine(label, radius, thickness, color, speed);
  }
  }
  break;
case 0x000003cc:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerBarChartAdvSineV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto mode = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerBarChartAdvSine(label, radius, thickness, color, speed, mode);
  }
  }
  break;
case 0x000003cd:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerBarChartAdvSineFade")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    {
    ImSpinner::SpinnerBarChartAdvSineFade(label, radius, thickness, color, speed);
  }
  }
  break;
case 0x000003ce:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerBarChartAdvSineFadeV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto mode = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerBarChartAdvSineFade(label, radius, thickness, color, speed, mode);
  }
  }
  break;
case 0x000003cf:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerBarChartRainbow")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    {
    ImSpinner::SpinnerBarChartRainbow(label, radius, thickness, color, speed);
  }
  }
  break;
case 0x000003d0:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerBarChartRainbowV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto bars = receiveValueSignMagnitude<int>();
    auto mode = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerBarChartRainbow(label, radius, thickness, color, speed, bars, mode);
  }
  }
  break;
case 0x000003d1:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerBlocks")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto bg = receiveValue<uint32_t>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    {
    ImSpinner::SpinnerBlocks(label, radius, thickness, bg, color, speed);
  }
  }
  break;
case 0x000003d2:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerTwinBlocks")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto bg = receiveValue<uint32_t>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    {
    ImSpinner::SpinnerTwinBlocks(label, radius, thickness, bg, color, speed);
  }
  }
  break;
case 0x000003d3:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerSquareRandomDots")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto bg = receiveValue<uint32_t>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    {
    ImSpinner::SpinnerSquareRandomDots(label, radius, thickness, bg, color, speed);
  }
  }
  break;
case 0x000003d4:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerScaleBlocks")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    {
    ImSpinner::SpinnerScaleBlocks(label, radius, thickness, color, speed);
  }
  }
  break;
case 0x000003d5:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerScaleBlocksV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto mode = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerScaleBlocks(label, radius, thickness, color, speed, mode);
  }
  }
  break;
case 0x000003d6:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerScaleSquares")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thikness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    {
    ImSpinner::SpinnerScaleSquares(label, radius, thikness, color, speed);
  }
  }
  break;
case 0x000003d7:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerSquishSquare")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    {
    ImSpinner::SpinnerSquishSquare(label, radius, color, speed);
  }
  }
  break;
case 0x000003d8:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerFluid")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    {
    ImSpinner::SpinnerFluid(label, radius, color, speed);
  }
  }
  break;
case 0x000003d9:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerFluidV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto bars = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerFluid(label, radius, color, speed, bars);
  }
  }
  break;
case 0x000003da:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerFluidPoints")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    {
    ImSpinner::SpinnerFluidPoints(label, radius, thickness, color, speed);
  }
  }
  break;
case 0x000003db:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerFluidPointsV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto dots = receiveValue<uint64_t>();
    auto delta = receiveValue<float>();
    {
    ImSpinner::SpinnerFluidPoints(label, radius, thickness, color, speed, dots, delta);
  }
  }
  break;
case 0x000003dc:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerArcPolarFade")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    {
    ImSpinner::SpinnerArcPolarFade(label, radius);
  }
  }
  break;
case 0x000003dd:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerArcPolarFadeV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto arcs = receiveValue<uint64_t>();
    auto mode = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerArcPolarFade(label, radius, color, speed, arcs, mode);
  }
  }
  break;
case 0x000003de:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerArcPolarRadius")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    {
    ImSpinner::SpinnerArcPolarRadius(label, radius);
  }
  }
  break;
case 0x000003df:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerArcPolarRadiusV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto arcs = receiveValue<uint64_t>();
    auto mode = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerArcPolarRadius(label, radius, color, speed, arcs, mode);
  }
  }
  break;
case 0x000003e0:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerCaleidoscope")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerCaleidoscope(label, radius, thickness);
  }
  }
  break;
case 0x000003e1:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerCaleidoscopeV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto arcs = receiveValue<uint64_t>();
    auto mode = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerCaleidoscope(label, radius, thickness, color, speed, arcs, mode);
  }
  }
  break;
case 0x000003e2:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerHboDots")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerHboDots(label, radius, thickness);
  }
  }
  break;
case 0x000003e3:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerHboDotsV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto minfade = receiveValue<float>();
    auto ryk = receiveValue<float>();
    auto speed = receiveValue<float>();
    auto dots = receiveValue<uint64_t>();
    auto mode = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerHboDots(label, radius, thickness, color, minfade, ryk, speed, dots, mode);
  }
  }
  break;
case 0x000003e4:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerMoonDots")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto first = receiveValue<uint32_t>();
    auto second = receiveValue<uint32_t>();
    {
    ImSpinner::SpinnerMoonDots(label, radius, thickness, first, second);
  }
  }
  break;
case 0x000003e5:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerMoonDotsV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto first = receiveValue<uint32_t>();
    auto second = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    {
    ImSpinner::SpinnerMoonDots(label, radius, thickness, first, second, speed);
  }
  }
  break;
case 0x000003e6:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerTwinHboDots")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerTwinHboDots(label, radius, thickness);
  }
  }
  break;
case 0x000003e7:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerTwinHboDotsV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto minfade = receiveValue<float>();
    auto ryk = receiveValue<float>();
    auto speed = receiveValue<float>();
    auto dots = receiveValue<uint64_t>();
    auto delta = receiveValue<float>();
    {
    ImSpinner::SpinnerTwinHboDots(label, radius, thickness, color, minfade, ryk, speed, dots, delta);
  }
  }
  break;
case 0x000003e8:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerThreeDotsStar")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerThreeDotsStar(label, radius, thickness);
  }
  }
  break;
case 0x000003e9:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerThreeDotsStarV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto minfade = receiveValue<float>();
    auto ryk = receiveValue<float>();
    auto speed = receiveValue<float>();
    auto delta = receiveValue<float>();
    {
    ImSpinner::SpinnerThreeDotsStar(label, radius, thickness, color, minfade, ryk, speed, delta);
  }
  }
  break;
case 0x000003ea:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerSineArcs")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerSineArcs(label, radius, thickness);
  }
  }
  break;
case 0x000003eb:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerSineArcsV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    {
    ImSpinner::SpinnerSineArcs(label, radius, thickness, color, speed);
  }
  }
  break;
case 0x000003ec:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerTrianglesShift")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerTrianglesShift(label, radius, thickness);
  }
  }
  break;
case 0x000003ed:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerTrianglesShiftV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto bg = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto bars = receiveValue<uint64_t>();
    {
    ImSpinner::SpinnerTrianglesShift(label, radius, thickness, color, bg, speed, bars);
  }
  }
  break;
case 0x000003ee:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerPointsShift")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerPointsShift(label, radius, thickness);
  }
  }
  break;
case 0x000003ef:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerPointsShiftV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto bg = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto bars = receiveValue<uint64_t>();
    {
    ImSpinner::SpinnerPointsShift(label, radius, thickness, color, bg, speed, bars);
  }
  }
  break;
case 0x000003f0:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerSwingDots")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerSwingDots(label, radius, thickness);
  }
  }
  break;
case 0x000003f1:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerSwingDotsV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    {
    ImSpinner::SpinnerSwingDots(label, radius, thickness, color, speed);
  }
  }
  break;
case 0x000003f2:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerCircularPoints")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerCircularPoints(label, radius, thickness);
  }
  }
  break;
case 0x000003f3:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerCircularPointsV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto lines = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerCircularPoints(label, radius, thickness, color, speed, lines);
  }
  }
  break;
case 0x000003f4:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerCurvedCircle")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerCurvedCircle(label, radius, thickness);
  }
  }
  break;
case 0x000003f5:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerCurvedCircleV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto circles = receiveValue<uint64_t>();
    {
    ImSpinner::SpinnerCurvedCircle(label, radius, thickness, color, speed, circles);
  }
  }
  break;
case 0x000003f6:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerModCircle")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerModCircle(label, radius, thickness);
  }
  }
  break;
case 0x000003f7:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerModCircleV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto ang_min = receiveValue<float>();
    auto ang_max = receiveValue<float>();
    auto speed = receiveValue<float>();
    {
    ImSpinner::SpinnerModCircle(label, radius, thickness, color, ang_min, ang_max, speed);
  }
  }
  break;
case 0x000003f8:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerDnaDots")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerDnaDots(label, radius, thickness);
  }
  }
  break;
case 0x000003f9:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerDnaDotsV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto lt = receiveValueSignMagnitude<int>();
    auto delta = receiveValue<float>();
    auto mode = receiveValue<bool>();
    {
    ImSpinner::SpinnerDnaDots(label, radius, thickness, color, speed, lt, delta, mode);
  }
  }
  break;
case 0x000003fa:
  {
    FFFI_FUNCTION_INVOCATION("Spinner3SmuggleDots")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::Spinner3SmuggleDots(label, radius, thickness);
  }
  }
  break;
case 0x000003fb:
  {
    FFFI_FUNCTION_INVOCATION("Spinner3SmuggleDotsV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto lt = receiveValueSignMagnitude<int>();
    auto delta = receiveValue<float>();
    auto mode = receiveValue<bool>();
    {
    ImSpinner::Spinner3SmuggleDots(label, radius, thickness, color, speed, lt, delta, mode);
  }
  }
  break;
case 0x000003fc:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerRotateSegmentsPulsar")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerRotateSegmentsPulsar(label, radius, thickness);
  }
  }
  break;
case 0x000003fd:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerRotateSegmentsPulsarV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto arcs = receiveValue<uint64_t>();
    auto layers = receiveValue<uint64_t>();
    {
    ImSpinner::SpinnerRotateSegmentsPulsar(label, radius, thickness, color, speed, arcs, layers);
  }
  }
  break;
case 0x000003fe:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerSplineAng")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    {
    ImSpinner::SpinnerSplineAng(label, radius, thickness);
  }
  }
  break;
case 0x000003ff:
  {
    FFFI_FUNCTION_INVOCATION("SpinnerSplineAngV")
    auto label = receiveString();
    auto radius = receiveValue<float>();
    auto thickness = receiveValue<float>();
    auto color = receiveValue<uint32_t>();
    auto bg = receiveValue<uint32_t>();
    auto speed = receiveValue<float>();
    auto angle = receiveValue<float>();
    auto mode = receiveValueSignMagnitude<int>();
    {
    ImSpinner::SpinnerSplineAng(label, radius, thickness, color, bg, speed, angle, mode);
  }
  }
  break;
case 0x00000400:
  {
    FFFI_FUNCTION_INVOCATION("Splitter")
    auto split_vertically = receiveValue<bool>();
    auto thickness = receiveValue<float>();
    auto size1P = receiveValue<float>();
    auto size2P = receiveValue<float>();
    auto min_size1 = receiveValue<float>();
    auto min_size2 = receiveValue<float>();
    bool r;
    float size1;
    float size2;
    {
    r = ImGui::Splitter(split_vertically, thickness, &size1P, &size2P, min_size1, min_size2);
         size1 = size1P;
         size2 = size2P;;
    sendValue<bool>(r);
    sendValue<float>(size1);
    sendValue<float>(size2);
    flushSend();
  }
  }
  break;
case 0x00000401:
  {
    FFFI_FUNCTION_INVOCATION("SplitterV")
    auto split_vertically = receiveValue<bool>();
    auto thickness = receiveValue<float>();
    auto size1P = receiveValue<float>();
    auto size2P = receiveValue<float>();
    auto min_size1 = receiveValue<float>();
    auto min_size2 = receiveValue<float>();
    auto splitter_long_axis = receiveValue<float>();
    bool r;
    float size1;
    float size2;
    {
    r = ImGui::Splitter(split_vertically, thickness, &size1P, &size2P, min_size1, min_size2, splitter_long_axis);
         size1 = size1P;
         size2 = size2P;;
    sendValue<bool>(r);
    sendValue<float>(size1);
    sendValue<float>(size2);
    flushSend();
  }
  }
  break;
case 0x00000402:
  {
    FFFI_FUNCTION_INVOCATION("loadStyle")
    auto ptr = receiveValue<uintptr_t>();
    auto bs = receiveSlice<bool>();
    auto fs = receiveSlice<float>();
    auto vec2s = receiveSlice<float>();
    auto cols = receiveSlice<float>();
    auto dirs = receiveSlice<int>();
    auto hovers = receiveSlice<int>();
    {
    
   int i;
   auto s = (ImGuiStyle *)ptr;
   
   i = 0;
   s->AntiAliasedLines = bs[i++];
   s->AntiAliasedLinesUseTex = bs[i++];
   s->AntiAliasedFill = bs[i++];

   i = 0;
   s->Alpha = fs[i++];
   s->DisabledAlpha = fs[i++];
   s->WindowRounding = fs[i++];
   s->WindowBorderSize = fs[i++];
   s->ChildRounding = fs[i++];
   s->ChildRounding = fs[i++];
   s->ChildBorderSize = fs[i++];
   s->PopupRounding = fs[i++];
   s->PopupBorderSize = fs[i++];
   s->FrameRounding = fs[i++];
   s->FrameBorderSize = fs[i++];
   s->IndentSpacing = fs[i++];
   s->ColumnsMinSpacing = fs[i++];
   s->ScrollbarSize = fs[i++];
   s->ScrollbarRounding = fs[i++];
   s->GrabMinSize = fs[i++];
   s->GrabRounding = fs[i++];
   s->LogSliderDeadzone = fs[i++];
   s->TabRounding = fs[i++];
   s->TabBorderSize = fs[i++];
   s->TabMinWidthForCloseButton = fs[i++];
   s->TabBarBorderSize = fs[i++];
   s->SeparatorTextBorderSize = fs[i++];
   s->DockingSeparatorSize = fs[i++];
   s->MouseCursorScale = fs[i++];
   s->CurveTessellationTol = fs[i++];
   s->CircleTessellationMaxError = fs[i++];
   s->HoverStationaryDelay = fs[i++];
   s->HoverDelayShort = fs[i++];
   s->HoverDelayNormal = fs[i++];
   
   i = 0;
   s->WindowPadding.x = vec2s[i++];
   s->WindowPadding.y = vec2s[i++];
   s->WindowMinSize.x = vec2s[i++];
   s->WindowMinSize.y = vec2s[i++];
   s->WindowTitleAlign.x = vec2s[i++];
   s->WindowTitleAlign.y = vec2s[i++];
   s->FramePadding.x = vec2s[i++];
   s->FramePadding.y = vec2s[i++];
   s->ItemSpacing.x = vec2s[i++];
   s->ItemSpacing.y = vec2s[i++];
   s->ItemInnerSpacing.x = vec2s[i++];
   s->ItemInnerSpacing.y = vec2s[i++];
   s->CellPadding.x = vec2s[i++];
   s->CellPadding.y = vec2s[i++];
   s->TouchExtraPadding.x = vec2s[i++];
   s->TouchExtraPadding.y = vec2s[i++];
   s->ButtonTextAlign.x = vec2s[i++];
   s->ButtonTextAlign.y = vec2s[i++];
   s->SelectableTextAlign.x = vec2s[i++];
   s->SelectableTextAlign.y = vec2s[i++];
   s->SeparatorTextAlign.x = vec2s[i++];
   s->SeparatorTextAlign.y = vec2s[i++];
   s->SeparatorTextPadding.x = vec2s[i++];
   s->SeparatorTextPadding.y = vec2s[i++];
   s->DisplayWindowPadding.x = vec2s[i++];
   s->DisplayWindowPadding.y = vec2s[i++];
   s->DisplaySafeAreaPadding.x = vec2s[i++];
   s->DisplaySafeAreaPadding.y = vec2s[i++];

   i = 0;
   for(i = 0;i<ImGuiCol_COUNT;i++) {
      s->Colors[i].x = cols[i*4+0];
      s->Colors[i].y = cols[i*4+1];
      s->Colors[i].z = cols[i*4+2];
      s->Colors[i].w = cols[i*4+3];
   }

   i = 0;
   s->WindowMenuButtonPosition = ImGuiDir(dirs[i++]);
   s->ColorButtonPosition = ImGuiDir(dirs[i++]);
   
   i = 0;
   s->HoverFlagsForTooltipMouse = hovers[i++];
   s->HoverFlagsForTooltipNav = hovers[i++];
;
  }
  }
  break;
case 0x00000403:
  {
    FFFI_FUNCTION_INVOCATION("GetStyle")
    uintptr_t r;
    {
    r = (uintptr_t)&ImGui::GetStyle();
    sendValue(r);
    flushSend();
  }
  }
  break;
case 0x00000404:
  {
    FFFI_FUNCTION_INVOCATION("dumpStyle")
    auto ptr = receiveValue<uintptr_t>();
    bool* bs;
    float* fs;
    float* vec2s;
    float* cols;
    int* dirs;
    int* hovers;
    {
    
   auto s = (ImGuiStyle*)ptr;
   size_t bs_len = 3;
   bs = (decltype(bs))arenaCalloc(bs_len,sizeof(*bs));
   size_t fs_len = 30;
   fs = (decltype(fs))arenaCalloc(fs_len,sizeof(*fs));
   size_t vec2s_len = 14*2;
   vec2s = (decltype(vec2s))arenaCalloc(vec2s_len,sizeof(*vec2s));
   size_t cols_len = 4*ImGuiCol_COUNT;
   cols = (decltype(cols))arenaCalloc(cols_len,sizeof(*cols));
   size_t dirs_len = 2;
   dirs = (decltype(dirs))arenaCalloc(dirs_len,sizeof(*dirs));
   size_t hovers_len = 2;
   hovers = (decltype(hovers))arenaCalloc(hovers_len,sizeof(*hovers));

   int i;
   
   i = 0;
   bs[i++] = s->AntiAliasedLines;
   bs[i++] = s->AntiAliasedLinesUseTex;
   bs[i++] = s->AntiAliasedFill;

   i = 0;
   fs[i++] = s->Alpha;
   fs[i++] = s->DisabledAlpha;
   fs[i++] = s->WindowRounding;
   fs[i++] = s->WindowBorderSize;
   fs[i++] = s->ChildRounding;
   fs[i++] = s->ChildRounding;
   fs[i++] = s->ChildBorderSize;
   fs[i++] = s->PopupRounding;
   fs[i++] = s->PopupBorderSize;
   fs[i++] = s->FrameRounding;
   fs[i++] = s->FrameBorderSize;
   fs[i++] = s->IndentSpacing;
   fs[i++] = s->ColumnsMinSpacing;
   fs[i++] = s->ScrollbarSize;
   fs[i++] = s->ScrollbarRounding;
   fs[i++] = s->GrabMinSize;
   fs[i++] = s->GrabRounding;
   fs[i++] = s->LogSliderDeadzone;
   fs[i++] = s->TabRounding;
   fs[i++] = s->TabBorderSize;
   fs[i++] = s->TabMinWidthForCloseButton;
   fs[i++] = s->TabBarBorderSize;
   fs[i++] = s->SeparatorTextBorderSize;
   fs[i++] = s->DockingSeparatorSize;
   fs[i++] = s->MouseCursorScale;
   fs[i++] = s->CurveTessellationTol;
   fs[i++] = s->CircleTessellationMaxError;
   fs[i++] = s->HoverStationaryDelay;
   fs[i++] = s->HoverDelayShort;
   fs[i++] = s->HoverDelayNormal;
   
   i = 0;
   vec2s[i++] = s->WindowPadding.x;
   vec2s[i++] = s->WindowPadding.y;
   vec2s[i++] = s->WindowMinSize.x;
   vec2s[i++] = s->WindowMinSize.y;
   vec2s[i++] = s->WindowTitleAlign.x;
   vec2s[i++] = s->WindowTitleAlign.y;
   vec2s[i++] = s->FramePadding.x;
   vec2s[i++] = s->FramePadding.y;
   vec2s[i++] = s->ItemSpacing.x;
   vec2s[i++] = s->ItemSpacing.y;
   vec2s[i++] = s->ItemInnerSpacing.x;
   vec2s[i++] = s->ItemInnerSpacing.y;
   vec2s[i++] = s->CellPadding.x;
   vec2s[i++] = s->CellPadding.y;
   vec2s[i++] = s->TouchExtraPadding.x;
   vec2s[i++] = s->TouchExtraPadding.y;
   vec2s[i++] = s->ButtonTextAlign.x;
   vec2s[i++] = s->ButtonTextAlign.y;
   vec2s[i++] = s->SelectableTextAlign.x;
   vec2s[i++] = s->SelectableTextAlign.y;
   vec2s[i++] = s->SeparatorTextAlign.x;
   vec2s[i++] = s->SeparatorTextAlign.y;
   vec2s[i++] = s->SeparatorTextPadding.x;
   vec2s[i++] = s->SeparatorTextPadding.y;
   vec2s[i++] = s->DisplayWindowPadding.x;
   vec2s[i++] = s->DisplayWindowPadding.y;
   vec2s[i++] = s->DisplaySafeAreaPadding.x;
   vec2s[i++] = s->DisplaySafeAreaPadding.y;

   i = 0;
   for(i = 0;i<ImGuiCol_COUNT;i++) {
      cols[i*4+0] = s->Colors[i].x;
      cols[i*4+1] = s->Colors[i].y;
      cols[i*4+2] = s->Colors[i].z;
      cols[i*4+3] = s->Colors[i].w;
   }

   i = 0;
   dirs[i++] = s->WindowMenuButtonPosition;
   dirs[i++] = s->ColorButtonPosition;
   
   i = 0;
   hovers[i++] = s->HoverFlagsForTooltipMouse;
   hovers[i++] = s->HoverFlagsForTooltipNav;
;
    sendSlice<bool>(bs,bs_len);
    sendSlice<float>(fs,fs_len);
    sendSlice<float>(vec2s,vec2s_len);
    sendSlice<float>(cols,cols_len);
    sendSlice<int>(dirs,dirs_len);
    sendSlice<int>(hovers,hovers_len);
    flushSend();
  }
  }
  break;
case 0x00000405:
  {
    FFFI_FUNCTION_INVOCATION("TableGetSortSpecs")
    bool sort;
    bool dirty;
    uint32_t* userIds;
    int16_t* columnIndices;
    uint8_t* directions;
    {
    
		auto spec = ImGui::TableGetSortSpecs();
		size_t userIds_len = 0;
        size_t columnIndices_len = 0;
        size_t directions_len = 0;
        if(spec == nullptr) {
            sort = false;
            dirty = false;
        } else {
            sort = true;
            dirty = spec->SpecsDirty;
			userIds_len = spec->SpecsCount;
            columnIndices_len = userIds_len;
            directions_len = userIds_len;
            userIds = (ImGuiID*)arenaMalloc(userIds_len*sizeof(ImGuiID));
            columnIndices = (int16_t*)arenaMalloc(userIds_len*sizeof(int16_t));
            directions = (uint8_t*)arenaMalloc(userIds_len*sizeof(ImGuiSortDirection));
            for(size_t i=0;i<userIds_len;i++) {
               auto s = spec->Specs[i];
               userIds[i] = s.ColumnUserID;
               columnIndices[i] = s.ColumnIndex;
               directions[i] = s.SortDirection;
            }
        }
;
    sendValue<bool>(sort);
    sendValue<bool>(dirty);
    sendSlice<uint32_t>(userIds,userIds_len);
    sendSlice<int16_t>(columnIndices,columnIndices_len);
    sendSlice<uint8_t>(directions,directions_len);
    flushSend();
  }
  }
  break;
case 0x00000406:
  {
    FFFI_FUNCTION_INVOCATION("TableSetSortSpecsDirty")
    auto dirty = receiveValue<bool>();
    {
    auto spec = ImGui::TableGetSortSpecs();
        if(spec == nullptr){ return; }
        spec->SpecsDirty = dirty;
;
  }
  }
  break;
case 0x00000407:
  {
    FFFI_FUNCTION_INVOCATION("TableNextColumnP")
    {
    ImGui::TableNextColumn();
  }
  }
  break;
case 0x00000408:
  {
    FFFI_FUNCTION_INVOCATION("Toggle")
    auto label = receiveString();
    auto val = receiveValue<bool>();
    bool valR;
    bool changed;
    {
    changed = ImGui::Toggle(label,&val);
valR = val;
    sendValue<bool>(valR);
    sendValue<bool>(changed);
    flushSend();
  }
  }
  break;
case 0x00000409:
  {
    FFFI_FUNCTION_INVOCATION("ToggleV")
    auto label = receiveString();
    auto val = receiveValue<bool>();
    auto flags = receiveValueSignMagnitude<int>();
    auto animationDuration = receiveValue<float>();
    auto frameRounding = receiveValue<float>();
    auto knobRounding = receiveValue<float>();
    auto size = receiveArray<float,2>();
    bool valR;
    bool changed;
    {
    changed = ImGui::Toggle(label,&val,flags,animationDuration,frameRounding,knobRounding,size);
valR = val;
    sendValue<bool>(valR);
    sendValue<bool>(changed);
    flushSend();
  }
  }
  break;
case 0x0000040a:
  {
    FFFI_FUNCTION_INVOCATION("InvisibleButtonP")
    auto str_id = receiveString();
    auto size = receiveArray<float,2>();
    {
    ImGui::InvisibleButton(str_id, size);
  }
  }
  break;
case 0x0000040b:
  {
    FFFI_FUNCTION_INVOCATION("InvisibleButtonVP")
    auto str_id = receiveString();
    auto size = receiveArray<float,2>();
    auto flags = receiveValueSignMagnitude<int>();
    {
    ImGui::InvisibleButton(str_id, size, flags);
  }
  }
  break;
